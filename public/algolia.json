[{"objectID":"1743904772","permalink":"/post/gemma-3%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/","title":"Gemma 3的本地部署","content":"Gemma 3 被谷歌称为目前最强的开源视觉模型之一。 该模型支持超过35种语言，能够分析文本、图像和短视频。值得注意的是，Gemma 3 的视觉编码器经过升级，支持高分辨率和非方形图像，并引入了 ShieldGemma 2 图像安全分类器，用于过滤被分类为性暗示、危险或暴力的内容。这些特性使得 Gemma 3 成为当前最强大的开源视觉模型之一。\n最新的 Gemma 3 多模态开源模型新功能\r使用世界上最好的单加速器模型进行构建： Gemma 3 以其尺寸提供最先进的性能，在 LMArena 排行榜的初步人类偏好评估中胜过 Llama3-405B、DeepSeek-V3 和 o3-mini。这可以帮助您创建可安装在单个 GPU 或 TPU 主机上的引人入胜的用户体验。 以 140 种语言走向全球：构建使用客户语言的应用程序。Gemma 3 提供对超过 35 种语言的开箱即用支持和对超过 140 种语言的预训练支持。 打造具备高级文本和视觉推理能力的AI：轻松构建分析图片、文本、短视频等应用，开启交互智能化新可能1。 使用扩展的上下文窗口处理复杂任务： Gemma 3 提供 128k 令牌上下文窗口，让您的应用程序处理和理解大量信息。 使用函数调用创建 AI 驱动的工作流程： Gemma 3 支持函数调用和结构化输出，以帮助您自动执行任务并构建代理体验。 通过量化模型更快地实现高性能： Gemma 3 引入了官方量化版本，减少了模型大小和计算要求，同时保持了高精度。\n本地安装，单显卡可以选择1b，4b，12b，27b，推荐选择27b，因为Gemma 3 27B 处于帕累托最佳点.\n本地部署Gemma 3开源大模型：\r1、下载官方 Ollama 【 点击前往 】 ，并通过下方的安装命令执行下载：\n普通用户建议选择4b和12b，显卡好的可以上27b\nollama run gemma3:1b ollama run gemma3:4b ollama run gemma3:12b ollama run gemma3:27b 2、通过Cherry Studio,添加本地大模型后使用 ","date":"2025-04-06 09:59:32","updated":"2025-04-06 09:59:32"},{"objectID":"1743904772","permalink":"/post/git%E6%93%8D%E4%BD%9C/","title":"Git 常用命令记录","content":"\r回滚到指定提交\rgit reset \u0026ndash;hard c1ac53850b0314a20e97f669bafc8bb67a3a1124 git push 放弃变更强制提交\rgit reset \u0026ndash;hard ; git pull \u0026ndash;force 子模块的使用\r","date":"2025-04-06 09:59:32","updated":"2025-04-06 09:59:32"},{"objectID":"1743668483","permalink":"/post/md%E6%A0%BC%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Markdown文档编写不完全指南","content":"\r一、核心语法精要\r1. 标题与段落\r# 主标题（H1） ## 二级标题（H2） 普通段落直接换行书写，空行分隔段落 2. 列表系统 无序列表项 [x] 已完成任务 [ ] 待办事项 有序列表 第二项 3. 代码展示 ```python def hello_hugo(): print(\u0026#34;Welcome to Hugo Blog!\u0026#34;) 二、Hugo增强特性\n短代码应用 {{\u0026lt; highlight python \u0026ldquo;linenos=table\u0026rdquo; /\u0026gt;}} def hugo_shortcode(): return \u0026ldquo;Hugo特色功能\u0026rdquo; {{\u0026lt;/ /highlight \u0026gt;}} 响应式图片 {{\u0026lt; image src=\u0026quot;/images/md-example.png\u0026quot; alt=\u0026ldquo;Markdown示例\u0026rdquo; caption=\u0026ldquo;图1. 文档结构示意图\u0026rdquo; width=\u0026ldquo;80%\u0026rdquo; }}\n### 1. 基础语法 ```markdown ![替代文字](图片路径) 示例： ![技术架构图](/images/tech-arch.png) 三、可视化元素 流程图示例\ngraph TD\rA[开始] --\u003e B{判断}\rB --\u003e|条件1| C[操作1]\rB --\u003e|条件2| D[操作2]\r数据表格\n功能 语法示例 效果 脚注 内容说明^1 底部注解 定义列表 术语: 解释说明 层级关系 启动本地预览服务命令：\nhugo server -D 访问 http://localhost:1313 查看实时效果。请确保： 文件保存路径为 content/post/Markdown文档编写指南.md 已准备好示例图片 /images/md-example.png Hugo版本 ≥ 0.89.0（支持最新短代码语法） ","date":"2025-04-03 16:21:23","updated":"2025-04-03 16:21:23"},{"objectID":"1743224372","permalink":"/post/%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/","title":"提示词技巧","content":"提示词技巧 总结：\n官方提示词库： https://api-docs.deepseek.com/zh-cn/prompt-library\n","date":"2025-03-29 12:59:32","updated":"2025-03-29 12:59:32"},{"objectID":"1743173972","permalink":"/archives/25%E5%B9%B4%E4%B8%80%E5%AD%A3%E5%BA%A6%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/","title":"25年一季度汇报总结反思","content":"\r关于汇报过程的反思\r汇报过程难免还是有些紧张，感觉到不是内心害怕什么，就是单纯的紧张，可能是缺乏长时间汇报的经验，或者当初不擅长表达和总结。不过与以前对比效果稍好，这次准备的反而不多，可能是最后汇报的原因。并没有太多火力集中在我身上。 汇报往往会有许多问题和意见，对于别人的意见的看法，有些是好的意见，但是也不乏一些意见仅仅是提问人为了找存在感而提出来的。而且有些人相当强势，咄咄逼人，不给你反驳的机会。这种人往往都是狭隘和傲娇的，往往沉浸在自己的世界。对于这种意见，一笑了知即可。但是当触及到我们的棱角时，需要适当的发作。否则这些人会得寸进尺。 这次汇报准备并不充分，但是汇报效果反而不错。与之前精心准备，但是效果欠佳形成鲜明对比，这可能是心态上不重视，反而给自己临产发挥的空间，不至于被前期的准备束缚。当然，有些总结是不够的，更多的只是把组内做的事情陈列出来，缺乏系统性的总结，思路是不够清晰的。下次重点的提炼总结相关事项。 ","date":"2025-03-28 22:59:32","updated":"2025-03-28 22:59:32"},{"objectID":"1743173012","permalink":"/post/pytest%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88/","title":"pytest接口自动化测试方案","content":"\r背景\r当前业务核心聚焦于 POCT 领域，设备购买和设备使用等关键功能，已成为测试工作的重点保障对象，但随着系统复杂度的提升,手工的回归测试工作很难全面覆盖。为了确保关键业务功能的质量稳定性，有必要引入自动化测试，增加测试覆盖范围，降低已有功能漏测的风险，提前发现问题。\n目标\r短期目标：接入自动化测试（截至3月底）\n前期准备工作 预研不同的自动化测试框架，结合中长期目标与现实情况及各个框架的优缺点选择一套合适的自动化框架 对比几款常见接口测试框架 初步选定：pytest + Requests 语法简洁容易上手-接入成本低 灵活，社区支持好，插件丰富-适合复杂测试场景 制定初步的方案 自动化项目方案 项目框架搭建 确定实施方案 测试人员小范围接入自动化项目（跑通流程） 三月底能够将三款新设备正向检测流程转化为自动化测试脚本 **将慢病设备下单-上传检测结果流程；快速检测单流程接入接口自动化测试（正向检测流程） **将免疫、血球设备下单-上传检测结果（正向检测流程） 中期目标 ：自动化项目应用到测试工作流程（截至6月底）\n覆盖三款新设备装机到检测使用的全部场景\n覆盖设备装机到检测过程中的各项操作步骤和关键节点，从设备初始化到实际检测，确保各环节功能正常，数据交互准确，为用户提供稳定可靠的设备使用体验（包括异常流程）。 将自动化流程应用到测试工作流程。\n能有效增加测试覆盖率，减少漏测风险。 脚本的维护流程\n在接口变更，需求功能更改后如何维护 运行失败用例如何维护 长期目标：不断完善接口自动化，有效应用到研发测试工作流程（截至12月底）\n完善涉及用户相关的功能的自动化测试覆盖 对从商城购买到设备装机、检测、报告生成打印及检测后的慢病管理，全流程自动化测试，保障用户使用系统过程中的顺畅性，避免因流程问题导致的交易失败或用户体验不佳情况。 将自动化测试无缝应用到现有的研发测试工作流程中。 替代大部分回归测试，提高测试效率，进一步减少漏测风险。 自动化测试成为常态化测试手段,能提前发现问题,有效提升整体工作效率。 自动化测试工具选型\r自动化测试框架-pytest + Requests 几款常见接口测试框架对比详情：\npytest + Requests\n语法简洁容易上手-接入成本低 灵活，社区支持好，插件丰富-适合复杂测试场景 已有相关基础 选型依据 兼容性、适合复杂流程交互（设备交互）、丰富的社区支持、接入成本\n测试管理工具（飞书或tapd） 自动化用例管理接口自动化测试用例 CI/CD工具 GitLab CI uvicorn+fastapi 部署+接口 自动化测试用例设计\r用例分层设计 基础类（/api） 根据接口文档生成 测试用例（/tests） 基础功能用例（原子级-单个接口测试） 定义 ：针对单个接口的独立测试，关注接口的输入输出正确性、异常处理能力及边界条件验证。例如，用户登录接口的独立测试需覆盖正常登录、密码错误、账号不存在等场景 特点 ： 原子性 ：每个用例仅验证一个接口的单一功能，不依赖其他接口或业务流程。 高复用性 ：可作为其他复杂用例的构建单元，例如登录接口的测试结果可被后续业务流程用例复用 技术实现 ：通常结合数据驱动设计（如参数化测试数据），通过多组输入数据覆盖等价类和边界值 业务流程用例（端到端、涉及多个接口和流程的测试） 定义 ：模拟真实用户操作路径，串联多个接口验证端到端业务逻辑。例如“创建商品→创建优惠券→创建活动→下单支付”的全流程测试 特点 ： 场景化 ：基于用户使用的功能场景设计，关注接口间的数据传递与状态流转。 风险覆盖 ：重点验证流程中的关键节点（如订单状态变更、库存扣减）和异常分支（如支付超时回滚） 依赖管理 ：通过关键字驱动设计（如“获取Token”“查询订单状态”）复用基础功能用例，降低冗余代码 测试数据（/data） 存放测试数据 提供测试数据的脚本 工具(/utils) 工具类集合 数据驱动设计 参数化测试数据（Excel、csv、数据库）\n关键字驱动设计 可复用的关键字库（如获取token、查询）\n测试执行策略\r触发条件 开发人员提交代码触发\n手动触发\n优先级划分(暂不考虑) 高（核心功能）、中（高频场景）\n失败重试机制 自动重试与日志记录\n** 持续集成（CI/CD）**\r集成流程 代码提交 → 静态检查 → 单元测试 → 自动化测试 → 报告生成 流水线配置 GitLab CI YAML配置 结果通知 企业微信群通知 风险管理\r潜在风险 环境不稳定 脚本维护成本 需求功能变更 应对措施 设计时需要提前考虑脚本稳定性 定期维护脚本 运行前保证环境正常可用 相关交付物\r测试报告 HTML报告 自动化脚本 代码仓库https://gitlab.guangpuyun.cn/clinic-diag/test/poct_api_test\n项目结构\n文档 初始化文档快速编写Pytest接口测试 自动化用例设计文档接口自动化测试用例 维护与优化\r脚本维护人员 一般情况下谁写的谁维护 脚本维护方法 接口变更的处理 用例执行/定时/手动触发脚本爬取接口文档，并与最新接口文档对比\n运行main.py 执行用例时，会在warnning日志提醒相关变更 检查变更是否涉及已经编写的用例（快捷键ctrl+shift+f搜索关键词即可） 如：PoctCreateOrderInModel存在差异，对应json文档中找到对应 operationId（文件名），在用例文档中搜索createOrder2UsingPOST_1 ，发现涉及已有用例。\n若有涉及用例，则维护成最新接口信息。\n当用例运行报错/不通过进行定位 bug-\u0026gt;记录并通知开发修复； 数据问题-\u0026gt;使用自动化专用的数据，避免污染； 脚本本身不稳定导致的运行失败，维护脚本能稳定运行，若维护成功过高可直接先注释脚本，并在对应用例做好备注“待维护”。 脚本维护代办事项 接口自动化代办事项 ","date":"2025-03-28 22:43:32","updated":"2025-03-28 22:43:32"},{"objectID":"1742910212","permalink":"/archives/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","title":"《金字塔原理》解析","content":"\r《金字塔原理》读书笔记（全）\r一、 表达的逻辑 1. 为什么要用金字塔？ 2. 金字塔内部结构 3. 如何构建金字塔？ 4. 序言的具体写法 5. 演绎推理与归纳推理 二、 思考的逻辑 6.应用逻辑顺序 （一）时间顺序 （二）结构顺序 （三）程度顺序 7.概括这种思想 （一）行动性思想的概括——说明采取行动的结果/目标 （二）描述性思想的概括——找出各结论之间的共性 三、 解决问题的逻辑 8.界定问题 （一）界定问题的连续分析法： （二）界定问题的框架 9.结构化分析问题 四、 演示的逻辑 10.在书面上呈现金字塔 11.在PPT中呈现金字塔 12.在字里行间呈现金字塔 读后心得 部分参考笔记： 《金字塔原理》资源EPUB：链接：https://pan.baidu.com/s/1-2uv0ktITGT51ft603KfCQ 提取码：aioh 《金字塔原理》资源PDF：链接：https://pan.baidu.com/s/1Z5WIpUSCm9qr7sJhDyf-sQ 提取码：h1sk 12345AI写代码 金字塔原理是为了解决沟通、表达或是思考问题时思维混乱、分不清主次的问题。而其背后的方法论就是–搭建金字塔，以金字塔原理进行表达。书分为四部分：\n表达的逻辑：说，使用金字塔原理的原因和具体构建方法； 思考的逻辑：想，使用金字塔原理过程中的应用逻辑要素； 解决问题的逻辑：做，在实例中界定、解构、分析、解决问题； 演示的逻辑：表演，在PPT演示中和文字中呈现金字塔。 一、 表达的逻辑\r1. 为什么要用金字塔？\r究其原因是和人脑的思维逻辑有关系，人们思考的习惯方式倾向于对输入信息进行自动联想和关联，而对于那些没有逻辑或关联的内容习惯性忽略。所以金字塔结构表达，加强逻辑关联，可以让我们沟通更加高效。《金字塔原理》中指出，人类的思维结构一般有以下几个规律：\n大脑会自动将有相关联的信息进行归类； 一次记忆不超过7个思想、概念或项目； 在进行观点阐述时将背景、冲突、疑问等进行说明与解答可以更好地吸引读者注意力。 因此当我们在进行写作和演讲活动时，为了让受众更好地了解并接受我们所表达的观点我们必须：\n归类分组，将思想组织成金字塔：将关键词罗列出来，并组织归类； 找出逻辑关系，抽象概况：找到同类内容之后，我们需要对这部分共性内容进行抽象； 自上而下表达，结论先行：当我们先提出总的概念，再列出具体项目，即自上而下地呈现思想时，可以最有效的进行沟通和写作表达，类似于从收敛到发散的过程，脑图结构； 自下而上思考，总结概括：思维从底层开始构建，句子按照某种逻辑顺序组成段落，之后将段落组成章节，最后章节组成文章，金字塔最顶端的思想（中心思想、核心观点）代表整片文章观点。文章的思想有三种关联方式：向上、向下、横向。 纵向：文章中每一层次上的思想必须是对下一层次思想的概括 横向：每组中的思想必须同属于同一逻辑范畴 横向：每组中思想必须按逻辑顺序组织 而思想的组织存在4种逻辑顺序：\n演绎顺序：大前提、小前提、结论 时间（步骤）顺序：第一、第二、第三 结构（空间）顺序：波士顿、纽约、华盛顿 程度（重要性）顺序：最重要、次重要 2. 金字塔内部结构\r纵向关系：纵向关系是疑问-回答式的表达方式，让读者产生”为什么这么做的想法“，类似于层层推理。 横向关系：横向关系是某一个层次的表述需要能够承上启下，保证本层次内容合乎逻辑。 序言结构：为了让读者在文章开头就能够了解作者想要表达的内容，也就是说为了读者和作者从文章开始可以“站在同一角度”看问题，我们可以对文章的背景和问题进行描述，这样也可以使得接下来的叙述可以更好地进行。\n3. 如何构建金字塔？\r自上而下：\n提出文章主题思想 设想受众主要疑问 写序言：背景—冲突—疑问—回答，说明“背景”，指出“冲突”，检查“疑问”和“回答 与受众进行疑问—回答式对话 对受众的新疑问，重复进行疑问—回答式对话 自下而上：\n提出文章主题思想 设想受众主要疑问 写序言：背景—冲突—疑问—回答，说明“背景”，指出“冲突”，检查“疑问”和“回答” 与受众进行疑问—回答式对话 对受众的新疑问，重复进行疑问—回答式对话 初学者注意事项：\n先搭结构，尝试自上而下法 序言先写背景，将背景作为序言的起点 多花时间思考序言（背景—冲突—疑问—回答），不要省略 将历史背景放序言中 序言仅涉及读者不会对其真实性提出质疑的内容 在关键句层次上，更宜选择归纳推理法 4. 序言的具体写法\r基本结构：SCQA（背景—冲突—疑问—回答）\nS-Situation—介绍背景 C-Complication—指出冲突 Q-Question—引发疑问 A-Answer—给出答案 eg. 背景（S）—本公司的业务多元化研究服务在过去5年中增长了40% 冲突（C）—无法保证我们的工作对客户有明显益处 疑问（Q）—如何确保多元化研究确实对客户研究有明显益处？ 回答（A）—实施“公司发展项目”，以研究该问题 序言的常见模式：根据文章的风格陈述顺序也可以做出调整：\n标准式：背景—冲突—答案 开门见山式：答案—背景—冲突 突出忧虑式：冲突—背景—答案 突出信心式：疑问—背景—冲突—答案 书写序言时需要遵循以下原则： 1.序言的目的是“提示”读者而不是“告诉”读者某些信息 2.序言必须包含故事所需要的3个要素，“冲突”、“背景”、“答案” 3.序言的长度取决于读者和主题的需要\n5. 演绎推理与归纳推理\r演绎推理：是一系列线性的推理过程，譬如最经典的三段论，大前提+小前提，推导出结论。最终是为了得出一个由逻辑词“因此”引出的结论。 ☞ 举个例子: 比如用这三个步骤去进行推理，就可以按照以下步骤 ➀ 出现的问题或存在的现象 ➁ 产生问题的根源 / 原因 ➂ 解决问题的方案 归纳推理：将具有共同点的事实、思想或观点归类分组，并概括其共同性。\n其中在归纳时，应遵循 MECE 原则：\n1.各部分之间相互独立，相互排斥，没有重叠。（Mutually Exclusive ） 2.所有部分完全穷尽，没有遗漏。（Collectively Exhaustive ）\n演绎推理与归纳推理的区别： 演绎推理，第二点是对第一点主语或谓语的论述。 归纳推理，同组中的思想具有类似的主语或谓语。\n二、 思考的逻辑\r这部分介绍了如何深入细致地把握思维的细节 以保证你使用的语句真实，明确地呈现你希望表达的思想 12AI写代码 在上文中介绍了金字塔模型的结构，但在我们日常写作中依旧会面临以下两个问题：\n概括在一起的思想并不具有关联性 表达中心思想的句子“缺乏思想性” 因此为了将所有表达的思想联系起来，确定逻辑顺序并概括隐含意义，我们就需要继续学习逻辑顺序的确定和概括各组思想的方法。\n6.应用逻辑顺序\r大脑的归纳分组活动：\n1.确定前因后果关系——时间（步骤）顺序 2.将整体分割为部分——结构（空间）顺序 3.将类似事物归为一组——程度（重要性）顺序 （一）时间顺序\r运用时间顺序，首先一定要区分出原因和结果，其次需要揭示出隐含的逻辑思路。\n例： 在第一阶段应采取以下措施： 1.与主要管理人员及监管人员谈话 2.跟踪并记录交易行为和工作流程 3.确定所有关键业务环节 4.分析组织结构 5.理解服务和绩效措施 6.评估业务职能的绩效水平 7.找出问题和原因 8.发现提高生产效率的潜在可能性 12345678910AI写代码 分析上面例子我们发现它超出了我们之前说的大脑一次最多记忆的数字“7”，并且表达的思想逻辑出现混乱，如果我们能区分以上例子中行动的原因和行动产生的结果，就可以达到以下效果：\n1.确定企业的关键业务（3） —与主要人员沟通（1） —跟踪并记录交易行为和工作流程（2） 2.找出开展业务时存在的弱点（7） —调整组织结构（4） —制定并实施服务和绩效管理措施（5） —评估绩效水平（6） 3.提出切实可行的改革建议（8） 12345678AI写代码 在按照时间顺序组织的思想中，主题句是要达到的结果，表述思想的顺序与采取行动的顺序（第一步、第二步、第三步）一致。 1AI写代码 （二）结构顺序\r在使用结构顺序时，我们先需要了解MECE原则： 1.各部分之间相互独立，相互排斥，没有重叠。（Mutually Exclusive ） 2.所有部分完全穷尽，没有遗漏。（Collectively Exhaustive ） 以上图为例，在一个公司分支结构中轮胎部、硬件部、体育设备部等部门之间是相互独立的，但是在公司的下级结构中所有部门又都要包含到，因此就是“相互独立，完全穷尽”。\n如果划分时强调活动本身，那么各部分展现的就是一个逻辑过程（流程），应采用时间顺序。 如果划分时强调地点，那么各部分呈现的地理状况，应采用结构顺序。 如果划分时强调与某一产品或市场有关的活动，那么划分就是一种归类。 （三）程度顺序\r程度顺序，也称为重要性顺序，对一组因为具有某种共同特点而聚集在一起的事物进行陈述或分析时采用的顺序。例如在思考“一家公司存在的问题”时，一般会列出该公司存在的主要三个问题以及存在的其他次要问题，当然这几个问题要满足完全穷尽的要求，也要做到相互排斥。 一般情况下第一步，先明确每组中的问题具有的共同特性，确保将拥有同一特性的问题列入同一组中；第二步，每组问题中，所有特性的程度高低排序，最有问题的放在第一位，先强后弱。\n例：客户对销售报告和库存报告不满意： 1.提交报告的周期不恰当 2.库存数据不可靠 3.获得库存数据的时间太迟 4.库存数据与销售数据不吻合 5.客户希望能改进报告的格式 6.客户希望除去无意义的数据 7.客户希望突出说明特殊情况 8.客户希望减少手工计算 123456789AI写代码 正确分类归组的例子\n1.时机不对 1）提交报告的周期不恰当 3）获得库存数据的时间太迟 2.数据不符合要求 2）数据库存不可靠 4）库存数据与销售数据不符合 6）客户希望去除无意义的数据 3.格式不对 5）客户希望能改进报告的格式 7）客户希望突出说明特殊情况 8）客户希望减少手工计算 1234567891011AI写代码 最后根据需要的回答来进行重要性程度的排序：\n问题一：为什么系统会生成没有意义的报告（编制过程） 2.收集的数据不可靠 3.报告的格式混乱 1.生成报告的时间太晚，无法采取有效的行动 问题二：为什么客户不喜欢这种报告（阅读过程） 1.提交报告的时间太晚 3.阅读报告时无法找到所需数据 2.即使找到数据，数据也是错误的 问题三：如何解决该问题（解决问题的过程） 3.确定所需要的数据及其格式 2.确保报告中数据的可靠性 1.确保及时提交报告 1234567891011121314AI写代码 在了解一组思想表达观点的流程，要做到：\n1.确定该组思想的类别\n2.将同一类型的思想归类、分组\n3.找出各类别思想之间的顺序\n7.概括这种思想\r缺乏思想的句子对于一方面对于读者而言枯燥无味，另一方面对于作者而言很难表达出自己想要表达的含义。因此我们要避免使用缺乏思想的句子，说明采取行动的结果/目标，找出各结论之间的共性。\n在金字塔结构中我们提到过，上一层的思想是从下一层中衍生、提炼、总结出来的。因此，我们可以通过将一组思想归类，再进行抽象、提炼、概括的方法，来得到得到概括性思想。当我们获得概括性思想，就可以使用 演绎法（对其做进一步评论）或者使用归纳法（找出与之类似的思想） 的方法来扩展思路。\n所以，多花些精力从思想组提炼出正确的概括性思想非常重要！ 如何概括呢？一般分为行动性思想的概括和描述性思想的概括。\n概括行动性思想（介绍采取的行动、行为、步骤、流程）时，应说明采取行动后取得的“结果”（效果、达到的目标）。\n概括描述性思想（介绍背景、信息）时，应说明这些思想具有的“共同点的含义”（共同点的意义）。\n如何表达？ 1.在将各行动（步骤、流程等）联系起来之前，先用明确的语句描述各行动（步骤、流程等）。 2.找出明显的因果关系组合，尽量将每一组中的行动、步骤控制在5个以下。 3.直接从这些行动、步骤、流程，总结、概括行动的结果、目标。 1234AI写代码 （一）行动性思想的概括——说明采取行动的结果/目标\r在进行行动性思想概括时，我们要先采取行动是为了达到某种目的。当我们采取一系列行动，会产生特定的结果，然后根据这些特定的结果我们又会采取下一部行动。因此根据相互独立、完全穷尽的行动性思想及所产生的结果，就形成一个封闭体系。\n根据产生的结果将行动性思想分组\n当罗列出一些实现某一目标应当采取的行动时，必须先指出这些行动将会达到的结果，才能判断自己是否有遗漏，因此在使用行动性思想进行概括时，可以记住以下几个原则：（P169） 1.总结句要用明确的语言概括，说明行动产生的结果，用明确的语言描述各项行动、步骤、流程等 2.区分行动、步骤的层次找出明显的因果关系，将每一组行动、步骤控制在5个以内 3.直接概括行动的结果，利用行动、步骤、流程来总结、概括行动的结果、目标\n总结行动产生的结果之后要注意： 1.该组行动、步骤之间必须相互独立不重叠、完全穷尽无遗漏 2.总结概括性语句必须说明各项行动、步骤导致的直接结果，且措辞必须明确、具体 3.先用明确的语句表述各项行动、步骤、流程等，然后区分不同的抽象层次，再从各行动、步骤、流程等总结概括出行动的结果 1234AI写代码 （二）描述性思想的概括——找出各结论之间的共性\r描述性思想通常可以用“原因”“问题”或“结论”之类的单一名词表示，对描述性思想的概括可以帮助读者更好发现作者想要表达的观点。概括的基础是这些思想具有某种共性，如果要能够从描述性思想中提炼出概括性语言，就可以根据以下步骤来完成推论：\n找共性：首先要找出这些思想结构上的共性，即明白一组思想是否属于同一范畴，因此可以观察这些思想是否针对同一类主语、同一类谓语（动作或对象）或者具有同一类隐含思想 找联系：其次发现思想之间所具有的共性之后，再寻找这些思想更密切的联系 概括主旨：最后完成归纳跃进，概括出主题思想 三、 解决问题的逻辑\r这类文章需要回答的3个问题之一： 我们应该做什么？（如果不知道解决方案） 我们应该做吗？（如果已经给出了解决方案） 我们应该怎么做？你会怎么做？（如果已经知道且接收解决方案） 1234AI写代码 解决问题逻辑的流程：\n界定问题\u0026mdash;\u0026ndash;\u0026gt;结构化\u0026mdash;\u0026ndash;\u0026gt;分析/找到\u0026mdash;\u0026mdash;-\u0026gt;组成金字塔 分析问题 解决方案 与他人交流\n提高写资讯报告效率的秘密：\n界定问题。 有条理地搜集和分析数据，转换为金字塔的形式。 8.界定问题\r（一）界定问题的连续分析法：\r概念： （1）判断问题是否存在：看经过努力得到的结果（现状），与希望得到的结果（目标）之间是否有差距。 （2）非期望结果（R1）：即现状，由某一特定背景导致的某一特定结果 （3）期望结果（R2）：即目标，你不喜欢某一结果，想得到其他结果 （4）解决方案：如何从R1到R2 连续分析方法： （1） 界定问题（文章的序言） - 有没有/是否有可能有问题（或机会）？ - 问题在哪里？ （2） 结构化分析原因：为什么存在？（产生问题的根源、原因） （3） 寻找解决方案 - 我们能做什么？ - 我们应该做什么？ 12345678AI写代码 （二）界定问题的框架\r界定问题的框架需要回答的3个问题：\n发生了什么事？【背景（切入点/序幕+困扰/困惑）】 我们不喜欢它什么？（非期望结果R1） 我们想要什么？（期望结果R2） 把“界定的问题”写成序言：\n方法： 得出界定问题的框架后，只需遵循从左到右，再到下的原则，把读者最后了解的事实作为序言的冲突部分，并在此基础上提出问题。 目的： 分析和修改解决方案的辅助手段 - 展开问题的基本部分（运用框架） - 你的解决方案处于哪一阶段（已经提出了，还是已经被接受了） - 提出适当的疑问 - 检查序言是否呈现了界定的问题 - 检查金字塔原理是否回答了疑问 展开问题的各要素：\n切入点/序幕：简单的设想和简短的描述 困扰/困惑：外部原因、内部原因、近期认识到的其他原因 R1现状，非期望结果 对公司结构或流程产生负面影响 扰乱某一特定方面的工作 引发对业务、产品、流程的重新考虑 挑战有关客户、市场、竞争、核心竞争力、流程或技术的基本假设 R2目标，期望结果（具体和定量的描述） 用具体数字 用具体的最终结果 发掘读者的疑问（1） 最常见的问题\n不知道如何从R1（现状）到R2（目标） 知道如何从R1到R2，但不敢肯定是否正确 知道从R1到R2的正确方案，但不知道如何实施 （2） 最常见问题的变形\n知道从R1到R2的解决方案，并且已经实施，但由于某种原因行不通 确定了好几个解决方案，但不知道选哪一个 （3） 可能但不常见的情形\n知道R1，但不能具体描述R2，所以无法找到解决方案 知道R2，但不清楚自己是否处在R1（典型的杠杆比对） 开始写序言 （1） 我们应该做什么 S：系统目前的工作情况 C：它不做它该做的工作 Q：如何让它做它该做的工作？ （2） 我们是否应该做我们想做的事 S：我们存在问题 C：我们计划采取行动 Q：该行动是否正确？ （3） 我们应该如何做我们想做的事 S：我们曾经存在的问题 C：通过X行动我们解决问题 Q：你是如何进行X行动的？ （4） 解决方案行不通，我们应该做什么？ S：我们遇到问题并采取了数项措施 C：目前没有任何效果 Q：我们应该做什么 （5） 我们应该选择哪种方案？ S：我们计划实施X方案 C：有人提出Y可能是更好的方案 Q：哪种方案最好？ （6） 我们应该采用哪些战略？ S：我们目前是大市场中的小企业 C：不知道潜力是否发挥，但知道和顶级企业还有较大差距 Q：我们应该采取哪些战略？ （7） 我们存在问题吗？ S：新的市场划分带来很大变化 C：有看法认为这些变化对处于该行业中的企业不利 Q：该看法有无道理？为什么？ 1234567891011121314151617181920212223242526272829AI写代码 9.结构化分析问题\r从信息资料入手 设计诊断框架 如何设计诊断框架：相互独立， 完全穷尽的列举 呈现有形结构 寻找因果关系：还是穷举的方案，进行层层的原因下分，并把可能的原因进行分类 1.财务结构 2.活动（行动、措施）结构 将产生问题的可能原因进行分类 使用诊断框架 客户面临的问题 分析的方法 建立逻辑树 序列分析法：P271 1.是否有问题？ 2.问题在哪里？ 3.为什么存在？ 4.我们能做什么？ 5.我们因该做什么？ 寻找解决方案 （1）根据“相互独立，完全穷尽”的原则，对各种可能性作一个系统的逻辑细分 （2）计算相关收益和评估每种行动方案的风险，以便确定一套最终的解决方案 寻找各组思想的缺陷 是非问题分析 适用框架： -需要做出紧急决策 -不止一个方案有优点 -存在很多变数，需要考虑的目标也很多 -衡量结果的标准各不相同，还经常冲突 -行动的最终结果可能对其他方面的决策产生显著影响 是非问题分析的错误概念 关键步骤： 1.按先后顺序画出该政策领域的图解，标明每个阶段的主要决策变量（MVD），包括影响每项活动的环境、经济、管理和社会因素。 2.对这些主要决策变量如何影响目标的实现提出假设，并根据对目标实现有重要影响的主要决策变量，决定应该作出哪些决策。 12345678910111213141516171819202122232425262728293031323334AI写代码 PS： 关于这两章的内容不理解这两章想表达的含义 1、所举的例子似乎不太贴合自身的应用范围 2、举例冗余，表达不够简洁。\n四、 演示的逻辑\r10.在书面上呈现金字塔\r在页面上实现的金字塔的结构，在篇幅比较长的时候可通过：\n多级标题 下划线发 数字编号法 行首缩进法 项目符号法 PS:主要是格式问题需要注意。\n11.在PPT中呈现金字塔\rPPT展示文稿必须要了解和掌握的基本规则：\n文字幻灯片应仅包含最重要的、经过分组和总结的思想 PPT展示应当图文并茂 PPT应当是经过深思熟虑的故事梗概和脚本 PPT内容的 图片：文字 = 9：1 关键点： 1.每次展示仅一个论点 2.论点采用陈述句 3.文字尽量简短 4.简单的词语和数字 5.字号足够大 6.幻灯片的趣味性 7.逐级展开 12345678AI写代码 PS：这些都是做PPT的最常用最基本的原则。\n12.在字里行间呈现金字塔\r表达的词藻不一定要专业术语的堆砌，读者理解为首要。 图像以说明抽象概念（以强调自己表述的内容） 读者通常会以“图像”的方式进行信息的摄取。 因此，在文字表述前自己应当对要表述的内容建立脑图，不仅帮助自己理解要表达的内容，同时，也能够帮助作者写出文章。\n读后心得\r这本书主要是讲一些方法论，本文中心：\n任何事情都可以归纳出一个中心论点，而此中心论点可由三至七个论据支持，这些一级论据本身也可以是个论点，被二级的三至七个论据支持，如此延伸，状如金字塔； 界定问题，搜集分析，条理明晰，大胆归纳，小心演绎。 个人感觉需要“理论联系实际”才能把这本书的作用发挥到最大程度。没读这本书之前，其实在平常的工作生活中已经悄然的用上了书中部分方法，譬如：“总-分-总”三段式写法、脑图、PPT制作原则等。在读完之后，也能更加清楚的了解到自己需要使用哪种方法论来进行阐述自己的观点，可以更加灵活的运用起来，也确实是能够帮助自己快速融入以后的职场，以结果为导向，能够迅速抓住重点，并进行归类分析，帮助自己快速发现问题。\n部分参考笔记：\r[1] 读书笔记|《金字塔原理》—思考问题的逻辑. [2] 表达、思考和解决问题的逻辑（金字塔原理-高质量读书笔记）. [3] 十分钟读完《金字塔原理》. [4]《金字塔原理》这样的书应该怎样阅读，读起来会不会有很累的感觉？.\n","date":"2025-03-25 21:43:32","updated":"2025-03-25 21:43:32"},{"objectID":"1742875200","permalink":"/post/gitlab%E9%85%8D%E7%BD%AEcicd%E5%B7%A5%E4%BD%9C%E6%B5%81/","title":"gitlab配置cicd工作流","content":"\rGitLab CI/CD 简介\rGitLab CI/CD 是 GitLab 内置的持续集成/持续部署工具，它允许开发者在代码提交后自动执行一系列任务，如构建、测试和部署。通过配置 CI/CD 流程，可以大大提高开发效率，减少人为错误，并确保代码质量。\nCI/CD 核心概念\r持续集成 (CI): 开发人员频繁地将代码集成到主分支，每次集成都通过自动化构建和测试来验证，从而尽早发现问题。 持续交付 (CD): 确保代码随时可以部署到生产环境，通常包括自动化测试和部署流程。 持续部署 (CD): 将持续交付更进一步，自动将通过测试的代码部署到生产环境。 .gitlab-ci.yml 配置文件\rGitLab CI/CD 的核心是 .gitlab-ci.yml 文件，它定义了 CI/CD 流水线的结构和行为。该文件需要放在项目的根目录下。\n基本结构\r# 定义阶段 stages: - build - test - deploy # 定义作业 build_job: stage: build script: - echo \u0026#34;Building the app\u0026#34; - make build test_job: stage: test script: - echo \u0026#34;Running tests\u0026#34; - make test deploy_job: stage: deploy script: - echo \u0026#34;Deploying the app\u0026#34; - make deploy only: - master 关键组件\rstages: 定义流水线的阶段，按顺序执行。 jobs: 定义在特定阶段执行的任务。 script: 在作业中执行的命令。 only/except: 控制作业何时运行（例如，只在特定分支上运行）。 GitLab Runner\rGitLab Runner 是执行 CI/CD 作业的代理，它可以安装在不同的环境中，如 Linux、Windows、macOS 等。\n安装 GitLab Runner\r# 在 Linux 上安装 curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash sudo apt-get install gitlab-runner # 在 macOS 上安装 brew install gitlab-runner 注册 Runner\rsudo gitlab-runner register 注册过程中，需要提供 GitLab 实例的 URL 和注册令牌，以及 Runner 的标签和执行器类型。\n高级配置\r环境变量\rvariables: DATABASE_URL: \u0026#34;postgres://postgres:postgres@postgres:5432/my_database\u0026#34; job_name: variables: DATABASE_URL: \u0026#34;postgres://postgres:postgres@postgres:5432/my_test_database\u0026#34; script: - echo $DATABASE_URL 缓存和构件\rcache: paths: - node_modules/ job_name: artifacts: paths: - dist/ expire_in: 1 week 依赖关系\rjob_name: stage: deploy dependencies: - build_job script: - echo \u0026#34;Deploying the app\u0026#34; 实际应用示例\rNode.js 项目\rimage: node:14 stages: - build - test - deploy cache: paths: - node_modules/ build: stage: build script: - npm install - npm run build artifacts: paths: - dist/ test: stage: test script: - npm run test deploy_staging: stage: deploy script: - npm install -g firebase-tools - firebase use staging - firebase deploy --token $FIREBASE_TOKEN only: - develop deploy_production: stage: deploy script: - npm install -g firebase-tools - firebase use production - firebase deploy --token $FIREBASE_TOKEN only: - master when: manual Python 项目\rimage: python:3.9 stages: - test - deploy before_script: - pip install -r requirements.txt test: stage: test script: - pytest deploy: stage: deploy script: - pip install awscli - aws s3 sync ./dist s3://my-bucket/ only: - master CI/CD 最佳实践\r保持流水线简单：只包含必要的步骤，避免过度复杂化。 使用缓存：缓存依赖项可以显著提高构建速度。 并行执行：将独立的任务并行执行以节省时间。 环境变量管理：使用 GitLab 的变量功能安全地存储敏感信息。 分支策略：为不同的分支配置不同的 CI/CD 行为。 故障排除\r常见问题\rRunner 无法连接：检查网络设置和 Runner 注册信息。 构建失败：查看日志以确定失败原因，可能是依赖项问题或脚本错误。 权限问题：确保 Runner 有足够的权限执行所需操作。 调试技巧\rjob_name: script: - set -x # 启用调试模式 - env # 打印环境变量 - ls -la # 列出文件 结论\rGitLab CI/CD 是一个强大的工具，可以自动化软件开发的各个阶段。通过正确配置 .gitlab-ci.yml 文件，可以实现代码的自动构建、测试和部署，提高开发效率和代码质量。随着对 CI/CD 实践的深入理解，可以进一步优化流水线，使其更加高效和可靠。\n","date":"2025-03-25 12:00:00","updated":"2025-03-25 12:00:00"},{"objectID":"1742875200","permalink":"/post/encrypted-example/","title":"加密文章示例","content":"\r这是一篇加密的文章\r只有输入正确的密码才能查看这篇文章的内容。\n如何设置文章加密\r在文章的前置参数中添加以下内容：\nencrypted: true password: \u0026#34;你的密码\u0026#34; 这样就可以为文章添加密码保护了。\n密码保护的工作原理\r当用户访问加密文章时，会显示密码输入框 用户输入正确的密码后，文章内容才会显示 密码验证在浏览器端进行，不需要服务器支持 使用sessionStorage保存解锁状态，避免刷新页面后需要重新输入密码 注意事项\r这种加密方式只是前端加密，不能防止真正的黑客攻击 适合用于简单的内容保护，不适合保护高度敏感的信息 密码直接保存在文章的前置参数中，所以不要使用您在其他地方使用的重要密码 ","date":"2025-03-25 12:00:00","updated":"2025-03-25 12:00:00"},{"objectID":"1742569232","permalink":"/post/%E4%BD%BF%E7%94%A8gihub%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/","title":"将github变为免费图床","content":"\r使用 GitHub 作为免费图床的文档\r最近就想找一款免费的图床来放置自己的图片，逛了一圈下来发现GitHub可以白嫖，于是乎，就有了这篇文章。\nGitHub 是一个非常流行的代码托管平台，除了代码存储外，你还可以使用 GitHub 来托管静态资源，比如图片。通过将图片上传到 GitHub 的仓库，你可以轻松获取图片的 URL，从而在网页或文档中嵌入这些图片。以下是如何使用 GitHub 作为免费图床的详细步骤。\n步骤 1: 创建 GitHub 仓库\r登录到 GitHub。\n点击右上角的 \u0026ldquo;+\u0026rdquo; 按钮，然后选择 \u0026ldquo;New repository\u0026rdquo;。\n填写仓库的名称（例如：my-image-hosting），并设置为公开（Public）。\n点击 \u0026ldquo;Create repository\u0026rdquo; 创建仓库。\n步骤 2: GitHub获取个人的Token\r访问：settings-tokens ，点击Generate new token 2.设置 token 属性 ，Expiration：永不过期，Select scopes：repo 一定要全选，其他的无所谓 ，点击最下方创建\n就会获得一个token字符串， ⚠️ 注意：一定要收藏好 token，因为只会显示一次！，关掉这个页面就再也看不见了。 [!IMPORTANT] 后续会继续使用这个token!!!!\n步骤 3: 下载PicGo\r在PicGo最新页面上下载它的安装包。PicGo下载页面 安装PicGo。无需赘述\n配置GitHub\n​\nPicGo 上传区配置选中你的配置 ​ 选择完成配置之后就可以拖拉拽上传文件了。\n步骤 4: Typora中使用\r打开Typora，在文件选项中选中偏好设置。 在图像选项中勾选你的安装路径 使用方式： 在Typora粘贴一张图片，右击图片上传，图片会上传并自动转换成链接\n++++\n使用 GitHub 图床大功告成！\r恭喜你完成了 GitHub 图床的配置！ 通过本文的引导，你已经学会了如何：\n创建 GitHub 仓库并上传图片； 获取并配置个人 Token； 使用 PicGo 工具进行图片上传； 在 Typora 中无缝集成并自动生成图片链接。 通过这个流程，你可以快速搭建自己的高效图床，结合 GitHub 和 JsDelivr CDN，免费、稳定且速度快！无论是博客写作还是前端项目开发，这都将是一个非常棒的工具！\n详情请参考我的博文: 使用GiHub作为图床 | 变量人生\n希望这篇教程对你有所帮助！祝你工作愉快，写作顺利！\n","date":"2025-03-21 23:00:32","updated":"2025-03-21 23:00:32"},{"objectID":"1742533172","permalink":"/post/%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%88%86%E4%BA%AB/","title":"测试平台教程","content":"一、基本介绍：（） 桌面端工具（一年左右），使用python的wxpython框架编写，使用pyinstaller打包为桌面exe文件；缺点：体积大，不便于分享；\nweb端应用（10月初至今）：flask+vue实现；优点，通过脚本实现热更新；链接形式便于分享。\n二、功能介绍：\n三、技术实现\n测试平台采用前后端分离的方式实现:\n后端由flask框架实现； （1）flask项目结构 （2）在项目入口文件中构建接口 Flask：用于创建一个flask应用,app = Flask(name) CORS:解决跨域问题，cors = CORS(app) request:接受请求的参数，request.args.get()；phone = request.json[] jsonify:以json格式返回结果：jsonify({\u0026ldquo;data\u0026rdquo;: res}) 接口的基本组成：\n构建一个接口的基本步骤： 导包：Flask、CORS、request、jsonify 在app.route()装饰器中定义接口的请求类型、url路径 写一个接口函数 获取入参（可选） get请求 request.args.get() post请求 request.json[] 对得到的参数进行基本校验：如参数类型校验、字段长度、是否空、鉴权等。 根据传参进行逻辑处理，调用对应功能，得到结果 构建响应头（可选，返回类型是文件时必须） 构建结果，使用jsonify将返回结果构建成一个js （可选） return结果 启动flask app.run(ip,port,debug=True),其中debug=True代表以调试模式启动，代码改动后自动重启；debug默认为False。 包的管理 requirements.txt 代码中引入了的包，需要填写在该文件中，格式：“ 包名==版本号”\n（3）采用gunnicorn+gevent部署flask项目 介绍： 一个HTTP 服务器，可以增加项目的并发，通常和gevent一起使用。 安装gunicorn和gevent： pip install gunicorn -i https://pypi.tuna.tsinghua.edu.cn/simple pip install gevent-i https://pypi.tuna.tsinghua.edu.cn/simple 配置文件 gunicorn.conf.py workers = 10 定义同时开启的处理请求的进程数量，根据网站流量适当调整 worker_class = \u0026ldquo;gevent\u0026rdquo; 采用gevent库，支持异步处理请求，提高吞吐量 bind = \u0026ldquo;0.0.0.0:80\u0026rdquo; 监听IP放宽，以便于Docker之间、Docker和宿主机之间的通信,docker部署固定 采用启动服务： gunicorn flask_index:app -c ./gunicorn.conf.py 注意：Gunicorn只能运行在Linux环境中，不支持windows平台，因此在windows调试的时候不要用这个方式启动flask； 2. 前端：vue 、node.js（前端的包管理工具，类似python的pip包管理工具）、vue-cli（vue项目的脚手架）、element-ui、echats提供页面交互;\n（1）项目结构\n(2) 配置环境 安装node.js，前端包管理工具，直接下载安装即可 全局安装cnpm： npm install cnpm -g，解决npm速度慢的问题 cnpm install vue-cli -g 全局安装脚手架vue-cli 通过脚手架创建项目： vue init webpack my-project 启动项目：npm run serve 打包：npm run build (3)配置本地环境和正式环境：\n手动切换：url决定正式环境还是本地测试环境 （4）通过nginx部署：\n部署：docker（ ）+WebHooks（ ）+脚本的方式实现，合并代码后自动化部署。 构建Dockerfile： flask： Vue:\n打包docker（自动化形式）：\n以demo的方式演示实现一个工具： 后端：用flask分别写一个接口demo，实现：根据传参生成新诊所，并绑定到指定账号 安装flask、flask_cors (pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple) 新建一个flask项目 导包 简单实现一个get类型接口： 写一个post类型接口，调用已有函数： 启动flask\n前端：一个单页面的vue+elementui的demo： 准备文件（要引入的插件），将以下文件下载到项目的目录下\n、\n引入文件，在html的head标签中引入以上文件\n（需要先了解下html\\css\\js） 创建vue应用骨架 html部分 js部分 vue部分只需重点关注：模板语法、事件处理、以及常用指令 在页面中使用element-ui组件，以按钮为例，并给按钮添加事件处理： 使用axios发送请求 js\n写一个按钮用于触发POST接口请求、一个文本框用于显示接收的结果。 html部分：\njs部分\n四、后续方向 继续加入能提升效率的工具、加强提供测试数据的能力 自动化测试项目的可视化、测试用例少代码化\nPython from flask import Flask,request,jsonify from opened_new_clinic import opened_new_clinic from flask_cors import CORS @app.route(\u0026rsquo;/demo\u0026rsquo;, methods=[\u0026lsquo;POST\u0026rsquo;, \u0026lsquo;GET\u0026rsquo;]) def get_msg(): msg=request.args.get(\u0026ldquo;message\u0026rdquo;) print(f\u0026rsquo;message, {msg}\u0026rsquo;) return {\u0026ldquo;data\u0026rdquo;:f\u0026quot;来自服务端的回复{msg}\u0026quot;} @app.route(\u0026rsquo;/create_clinic\u0026rsquo;, methods=[\u0026lsquo;POST\u0026rsquo;, \u0026lsquo;GET\u0026rsquo;]) def create_clinic(): phone = request.json[\u0026lsquo;phone\u0026rsquo;] storeid = request.json[\u0026lsquo;storeid\u0026rsquo;] if phone != \u0026rsquo;\u0026rsquo; and storeid != \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(phone, storeid) elif phone != \u0026rsquo;\u0026rsquo; and storeid == \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(phone=phone) elif phone == \u0026rsquo;\u0026rsquo; and storeid != \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(clinic_id=storeid) else: res = opened_new_clinic() return jsonify({\u0026ldquo;data\u0026rdquo;: res}) Bash\n})\r.catch(function (error) {\r// 请求失败处理\rconsole.log(error);\r});\r}\rBash\nmethods: {\rsend(){\rvar _this = this;\raxios\r.get('http://localhost:5000/demo?message=test')\r.then(\rfunction(response) {\r_this.info = response.data.data\rconsole.log(info)\r})\r.catch(function (error) {\r// 请求失败处理\rconsole.log(error);\r});\r},\rcreate_clinic(){\rvar _this = this;\raxios\r.post('http://localhost:5000/create_clinic' , {\rstoreid:_this.form.store_id,\rphone:_this.form.phone\r})\r.then(\rfunction(response) {\r_this.form.res = response.data.data\rconsole.log(info)\r})\r.catch(function (error) {\r// 请求失败处理\rconsole.log(error);\r});\r}\r},\r})\u0026lt;/script\u0026gt;\n","date":"2025-03-21 12:59:32","updated":"2025-03-21 12:59:32"},{"objectID":"1742449709","permalink":"/post/mcp-intro/","title":"MCP入门指南","content":"\r什么是MCP？\rMCP（Model Context Protocol）是一种用于扩展和增强开发工具功能的协议。它允许开发者创建和使用MCP服务器，这些服务器可以提供额外的工具和资源，以提高开发效率和灵活性。\nMCP的安装\rMCP的安装通常包括以下步骤：\n安装MCP客户端：根据使用的开发工具，安装相应的MCP客户端插件或扩展。 创建MCP服务器：使用提供的工具或模板创建一个新的MCP服务器项目。 配置MCP服务器：在MCP服务器项目中添加所需的工具和资源，并进行相应的配置。 运行MCP服务器：启动MCP服务器，使其与MCP客户端进行通信。 使用示例\r以下是一个简单的MCP服务器使用示例：\n#!/usr/bin/env node import { Server } from \u0026#39;@modelcontextprotocol/sdk/server/index.js\u0026#39;; import { StdioServerTransport } from \u0026#39;@modelcontextprotocol/sdk/server/stdio.js\u0026#39;; const server = new Server( { name: \u0026#39;example-mcp-server\u0026#39;, version: \u0026#39;0.1.0\u0026#39;, }, { capabilities: { tools: { exampleTool: { description: \u0026#39;这是一个示例工具\u0026#39;, inputSchema: { type: \u0026#39;object\u0026#39;, properties: { message: { type: \u0026#39;string\u0026#39;, description: \u0026#39;要显示的消息\u0026#39;, }, }, required: [\u0026#39;message\u0026#39;], }, }, }, }, } ); server.setRequestHandler(\u0026#39;exampleTool\u0026#39;, async (request) =\u0026gt; { const message = request.params.message; return { content: [ { type: \u0026#39;text\u0026#39;, text: `您输入的消息是：${message}`, }, ], }; }); const transport = new StdioServerTransport(); await server.connect(transport); console.error(\u0026#39;MCP服务器正在运行\u0026#39;); 热门MCP工具推荐\r以下是一些目前热门的MCP工具：\n代码生成工具：根据项目需求自动生成代码模板和结构，提高开发效率。 API文档生成工具：自动从代码中提取API信息并生成详细的文档，方便团队成员查阅。 代码质量检查工具：对代码进行静态分析，检查潜在的错误和问题，提高代码质量。 自动化测试工具：自动生成和执行测试用例，确保代码的正确性和稳定性。 通过使用这些热门MCP工具，开发者可以大大提高开发效率和代码质量，更好地完成项目开发任务。\n总结\rMCP是一种强大的开发工具扩展协议，可以帮助开发者创建和使用各种工具和资源。通过本指南，您已经了解了MCP的基本使用方法，接下来可以探索更多高级功能和热门工具。\n","date":"2025-03-20 13:48:29","updated":"2025-03-20 13:48:29"},{"objectID":"1742449368","permalink":"/post/pytest-intro/","title":"pytest入门指南","content":"\r什么是pytest？\rpytest是一个功能强大且易于使用的Python测试框架。它可以帮助开发者编写简洁、可读性强的测试代码，并提供丰富的插件支持。\npytest的主要特点\r简洁的测试用例编写方式 自动发现测试用例 支持参数化测试 强大的断言功能 丰富的插件生态系统 安装pytest\r使用以下命令安装pytest：\npip install pytest 编写测试用例\r一个简单的pytest测试用例如下：\ndef test_addition(): assert 1 + 1 == 2 def test_subtraction(): assert 2 - 1 == 1 运行测试\r使用以下命令运行pytest测试：\npytest 参数化测试\rpytest支持参数化测试，可以使用@pytest.mark.parametrize装饰器：\nimport pytest @pytest.mark.parametrize(\u0026#34;test_input,expected\u0026#34;, [ (\u0026#34;3+5\u0026#34;, 8), (\u0026#34;2+4\u0026#34;, 6), (\u0026#34;6*9\u0026#34;, 42), ]) def test_eval(test_input, expected): assert eval(test_input) == expected 总结\rpytest是一个功能强大且易于使用的Python测试框架，可以帮助开发者编写简洁、可读性强的测试代码。通过本指南，您已经了解了pytest的基本使用方法，接下来可以探索更多高级功能。\n","date":"2025-03-20 13:42:48","updated":"2025-03-20 13:42:48"},{"objectID":"1742446772","permalink":"/post/docker%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","title":"docker常用命令","content":"docker pull ubuntu 载入ubuntu 镜像\ndocker pull training/webapp # 载入镜像\ndocker pull python:3.7 安装python镜像\ndocker pull nginx 安装nginx镜像\ndocker run -it python:3.7 /bin/bash 进入python镜像\n连接不上时，终端输入：\n1.cd \u0026ldquo;C:\\Program Files\\Docker\\Docker\u0026rdquo;\n2.DockerCli.exe -SwitchDaemon\ndocker run -it ubuntu /bin/bash 启用进入容器\nexit退出容器\ndocker run -d -P training/webapp python app.py 后台启用容器并随机映射到本机端口\ndocker run -d -p 5000:5000 training/webapp python app.py后台启用容器并指定映射到\ndocker logs -f id 查看应用日志\ndocker logs -f -t \u0026ndash;tail=100 dockerid 动态查看最新100条日志\ndocker top id 查看容器内部应用进程\ndocker ps -a 查看所有容器(可查容器id)\ndocker ps 查看在运行的容器\ndocker ps -l 查询最后一次创建的容器\ndocker start id 启用对应id的容器\ndocker restart id重启\ndocker stop id 停止\ndocker run -dit -p 5000:80 -v /opt/app/docker_app/tools_flask/tools:/usr/src/app/tools \u0026ndash;name tools-flask tools_flask; 启动容器并持久化docker目录\ndocker run -itd \u0026ndash;name ubuntu-test ubuntu /bin/bash 后台运行容器\ndocker exec -it id bash进入容器\ndocker export id \u0026gt; ubuntu.tar 导出容器\ncat docker/ubuntu.tar | docker import - test/ubuntu:v1 导入容器到镜像\ndocker rm -f id 删除容器\ndocker images 列出镜像列表\n镜像下载： https://hub.docker.com/\ndocker search 关键词搜索镜像\n传输文件\ndocker cp 本地文件的路径 container_id:\u0026lt;docker容器内的路径\u0026gt;\ndocker run -p 3000:80 -d \u0026ndash;name vueApp vuenginxcontainer\nDockerfile 来构建镜像\n1.创建Dockerfile 填写配置内容，参考：E:\\code\\flask_tools\\tools\\Dockerfile\n2.docker build -t flask_tools:v1 . Dockerfile当前目录构建镜像. 是基于当前目录的 。后面的.不能少\n3.docker run -p 5000:80 -d \u0026ndash;name flask2 flask_tools:v1 top bin/bash启用容器\ngunicorn -k gevent -c gunicorn.conf flask_index:app项目名 # 用gunicorn启动项目\n上传到docker hub\n先给要上传的仓库打上标签：\ndocker tag id tianqinghong/python_vue_share\n再push:\ndocker push tianqinghong/python_vue_share\n下载镜像\ndocker pull tianqinghong/python_vue_share\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/git-submodule/","title":"Git submodule","content":" Git submodule添加子项目_库 Git归并策略 添加 删除 输入“/”快速插入内容\n添加图标\n添加封面\n展示文档信息\nGit submodule添加子项目_库\n开发过程中，经常会有一些通用的部分希望抽取出来做成一个公共库来提供给别的工程来使用，而公共代码库的版本管理是个麻烦的事情。git submodule命令就可以解决这个问题。\nGit归并策略\nGit归并有两种策略：递归，章鱼。\n1.递归策略：当分支数只有两个的时候。\n2.章鱼策略：当分支数大于两个的时候。\nGit会自动选择归并的方法。\n3.子树策略：是Git另一种归并方法。（submodule）\n它可以把另一个子项目，嵌入到当前项目。而且会非常聪明的合并这些子项目。\n添加\n为当前工程添加submodule，命令如下：\ngit submodule add 仓库地址 路径\n其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。\n注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）\n示例:\ngit submodule add -f http://git.cs/Cmblife_iOS_Internal/modulesLib.git\n-f 是强制的意思，一般不需要加\n命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。\n删除\nsubmodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。\n下载的工程带有submodule\n当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：\ngit submodule update –init –recursive\n即可将子模块内容下载下来后工程才不会缺少相应的文件。\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/git%E6%B7%BB%E5%8A%A0%E5%AD%90%E9%A1%B9%E7%9B%AE/","title":"git子项目","content":" 项目中添加子项目 1、git clone 父项目url 2、cd 父项目对应目录下：git submodule add \u0026lt;子项目地址\u0026gt; 3、git commit ;git push 4、此时子项目下的子项目是空的，需要cd到父目录cmd执行： git submodule update \u0026ndash;init \u0026ndash;recursive 或者执行：git submodule init 然后执行git submodule update clone含嵌套项目的项目 git clone 父项目url \u0026ndash;recurse-submodules 不加\u0026ndash;recurse-submodules，克隆的子项目是空的 ","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/hugo%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","title":"Hugo静态网站生成器入门指南","content":"\r什么是Hugo？\rHugo是一个用Go语言编写的快速、现代的静态网站生成器。它可以将Markdown文件转换为HTML页面，非常适合构建文档网站、博客等。\nHugo的主要特点\r极快的构建速度 丰富的主题支持 简单的Markdown内容管理 强大的模板系统 内置的短代码功能 安装Hugo\r在Windows上安装Hugo的步骤：\n下载Hugo的Windows版本 解压到指定目录 将Hugo的可执行文件路径添加到系统环境变量 创建新站点\r使用以下命令创建一个新的Hugo站点：\nhugo new site mydocs 下载插件\r添加内容\r在content目录下创建Markdown文件来添加内容：\nhugo new blog/my-first-post.md 运行开发服务器\r使用以下命令启动开发服务器：\nhugo server -D --environment development #如果未设置环境变量则不需要指定环境。 部署网站\r使用以下命令生成静态文件：\nhugo 然后将public目录下的文件部署到Web服务器即可，注意每次推送前运行hugo更新public文件夹 若有更新域名，请删除public后，再运行hugo重新生成public，否则会出现路由错误的情况。 为了方便新建.sh脚本文件，命名为.command.sh # 判断是否已初始化Git仓库 if [ ! -d \u0026#34;.git\u0026#34; ]; then echo \u0026#34;未检测到Git仓库，正在初始化...\u0026#34; git init else echo \u0026#34;Git仓库已初始化\u0026#34; fi # 创建.gitignore文件，排除不需要版本控制的文件 cat \u0026gt; .gitignore \u0026lt;\u0026lt; EOF resources/ .DS_Store node_modules/ .hugo_build.lock EOF # 添加所有文件 git add . # 提交更改 git commit -m \u0026#34;更新博客\u0026#34; # 检查是否已关联远程仓库 REMOTE_URL=$(git remote get-url origin 2\u0026gt;/dev/null) if [ -z \u0026#34;$REMOTE_URL\u0026#34; ]; then echo \u0026#34;未检测到远程仓库，正在添加...\u0026#34; git remote add origin https://github.com/bluespace3/bluespace3.github.io else echo \u0026#34;已关联远程仓库：$REMOTE_URL\u0026#34; fi # 推送到GitHub git push -u origin main --force 终端运行 ..command.sh 更新维护\r后期维护有许多要留意的地方否则容易踩坑。\n新增文章，在项目根目录终端运行，hugo new content/post/文章名称 不同主题博客目录不一致，这里需要留意你下载主题的说明。\n生成的文章会自带字段，其中draft默认true需要维护成false或者删掉，否则视为草稿。如下：\ntitle: \u0026#34;测试平台教程\u0026#34; date: 2025-03-20T12:59:32+08:00 draft: false tags: [\u0026#34;测试平台\u0026#34;, \u0026#34;静态网站\u0026#34;, \u0026#34;教程\u0026#34;] 3.若只有一台电脑更新博客，可以只把public托管到github，若要多个终端更新。需要满足以下条件。\n终端的hugo版本和主题保持需要保持一致，建议把主题配置在hugo.toml文件里面。否则本地有多个主题时在运行时要指定主题。\nhugo -t hugo-theme-reimu\n需要把整个项目推到github，并且指定githubPage为存放public的分支。需要建立工作流，脚本如下。\nname: Deploy Hugo site on: push: branches: - main # 或者你的默认分支名 jobs: deploy: runs-on: ubuntu-latest permissions: contents: write # Ensure GITHUB_TOKEN has write access to contents steps: - uses: actions/checkout@v3 with: submodules: false # 确保自动拉取子模块 fetch-depth: 0 # 获取所有历史记录和标签 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: gh-pages # 部署到gh-pages分支 总结\rHugo是一个功能强大且易于使用的静态网站生成器，非常适合构建个人博客、文档网站等。\n优点是能快速构建，丰富的模板生态，方便的托管到github，后期维护成本低。\n缺点：只支持md格式，不支持在线编辑，因为只支持通过代码push到远程仓库更新，所以在切换终端时简直是噩梦，笔者在此处踩坑无数，特别需要注意这里。\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/linux%E5%AE%89%E8%A3%85python/","title":"linux安装python","content":"#依赖包\nyum -y groupinstall \u0026ldquo;Development tools\u0026rdquo;\nyum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n#下载 Python3\nwget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz\n#创建文件夹\nmkdir /usr/local/python3\n#解压编译安装\ntar -xvJf Python-3.6.2.tar.xz\ncd Python-3.6.2\n./configure \u0026ndash;prefix=/usr/local/python3\nmake \u0026amp;\u0026amp; make install\n#给个软链\nln -sf /usr/local/python3/bin/python3 /usr/bin/python3\nln -sf /usr/local/python3/bin/pip3 /usr/bin/pip3\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"linux常用命令","content":"\r文章目录\r一、目录操作 1、批量操作 二、文件操作 三、文件内容操作（查看日志，更改配置文件） 1、grep(检索文件内容) 2、awk(数据统计) 3、sed(替换文件内容) 4、管道操作符 | 四、系统日志位置 五、创建与删除软连接 六、压缩和解压缩 七、Linux下文件的详细信息 八、常用的docker容器的命令： 九、运维常用命令 1、查看服务器端口号是否可用 十、yum常用命令 十一、其他命令 1、xargs 2、curl语法 十二、Linux内核优化 十三、用户权限操作 1、用户操作 2、添加组 3、sudo用户权限操作 4、更换文件所有者 十四、TOP 1、统计信息区 2、进程信息区 十五、文件安装 1、文件下载(lrzsz) 十六、文章PDF版本 Linux 系统目录\n├── bin -\u0026amp;gt; usr/bin # 用于存放二进制命令 ├── boot # 内核及引导系统程序所在的目录 ├── dev # 所有设备文件的目录（如磁盘、光驱等） ├── etc # 配置文件默认路径、服务启动命令存放目录 ├── home # 用户家目录，root用户为/root ├── lib -\u0026amp;gt; usr/lib # 32位库文件存放目录 ├── lib64 -\u0026amp;gt; usr/lib64 # 64位库文件存放目录 ├── media # 媒体文件存放目录 ├── mnt # 临时挂载设备目录 ├── opt # 自定义软件安装存放目录 ├── proc # 进程及内核信息存放目录 ├── root # Root用户家目录 ├── run # 系统运行时产生临时文件，存放目录 ├── sbin -\u0026amp;gt; usr/sbin # 系统管理命令存放目录 ├── srv # 服务启动之后需要访问的数据目录 ├── sys # 系统使用目录 ├── tmp # 临时文件目录 ├── usr # 系统命令和帮助文件目录 └── var # 存放内容易变的文件的目录 12345678910111213141516171819 一、目录操作\rpwd 查看当前工作目录 clear 清除屏幕 cd ~ 当前用户目录 cd / 根目录 cd - 上一次访问的目录 cd .. 上一级目录 123456 查看目录内信息\nll 查看当前目录下内容（LL的小写） 1 …","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/playwright%E7%9A%84python%E6%96%87%E6%A1%A3/","title":"playwright的python文档","content":"\r安装\r引言\rPlaywright 是专门为满足端到端测试的需求而创建的。Playwright 支持包括 Chromium、WebKit 和 Firefox 在内的所有现代渲染引擎。在 Windows、Linux 和 macOS 上进行测试，无论是本地还是在 CI 上，无论是无头模式还是有头模式，都可以使用原生移动设备仿真。\nPlaywright 库可以用作通用的浏览器自动化工具，为同步和异步 Python 提供了一套强大的 API 来自动化 Web 应用程序。\n本介绍描述了 Playwright Pytest 插件，这是编写端到端测试的推荐方式。\n你将学到\n如何安装 Playwright Pytest 如何运行示例测试 安装 Playwright Pytest\rPlaywright 建议使用官方的 Playwright Pytest 插件来编写端到端测试。它提供了上下文隔离，并开箱即用地在多个浏览器配置上运行。\n首先，通过安装 Playwright 并运行示例测试来开始，亲眼看看它是如何工作的。\nPyPI Anaconda 安装所需的浏览器：\n添加示例测试\r在当前工作目录或遵循 test_ 前缀约定的子目录中创建一个文件，例如 test_example.py，并在其中包含以下代码。确保你的测试名称也遵循 test_ 前缀约定。\ntest_example.py\nimport re from playwright.sync_api import Page, expect def test_has_title(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 期望标题“包含”一个子字符串。 expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) def test_get_started_link(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 点击“开始”链接。 page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() # 期望页面有一个名为“安装”的标题。 expect(page.get_by_role(\u0026#34;heading\u0026#34;, name=\u0026#34;Installation\u0026#34;)).to_be_visible() 运行示例测试\r默认情况下，测试将在 Chromium 上运行。这可以通过 CLI 选项进行配置。测试以无头模式运行，这意味着在运行测试时不会打开浏览器 UI。测试结果和测试日志将在终端中显示。\n更新 Playwright\r要将 Playwright 更新到最新版本，请运行以下命令：\npip install pytest-playwright playwright -U 系统要求\rPython 3.8 或更高版本。 Windows 10+、Windows Server 2016+ 或 Windows Subsystem for Linux (WSL)。 MacOS 12 Monterey、MacOS 13 Ventura 或 MacOS 14 Sonoma。 Debian 11、Debian 12、Ubuntu 20.04 或 Ubuntu 22.04。 接下来是什么\r使用 Web 优先断言、页面夹具和定位器编写测试 运行单个测试、多个测试、有头模式 使用 Codegen 生成测试 查看测试的跟踪 编写测试用例\r引言\rPlaywright 测试很简单，它们\n执行操作 ， 断言状态与预期相符。 在执行操作之前没有必要等待任何东西：Playwright 在执行每个操作之前会自动等待一系列可操作性检查通过。\n也没有必要在执行检查时处理竞态条件 - Playwright 断言的设计方式是它们描述了最终需要满足的预期。\n就是这样！这些设计选择允许 Playwright 用户完全忘记他们测试中的不稳定超时和竞态检查。\n你将学到\n如何编写第一个测试 如何执行操作 如何使用断言 测试如何独立运行 如何使用测试钩子 第一个测试\r查看以下示例，了解如何编写测试。注意文件名遵循 test_ 前缀约定，以及每个测试名称。\ntest_example.py\nimport re from playwright.sync_api import Page, expect def test_has_title(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 期望标题“包含”一个子字符串。 expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) def test_get_started_link(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 点击“开始”链接。 page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() # 期望页面有一个名为“安装”的标题。 expect(page.get_by_role(\u0026#34;heading\u0026#34;, name=\u0026#34;Installation\u0026#34;)).to_be_visible() 操作\r导航\r大多数测试将从导航到 URL 的页面开始。之后，测试将能够与页面元素进行交互。\npage.goto(\u0026#34;https://playwright.dev/\u0026#34;) Playwright 会等待页面达到加载状态，然后再继续。了解更多关于 page.goto() 选项的信息。\n交互\r执行操作从定位元素开始。Playwright 使用 Locators API 进行此操作。定位器代表了在任何时刻在页面上查找元素（或元素组）的方式，了解更多关于可用的不同类型定位器的信息。Playwright 会在执行操作之前等待元素可操作，因此没有必要等待其变为可用。\n# 创建一个定位器。 get_started = page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;) # 点击它。 get_started.click() 在大多数情况下，它会写成一行：\npage.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() 基本操作\r这是最受欢迎的 Playwright 操作列表。请注意，还有更多操作，请确保查看定位器 API 部分以了解更多信息。\n操作 描述 locator.check() 检查输入复选框 locator.click() 点击元素 locator.uncheck() 取消检查输入复选框 locator.hover() 鼠标悬停在元素上 locator.fill() 填写表单字段，输入文本 locator.focus() 使元素获得焦点 locator.press() 按下单个键 locator.set_input_files() 选择上传的文件 locator.select_option() 在下拉菜单中选择选项 断言\rPlaywright 包括断言，这些断言会等待直到满足预期条件。使用这些断言可以使测试不脆弱且具有弹性。例如，这段代码会等待页面获得包含“Playwright”的标题：\nimport re from playwright.sync_api import expect expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) 这是最受欢迎的异步断言列表。请注意，还有更多断言需要熟悉：\n断言 描述 expect(locator).to_be_checked() 复选框被选中 expect(locator).to_be_enabled() 控件被启用 expect(locator).to_be_visible() 元素可见 expect(locator).to_contain_text() 元素包含文本 expect(locator).to_have_attribute() 元素具有属性 expect(locator).to_have_count() 元素列表具有给定长度 expect(locator).to_have_text() 元素匹配文本`` expect(locator).to_have_value() 输入元素具有值`` expect(page).to_have_title() 页面具有标题`` expect(page).to_have_url() 页面具有 URL 测试隔离\rPlaywright Pytest 插件基于测试夹具的概念，例如内置的页面夹具，它被传递到你的测试中。由于浏览器上下文，页面在测试之间是隔离的，这相当于一个全新的浏览器配置文件，每个测试都获得一个新鲜环境，即使多个测试在单个浏览器中运行。\ntest_example.py\nfrom playwright.sync_api import Page def test_example_test(page: Page): pass # “page”属于一个独立的 BrowserContext，为这个特定测试创建。 def test_another_test(page: Page): pass # 这个第二个测试中的“page”与第一个测试完全隔离。 使用夹具\r你可以使用各种夹具在测试之前或之后执行代码并共享对象。一个 function 作用域的夹具，例如带有 autouse 的，表现得像 beforeEach/afterEach。一个 module 作用域的夹具带有 autouse 表现得像 beforeAll/afterAll，它在所有测试之前和之后运行。\ntest_example.py\nimport pytest from playwright.sync_api import Page, expect @pytest.fixture(scope=\u0026#34;function\u0026#34;, autouse=True) def before_each_after_each(page: Page): print(\u0026#34;before the test runs\u0026#34;) # 在每个测试之前转到起始 URL。 page.goto(\u0026#34;https://playwright.dev/\u0026#34;) yield print(\u0026#34;after the test runs\u0026#34;) def test_main_navigation(page: Page): # 断言使用 expect API。 expect(page).to_have_url(\u0026#34;https://playwright.dev/\u0026#34;) 接下来是什么\r运行单个测试，多个测试，有头模式 使用 Codegen 生成测试 查看测试的跟踪 在 CI 上运行测试与 GitHub Actions 生成测试\r引言\rPlaywright 提供了开箱即用的测试生成能力，是快速开始测试的绝佳方式。它将打开两个窗口，一个浏览器窗口，您可以在其中与您想要测试的网站进行交互；另一个是 Playwright 检查器窗口，您可以在其中录制测试、复制测试、清除测试以及更改测试的语言。\n您将学到\n如何录制测试 如何生成定位器 运行 Codegen\r使用 codegen 命令运行测试生成器，然后是您想要为其生成测试的网站的 URL。URL 是可选的，您也可以在不指定 URL 的情况下运行命令，然后在浏览器窗口中直接添加 URL。\nplaywright codegen demo.playwright.dev/todomvc 录制测试\r运行 codegen 并在浏览器中执行操作。Playwright 将为用户交互生成代码。Codegen 将查看渲染后的页面并找出推荐的定位器，优先考虑角色、文本和测试 ID 定位器。如果生成器识别出多个元素与定位器匹配，它将改进定位器，使其更具弹性并唯一地识别目标元素，从而消除和减少由于定位器导致的测试失败和不稳定。\n使用测试生成器，您可以录制：\n通过简单地与页面交互，执行点击或填充等操作 通过点击工具栏上的一个图标，然后点击页面上的元素进行断言。您可以选择： 'assert visibility' 断言元素可见 'assert text' 断言元素包含特定文本 'assert value' 断言元素具有特定值 当您完成与页面的交互后，按下 'record' 按钮停止录制，并使用 'copy' 按钮将生成的代码复制到您的编辑器中。\n使用 'clear' 按钮清除代码以开始重新录制。完成后，关闭 Playwright 检查器窗口或停止终端命令。\n要了解更多关于生成测试的信息，请查看我们关于 Codegen 的详细指南。\n生成定位器\r您可以使用测试生成器生成定位器。\n按下 'Record' 按钮停止录制，\u0026lsquo;Pick Locator\u0026rsquo;` 按钮将会出现。 点击 'Pick Locator' 按钮，然后将鼠标悬停在浏览器窗口的元素上，以查看定位器在每个元素下方突出显示。 要选择一个定位器，单击您想要定位的元素，该定位器的代码将出现在 Pick Locator 按钮旁边的定位器游乐场中。 然后您可以在定位器游乐场中编辑定位器以微调它，并看到匹配的元素在浏览器窗口中突出显示。 使用复制按钮复制定位器并将其粘贴到您的代码中。 仿真\r您还可以使用仿真生成测试，以便为特定的视口、设备、颜色方案生成测试，以及模拟地理位置、语言或时区。测试生成器还可以在保持认证状态的同时生成测试。查看测试生成器指南以了解更多信息。\n接下来做什么\r查看您的测试跟踪 运行和调试\r引言\r您可以运行单个测试、一组测试或所有测试。使用 --browser 标志，可以在一个浏览器或多个浏览器上运行测试。默认情况下，测试以无头模式运行，这意味着在运行测试时不会打开浏览器窗口，结果将在终端中显示。如果您愿意，可以通过使用 --headed CLI 参数以有头模式运行您的测试。\n您将学到\n如何从命令行运行测试 如何调试测试 运行测试\r命令行\r要运行您的测试，请使用 pytest 命令。这将默认在 Chromium 浏览器上运行您的测试。默认情况下，测试以无头模式运行，这意味着在运行测试时不会打开浏览器窗口，结果将在终端中显示。\n在有头模式下运行测试\r要以有头模式运行您的测试，请使用 --headed 标志。这将在运行测试时打开浏览器窗口，并在完成后关闭浏览器窗口。\n在不同的浏览器上运行测试\r要指定您想要运行测试的浏览器，请使用 --browser 标志，后跟浏览器的名称。\n要指定要在多个浏览器上运行测试，请多次使用 --browser 标志，后跟每个浏览器的名称。\npytest --browser webkit --browser firefox 运行特定测试\r要运行单个测试文件，请传入您想要运行的测试文件的名称。\n要运行一组测试文件，请传入您想要运行的测试文件的名称。\npytest tests/test_todo_page.py tests/test_landing_page.py 要运行特定测试，请传入您想要运行的测试的函数名称。\npytest -k test_add_a_todo_item 并行运行测试\r要并行运行您的测试，请使用 --numprocesses 标志，后跟您想要运行测试的进程数量。我们建议使用逻辑 CPU 核心数的一半。\n（这假设已安装了 pytest-xdist。有关更多信息，请参见此处。）\n有关更多信息，请参见 Playwright Pytest 使用情况或 Pytest 文档以了解一般 CLI 使用情况。\n调试测试\r由于 Playwright 在 Python 中运行，您可以使用您选择的调试器进行调试，例如使用 Visual Studio Code 中的 Python 扩展。Playwright 带有 Playwright 检查器，允许您逐步执行 Playwright API 调用，查看它们的调试日志并探索定位器。\n要调试所有测试，请运行以下命令。\nBash PowerShell Batch 要调试一个测试文件，请在命令后运行您想要调试的测试文件的名称。\nBash PowerShell Batch PWDEBUG=1 pytest -s test_example.py 要调试特定测试，请添加 -k 后跟您想要调试的测试的名称。\nBash PowerShell Batch PWDEBUG=1 pytest -s -k test_get_started_link 此命令将打开浏览器窗口以及 Playwright 检查器。您可以使用检查器顶部的步过按钮逐步执行您的测试。或者按下播放按钮从开始到结束运行您的测试。一旦测试完成，浏览器窗口将关闭。\n在调试时，您可以使用选择定位器按钮来选择页面上的元素，并查看 Playwright 用于查找该元素的定位器。您还可以编辑定位器并实时在浏览器窗口中看到它被高亮显示。使用复制定位器按钮将定位器复制到剪贴板，然后将其粘贴到您的测试中。\n查看我们的调试指南，以了解更多关于 Playwright 检查器以及使用浏览器开发工具进行调试的信息。\n接下来做什么\r使用 Codegen 生成测试 查看您的测试跟踪 在 CI 上使用 GitHub Actions 运行您的测试 跟踪查看器\r介绍\rPlaywright Trace Viewer 是一个图形用户界面（GUI）工具，允许您探索录制的 Playwright 测试跟踪，这意味着您可以前后浏览测试的每个动作，并直观地看到每个动作期间发生了什么。\n您将学到\n如何录制跟踪 如何打开 HTML 报告 如何打开跟踪查看器 录制跟踪\r可以通过使用 --tracing 标志运行测试来录制跟踪。\n跟踪的选项有：\non: 为每个测试录制跟踪 off: 不录制跟踪。（默认） retain-on-failure: 为每个测试录制跟踪，但删除成功测试运行的所有跟踪。 这将录制跟踪并将其放入 test-results 目录中名为 trace.zip 的文件中。\n如果您没有使用 Pytest，请点击这里了解如何录制跟踪。\n同步 异步 browser = chromium.launch() context = browser.new_context() # 在创建/导航页面之前开始跟踪。 context.tracing.start(screenshots=True, snapshots=True, sources=True) page = context.new_page() page.goto(\u0026#34;https://playwright.dev\u0026#34;) # 停止跟踪并将其导出到 zip 归档中。 context.tracing.stop(path=\u0026#34;trace.zip\u0026#34;) 打开跟踪\r您可以使用 Playwright CLI 或在 trace.playwright.dev 上的浏览器中打开保存的跟踪。确保添加您的 trace.zip 文件所在的完整路径。这应该包括 test-results 目录，然后是测试名称，最后是 trace.zip。\nplaywright show-trace trace.zip 查看跟踪\r通过点击每个动作或使用时间线悬停来查看测试的跟踪，并查看动作前后页面的状态。在测试的每个步骤期间检查日志、源代码和网络。跟踪查看器创建了一个 DOM 快照，因此您可以完全与之交互，打开开发工具等。\n要了解更多信息，请查看我们关于跟踪查看器的详细指南。\n接下来是什么\r在 GitHub Actions 上运行 CI 测试 了解更多关于跟踪查看器的信息 Pytest 插件来编写端到端测试\r引言\rPlaywright 提供了一个 Pytest 插件来编写端到端测试。要开始使用它，请参考入门指南。\n使用方法\r要运行测试，请使用 Pytest 命令行界面。\npytest --browser webkit --headed 如果你想自动添加命令行参数而不需要明确指定它们，你可以使用 pytest.ini 文件：\n# pytest.ini 文件的内容 [pytest] # 使用 UI 运行 firefox addopts = --headed --browser firefox 命令行参数\r请注意，命令行参数仅应用于默认的 browser、context 和 page 固定装置。如果你使用 API 调用如 browser.new_context() 创建浏览器、上下文或页面，命令行参数将不会应用。\n--headed：以有头模式运行测试（默认：无头）。 --browser：在不同的浏览器中运行测试 chromium、firefox 或 webkit。可以多次指定（默认：chromium）。 --browser-channel：要使用的浏览器渠道。 --slowmo：通过指定的毫秒数减慢 Playwright 操作。这样你可以看清楚发生了什么（默认：0）。 --device：要模拟的设备。 --output：由测试产生的工件目录（默认：test-results）。 --tracing：是否为每个测试记录跟踪。on、off 或 retain-on-failure（默认：off）。 --video：是否为每个测试录制视频。on、off 或 retain-on-failure（默认：off）。 --screenshot：是否在每个测试后自动捕获屏幕截图。on、off 或 only-on-failure（默认：off）。 --full-page-screenshot：在失败时是否拍摄整个页面的屏幕截图。默认情况下，只捕获视口。需要启用 --screenshot（默认：off）。 固定装置\r这个插件为 pytest 配置了 Playwright 特定的固定装置。要使用这些固定装置，将固定装置名称作为参数传递给测试函数。\ndef test_my_app_is_working(fixture_name): pass # 使用 fixture_name 进行测试 # ... 函数范围 ：当在测试函数中请求时，这些固定装置被创建，并在测试结束时销毁。\ncontext：测试的新浏览器上下文。 page：测试的新浏览器页面。 new_context：允许为测试创建不同的浏览器上下文。适用于多用户场景。接受与 browser.new_context() 相同的参数。 会话范围 ：当在测试函数中请求时，这些固定装置被创建，并在所有测试结束时销毁。\nplaywright：Playwright 实例。 browser_type：当前浏览器的 BrowserType 实例。 browser：由 Playwright 启动的浏览器实例。 browser_name：浏览器名称字符串。 browser_channel：浏览器渠道字符串。 is_chromium、is_webkit、is_firefox：相应浏览器类型的布尔值。 自定义固定装置选项 ：对于 browser 和 context 固定装置，使用以下固定装置定义自定义启动选项。\nbrowser_type_launch_args：覆盖 browser_type.launch() 的启动参数。它应该返回一个字典。 browser_context_args：覆盖 browser.new_context() 的选项。它应该返回一个字典。 也可以通过使用 browser_context_args 标记来覆盖单个测试的上下文选项（browser.new_context()）：\nimport pytest @pytest.mark.browser_context_args(timezone_id=\u0026#34;Europe/Berlin\u0026#34;, locale=\u0026#34;en-GB\u0026#34;) def test_browser_context_args(page): assert page.evaluate(\u0026#34;window.navigator.userAgent\u0026#34;) == \u0026#34;Europe/Berlin\u0026#34; assert page.evaluate(\u0026#34;window.navigator.languages\u0026#34;) == [\u0026#34;de-DE\u0026#34;] 并行性：同时运行多个测试\r如果你的测试在拥有大量 CPU 的机器上运行，你可以通过使用 pytest-xdist 同时运行多个测试来加快测试套件的整体执行时间：\n# 安装依赖 pip install pytest-xdist # 使用 --numprocesses 标志 pytest --numprocesses auto 根据硬件和测试的性质，你可以将 numprocesses 设置为从 2 到机器上的 CPU 数量。如果设置得太高，你可能会注意到意外的行为。\n有关 pytest 选项的一般信息，请参见运行测试。\n示例\r为自动补全配置 Mypy 类型\rtest_my_application.py\nfrom playwright.sync_api import Page def test_visit_admin_dashboard(page: Page): page.goto(\u0026#34;/admin\u0026#34;) # ... 配置慢动作\r使用 --slowmo 参数运行测试。\n将 Playwright 操作减慢 100 毫秒。\n按浏览器跳过测试\rtest_my_application.py\nimport pytest @pytest.mark.skip_browser(\u0026#34;firefox\u0026#34;) def test_visit_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) # ... 在特定浏览器上运行\rconftest.py\nimport pytest @pytest.mark.only_browser(\u0026#34;chromium\u0026#34;) def test_visit_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) # ... 使用自定义浏览器渠道，如 Google Chrome 或 Microsoft Edge\rpytest --browser-channel chrome test_my_application.py\ndef test_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) 配置基础 URL\r使用 base-url 参数启动 Pytest。pytest-base-url 插件用于此目的，它允许你从配置、命令行参数或固定装置中设置基础 URL。\npytest --base-url http://localhost:8080 test_my_application.py\ndef test_visit_example(page): page.goto(\u0026#34;/admin\u0026#34;) # -\u0026gt; 将导致 http://localhost:8080/admin 忽略 HTTPS 错误\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args): return { **browser_context_args, \u0026#34;ignore_https_errors\u0026#34;: True } 使用自定义视口大小\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args): return { **browser_context_args, \u0026#34;viewport\u0026#34;: { \u0026#34;width\u0026#34;: 1920, \u0026#34;height\u0026#34;: 1080, } } 设备模拟\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args, playwright): iphone_11 = playwright.devices[\u0026#39;iPhone 11 Pro\u0026#39;] return { **browser_context_args, **iphone_11, } 或通过命令行 --device=\u0026quot;iPhone 11 Pro\u0026quot;。\n与 unittest.TestCase 一起使用\r查看以下示例，了解如何将其与 unittest.TestCase 一起使用。这有一个限制，即只能指定单个浏览器，并且在指定多个浏览器时不会生成多个浏览器的矩阵。\nimport pytest import unittest from playwright.sync_api import Page class MyTest(unittest.TestCase): @pytest.fixture(autouse=True) def setup(self, page: Page): self.page = page def test_foobar(self): self.page.goto(\u0026#34;https://microsoft.com\u0026#34;) self.page.locator(\u0026#34;#foobar\u0026#34;).click() assert self.page.evaluate(\u0026#34;1 + 1\u0026#34;) == 2 调试\r与 pdb 一起使用\r在你的测试代码中使用 breakpoint() 语句来暂停执行并获得 pdb REPL。\ndef test_bing_is_working(page): page.goto(\u0026#34;https://bing.com\u0026#34;) breakpoint() # ... 部署到 CI\r请参阅 CI 提供商的指南，了解如何将你的测试部署到 CI/CD。\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/python%E9%9D%9E%E5%90%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E8%B0%83%E7%94%A8%E6%8A%A5%E9%94%99/","title":"python常见踩坑记录","content":"\r项目结构：\r问题：\r执行文件调用dir1，间接调用dir2。执行时报错：“ModuleNotFoundError: No module named \u0026lsquo;dir1.dir2\u0026rsquo;;”\n解决方法：\rdir1文件导包时做处理。\n主函数加入这四行，将项目的根目录(webapp)的路径加入到系统PATH中； import os,sys\nfrom pathlib import Path\nsys.path[0] = str(Path(sys.path[0]).parent.parent)\nsys.path.append(os.getcwd())\n且导包从项目执行入口文件同级开始写\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/python%E4%B8%AD%E7%9A%84os%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/","title":"python的os模块使用","content":" os.listdir(path) 获取文件夹下全部文件，的列表 os.path.join(path1,path2) 将路径path1和路径path2拼接成新的路径，path1//path2 base_dir = os.path.dirname(os.path.abspath(file)) 获取当前文件的绝对路径 input_file = os.path.join(base_dir, \u0026quot;../resource/swaggerApi/clinic-ysb-app_OpenAPI.json\u0026quot;) ","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/scrapy%E7%88%AC%E6%9F%9A%E5%AD%90%E7%BD%91%E7%A4%BA%E4%BE%8B/","title":"scrapy爬柚子网示例","content":"柚子网https://www.uu-zz.com/\n爬取页码\n遍历页面内对应的视频集的链接\n遍历视频内子视频链接\n!\nhttps://www.uu-zz.com/+子视频链接，发送get请求\n!\n获得m3u8文件，储存在数据库\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742446772","permalink":"/post/unnitest%E7%AC%94%E8%AE%B0/","title":"unnitest","content":" 一、引入 1.导包，import unnitest 2.编写测试类，继承unnitest 二、运行 1.unnitest.main(),运行全部用例\n2.测试套：testsuite\n创建：suite=unnitest.Testsuite()\n测试套添加用例：suite.addtTest（类（方法））\n运行：runner=unnitest.TextTestRunner()\n运行：runner.run(suite) *运行必须在命令行运行否则是运行全部用例\n三、生成报告\n1.将HTMLTestRunner.py文件放到项目文件夹下 2.导包：如左图 3.创建测试套，参考上方 4.创建测试报告文件，且以测试套运行（参考左图） 与pytest的异同 pytest以mark方式组织用例（而非套件） 面试相关 pycharm关闭pytest测试模式 ","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"1742061600","permalink":"/post/go%E8%AF%AD%E8%A8%80--%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E9%85%8D/","title":"go语言--安装和环境搭配","content":"\r一.Go简介\rGo 语言（又称 Golang）是由 Google 开发的一种开源编程语言，于 2009 年正式对外发布。下面从多个方面为你介绍它：\n设计目标\rGo 语言的设计初衷是为了解决大规模软件开发中的一些问题，比如编译速度慢、并发编程复杂、代码可维护性差等。所以它结合了静态语言的性能优势和动态语言的开发效率。\n特点\r高效的编译和执行：Go 语言拥有快速的编译速度，这使得开发过程更加流畅。同时，它的执行效率也很高，能充分利用现代多核处理器的性能。 内置并发支持：Go 语言原生支持并发编程，通过goroutine和channel可以很方便地实现高并发程序。goroutine是一种轻量级的线程，占用资源少，创建和销毁的开销小；channel则用于goroutine之间的通信和同步。 垃圾回收机制：它具备自动垃圾回收功能，开发者无需手动管理内存，减少了内存泄漏的风险，提高了开发效率。 丰富的标准库：标准库涵盖了网络编程、文件操作、加密解密等多个领域，为开发者提供了便利，减少了对第三方库的依赖。 跨平台支持：可以在不同的操作系统和硬件平台上编译和运行，方便开发跨平台的应用程序。 应用场景\r云计算与容器编排：像 Docker 和 Kubernetes 这类知名项目，就是用 Go 语言开发的。 网络编程：由于其出色的并发性能和网络库，Go 语言非常适合开发网络服务器、代理服务器等。 分布式系统：在分布式系统中，Go 语言的并发模型和网络编程能力使其能够高效地处理大量的并发请求。 二、Go语言安装与配置\rGo语言支持以下系统：Linux、Mac、Windows。\n安装包下载地址：The Go Programming Language\nwindows\r直接安装系统下载安装即可！\nLinux\r将下载的二进制包解压至/usr/local目录\rtar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz AI写代码 将 /usr/local/go/bin 目录添加至 PATH 环境变量：\r可以编辑 /etc/profile，并将以下命令添加该文件的末尾，这样就可以永久生效：\nexport PATH=$PATH:/usr/local/go/bin AI写代码 然后执行\nsource /etc/profileAI写代码 三.编写基本测试用例\rpackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;)}AI写代码 go build 文件名+ 运行程序=go run文件名AI写代码 ","date":"2025-03-15 11:00:00","updated":"2025-03-15 11:00:00"},{"objectID":"1742061600","permalink":"/post/mac%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E9%80%9F%E8%AE%B0/","title":"mac使用笔记","content":"在Mac终端中，有几种方法可以连续删除命令：\n使用 Ctrl + W ：删除光标前的一个单词 使用 Ctrl + U ：删除光标前的整行内容 使用 Ctrl + K ：删除光标后的整行内容 使用 Option + Delete ：删除光标前的一个单词（与 Ctrl + W 类似） 这些快捷键可以帮助你快速删除命令内容，提高终端操作效率。 ","date":"2025-03-15 11:00:00","updated":"2025-03-15 11:00:00"},{"objectID":"1742061600","permalink":"/post/mysql----%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/","title":"数据库使用笔记","content":" 数据库的查询是数据库使用中比较重要的环节，前面的基础查询比较简单，不做介绍，可自行查阅。本文主要介绍复合查询，并结合用例进行讲解。\n本文的用例依据Soctt模式的经典测试表，可以自行下载，也可以自己创建\n链接：点这里跳转\n自行创建步骤如下：\n0、预备工作\r0.1 建表\r-- 创建 dept 表（部门表） CREATE TABLE dept ( deptno INT PRIMARY KEY, -- 部门编号 dname VARCHAR(14), -- 部门名称 loc VARCHAR(13) -- 部门位置 ); -- 创建 emp 表（员工表） CREATE TABLE emp ( empno INT PRIMARY KEY, -- 员工编号 ename VARCHAR(10), -- 员工姓名 job VARCHAR(9), -- 职位 mgr INT, -- 上级经理编号 hiredate DATE, -- 入职日期 sal DECIMAL(7,2), -- 工资 comm DECIMAL(7,2), -- 奖金 deptno INT, -- 部门编号 FOREIGN KEY (deptno) REFERENCES dept(deptno) ); -- 创建 salgrade 表（工资等级表） CREATE TABLE salgrade ( grade INT PRIMARY KEY, -- 工资等级 losal DECIMAL(7,2), -- 最低工资 hisal DECIMAL(7,2) -- 最高工资 ); 1234567891011121314151617181920212223242526AI写代码 0.2 插入测试数据\r-- 插入 dept 表数据 INSERT INTO dept (deptno, dname, loc) VALUES (10, \u0026#39;ACCOUNTING\u0026#39;, \u0026#39;NEW YORK\u0026#39;), (20, \u0026#39;RESEARCH\u0026#39;, \u0026#39;DALLAS\u0026#39;), (30, \u0026#39;SALES\u0026#39;, \u0026#39;CHICAGO\u0026#39;), (40, \u0026#39;OPERATIONS\u0026#39;, \u0026#39;BOSTON\u0026#39;); -- 插入 emp 表数据 INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES (7369, \u0026#39;SMITH\u0026#39;, \u0026#39;CLERK\u0026#39;, 7902, \u0026#39;1980-12-17\u0026#39;, 800.00, NULL, 20), (7499, \u0026#39;ALLEN\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-02-20\u0026#39;, 1600.00, 300.00, 30), (7521, \u0026#39;WARD\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-02-22\u0026#39;, 1250.00, 500.00, 30), (7566, \u0026#39;JONES\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-04-02\u0026#39;, 2975.00, NULL, 20), (7654, \u0026#39;MARTIN\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-09-28\u0026#39;, 1250.00, 1400.00, 30), (7698, \u0026#39;BLAKE\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-05-01\u0026#39;, 2850.00, NULL, 30), (7782, \u0026#39;CLARK\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-06-09\u0026#39;, 2450.00, NULL, 10), (7788, \u0026#39;SCOTT\u0026#39;, \u0026#39;ANALYST\u0026#39;, 7566, \u0026#39;1982-12-09\u0026#39;, 3000.00, NULL, 20), (7839, \u0026#39;KING\u0026#39;, \u0026#39;PRESIDENT\u0026#39;, NULL, \u0026#39;1981-11-17\u0026#39;, 5000.00, NULL, 10), (7844, \u0026#39;TURNER\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-09-08\u0026#39;, 1500.00, 0.00, 30), (7876, \u0026#39;ADAMS\u0026#39;, \u0026#39;CLERK\u0026#39;, 7788, \u0026#39;1983-01-12\u0026#39;, 1100.00, NULL, 20), (7900, \u0026#39;JAMES\u0026#39;, \u0026#39;CLERK\u0026#39;, 7698, \u0026#39;1981-12-03\u0026#39;, 950.00, NULL, 30), (7902, \u0026#39;FORD\u0026#39;, \u0026#39;ANALYST\u0026#39;, 7566, \u0026#39;1981-12-03\u0026#39;, 3000.00, NULL, 20), (7934, \u0026#39;MILLER\u0026#39;, \u0026#39;CLERK\u0026#39;, 7782, \u0026#39;1982-01-23\u0026#39;, 1300.00, NULL, 10); -- 插入 salgrade 表数据 INSERT INTO salgrade (grade, losal, hisal) VALUES (1, 700, 1200), (2, 1201, 1400), (3, 1401, 2000), (4, 2001, 3000), (5, 3001, 9999); 12345678910111213141516171819202122232425262728293031AI写代码 创建好以后，如果表的内容和下图一样，那基本就没问题了\n1、复合表的查询\r1.查询工资高于500 或 岗位为MANAGER 的雇员，同时还要满足他们的姓名首字母为大写的J\n根据上述的要求，我们可以发现，要查询的表总共两个条件，工资高于500 或 岗位为MANAGER， 首字母为J。 根据上述的两个条件，我们可以写出对应的sql查询语句： select name, job , sal from emp where (sal \u0026gt;= 500 or job = 'MANAGER') and enum like 'J%'; 这两个条件可以看成是并列条条件\n2.按照部门号升序而雇员工资降序的顺序对表的内容排序\n先观察一下这里的需求，首先就是要部门号升序，然后就是雇员的工资降序，所以这个案例的需求非常简单。根据这个要求我们可以写出sql查询语句：select deptno , sal from emp order by deptno asc , sal desc;\n3. 使用年薪进行降序排序\n这里我们需要特别注意的一个点就是年薪这个概念，年薪在这里是包括了12个月的月薪加上奖金，而这里奖金就是comm，但是奖金这一列很多都是NULL，而NULL是不参与计算的，所以这里就需要用ifnull(expression ，values)**(如果expression为null，返回的值为values否则返回expression)**利用这个函数的特点，我们就可以算出年薪 = 12 x sal + ifnull(comm,0)； 根据这个要求我们可以写出sql查询语句：select sal * 12 + ifnull(comm,0) 年薪 from emp order by 年薪 desc;\n4.显示工资最高的员工名字和工作岗位\n这条语句的要求非常简单，我们可以直接写出对应sql查询语句： select ename , job from emp where sal = (select max(sal) from emp);这里select是可以嵌套使用的，执行顺序就和C语言的中函数一样。当然，这里我们也可以分两步走，先把最高工资打印出来，再让第二条语句中 sal = 最高工资，结果是一样的。\n5. 显示工资高与平均工资的员工信息\n这个例子的要求和上面一个例子相差无几，做法也都差不多，先求出平均工资，再作比较即可。我们可以直接写出对应sql查询语句：select * from emp where sal \u0026gt;= (select avg(sal) from emp);\n6.显示每个部门的平均工资与最高工资\n这里也是只有两个条件，我们将平均工资和最高工资列出即可。我们可以直接写出对应sql查询语句：select deptno ,avg(sal),max(sal) from emp group by deptno;这里是先分组，然后再对内中内容进行筛查。\n7.显示平均工资低于两千的部门号和它的平均工资\n这个例子就需要和上面的例子一样，先对部门进行分组，分完组后就可以计算平均工资，然后再比对工资低于两千的部门。根据上述的条件，我们可以直接写出对应sql查询语句：select deptno ,avg(sal) 平均工资 from emp group by deptno having 平均工资 \u0026lt; 2000;这里的having是最后执行的，所以可以使用平均工资这个别名。\n8.显示每种岗位的雇员总数，平均工资\n这个例子和上面几个例子大差不差，这里不再赘述，直接把对应的语句写出：select deptno ,count(job) 人数,avg(sal) 平均工资 from emp group by job;\n2、多表复合查询\r前面我们介绍了单张表下的复合查询，但在日常生活中还存在非常的多表查询的情况。\n1、显示每一个雇员名，雇员工资和部门名称\n这个例子中和上面不同就是我们需要去查询部门名称，部门名称是在dept这张表中，而雇员名称以及工资在emp这张表中。这就需要我们将两张表的内容合并成一张表，也就是对第一张表的每一行内容与第二张表整张表进行组合，这种穷举的方式也叫作笛卡尔积。当然这种方式会生成很多没有啥意义的组合(部门号不对应)。这里我们就可以使用where进行筛查，select * from emp, dept where emp.deptno = dept.deptno结果如下图\n![\u0026gt;\n经过上述sql语句的筛查基本已经把要求给完成了，我们这里稍微完善一下即可：select ename,sal,dname from emp, dept where emp.deptno = dept.deptno\n3、自链接\r前面我们了解了不同表之间的进行链接查询，下面介绍一下同一张表之间链接。以下面这个例子为例：**a.显示员工FORD的上级领导的编号和姓名（mgr是员工领导的编号–empno）。**这个例子中，我们需要将在FORD的领导编号查出，然后在从当前这张表中查领导的相关信息。由此我们可以写出对应的sql语句：select empno,ename from emp where emp.empno=(select mgr from emp where ename=‘FORD’); 4、子查询\r**概念：子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询。**前面已有描述，这里就不再赘述\n4.1、单行子查询\r单行子查询表示的就是返回结果只有一行的子查询，以下面这一个通过下面这个例子帮助了解：\n显示SMITH同一部门的员工\n这个案例比较简单，我们只需先对SMITH先做子查询即可：select * from emp where deptno = (select deptno from emp where ename=‘smith’); 4.3、多行子查询\r这种子查询返回结果有很多行，但是原本子查询返回结果只有一行，所以这里我们需要将引入一些关键字，才能使其达到多行子查询的效果。\nin关键字 all关键字 any关键字 首先我们可以通过一个例子了解一下in关键字：a.查询和10号部门的工作岗位相同的雇员的名字，岗位，工资，部门号，但是不包含10自己.\n在这个例子中，我们要先查询10号部门的工作岗位相同的雇员，然后才是其它的相关信息，最后剔除十号部门。\n第一步：select distinct job from emp where deptno=10;\n第二步：select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10);这里的in在where中作为一种条件判断，表示判断job否在子查询中的表中。\n第三步：select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10) and deptno\u0026lt;\u0026gt;10;\n然后，我们通过另外一个例子来增加对all的理解：**显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号.**这里的all关键字其实和上面的in关键字一样，也是where中作为一种条件判断，代表子查询的所有结果。我们可以直接写出对应的sql语句：select ename, sal, deptno from emp where sal \u0026gt; all(select sal from emp where deptno=30); 最后一个any，作用和上面两个关键字大同小异，表示子查询的任意一个结果，用一个例子帮助理解：显示工资比部门30的任意员工的工资高的员工的姓名、工资和部门号（包含自己部门的员工）.，对应的sql语句：select ename, sal, deptno from emp where sal \u0026gt; any(select sal from emp where deptno=30); 4.4、多列子查询\r单行子查询是指子查询只返回单列，单行数据；多行子查询是指返回单列多行数据，都是针对单列而言的，而多列子查询则是指查询返回多个列数据的子查询语句。以下面例子为例：查询和SMITH的部门和岗位完全相同的所有雇员，不含SMITH本人这里第一步就是筛出SMITH部门和岗位相同的雇员，然后剔除SMITH，我们可以用括号的方式来对子查询各列的数据进行查询比对，具体方式如下： select ename from emp where (deptno, job)=(select deptno, job from emp where ename=‘SMITH’) and ename \u0026lt;\u0026gt; ‘SMITH’;\n4.5、from字句中使用子查询\r通过对前面的相关知识的了解，我们可以知道，子查询本质其实就是一张新的临时表，所以本质上我们查表都是在查一张表，就是将临时表和原表进行处理后的一张新表。既然上面 where 后面能够使用子查询，那from后面也必然是可以使用子查询的。from后面使用子查询就是将子查询生成的临时表与另外的表做笛卡尔积生成新的表，在从新的表中对数据进行筛查。下面用一个例子来帮助理解：显示每个高于自己部门平均工资的员工的姓名、部门、工资、平均工资\n对应的sql语句：//获取各个部门的平均工资，将其看作临时表 select ename, deptno, sal, format(asal,2) from emp, (select avg(sal) asal, deptno dt from emp group by deptno) tmp where emp.sal \u0026gt; tmp.asal and emp.deptno=tmp.dt;需要 需要注意的时from中子查询形成的临时表要有临时的名称。\n5、合并查询\r由于这个合并查询并不多见，使用率也较低，所以这里简单介绍即可。\nunion操作符：该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中的重复行。例子：将工资大于2500或职位是MANAGER的人找出来。 sql语句：select ename, sal, job from emp where sal\u0026gt;2500 union select ename, sal, job fromemp where job='MANAGER';\nunion all操作符：该操作符用于取得两个结果集的并集。当使用该操作符时，不会去掉结果集中的重复行。例子：将工资大于25000或职位是MANAGER的人找出来。sql语句：select ename, sal, job from emp where sal\u0026gt;2500 union all select ename, sal, job from emp where job='MANAGER';\n","date":"2025-03-15 11:00:00","updated":"2025-03-15 11:00:00"}]