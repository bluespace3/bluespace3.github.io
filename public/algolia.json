[{"objectID":"1763828471","permalink":"/post/%E5%B7%A5%E4%BD%9C/1017/","title":"1017","content":"小助 测试总结情况\n项目进度和规划： 体感：小助：对测试值班的帮助-群里问题是减少的，从小助-\u0026gt;智能工单,问题减少更明显。\n进度：\n规划：\n医学助手 参与的其实不多并不是很多，参与了3次。 评测数据构造、体验评测流程、线上问题收集分析。\n混合检索效果没有语义检索效果好？语义和混合检索调试权重。平台限制有没有考虑自定义开发，借助一些lanchain之类的框架。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E9%87%8F%E5%8C%96%E9%A1%B9%E7%9B%AE/ai%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E5%86%B3%E7%AD%96%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88/","title":"AI量化交易决策系统方案","content":"\r📝 2025-07-13 近期优化与变更\r新增布林带、KDJ、成交量、ATR、威廉指标，技术指标体系更丰富。 评分体系优化：技术面40分、基本面35分、情绪面25分，ETF与A股评分规则分离，ETF基本面恒为0，ETF评分=技术面50分+AI消息面50分。 决策等级优化：5级决策（重仓买入、买入、持有、谨慎持有、卖出），买入阈值降至50分，持有30分，谨慎持有10分，卖出\u0026lt;10分。 日志与邮件去重：每只股票仅保留最新信号，输出和报告更简明。 自动邮件集成：主程序运行后自动发送HTML格式决策报告，内容美化，信号带emoji和中文名。 数据兼容性增强：分析引擎支持成交量列名为vol或volume。 AI分析优化：ETF和A股分开提示，ETF基本面恒为0，AI消息面更关注资金流和行业新闻。 文档完善：补充README、部署、API、策略等文档，详细说明系统架构、评分体系、部署与接口。 用户体验提升：聚合报告美化，策略可读性提升，项目说明更精炼。 本文档详细阐述了本量化交易系统的核心决策逻辑。系统通过对技术面、基本面和AI市场情绪面三个维度进行独立的量化评分，最终加权汇总，生成交易信号。\n总分 = 技术面得分 + 基本面得分 + AI市场情绪面得分\n重仓买入阈值: 总分 \u0026gt;= 80 买入阈值: 总分 \u0026gt;= 60 持有阈值: 总分 \u0026gt;= 20 谨慎持有阈值: 总分 \u0026gt;= -10 卖出阈值: 总分 \u0026lt; -10 ETF评分体系（指数基金/ETF专用）\r技术面：50分（均线、成交量、波动率等为主，弱化KDJ等短线指标） AI消息面：50分（重点关注资金流向、申购赎回、行业轮动、指数调整等） 基本面：恒为0分（ETF不参与基本面打分） 总分 = 技术面得分（归一化到50分） + AI消息面得分（归一化到50分）\n归一化方法：技术面原始得分/40×50，AI消息面原始得分/25×50，四舍五入取整。 ETF决策流程与A股一致，但分数分布和信号解释更侧重资金流和行业轮动。 一、 技术面分析 (总权重: 40分)\r技术面分析旨在捕捉市场的短期趋势和动量。它由四个核心指标构成，各自有独立的评分和权重。\n指标 权重 触发条件 得分 MACD趋势 15分 看涨金叉 (DIF上穿DEA，且DIF\u0026gt;0) +15 看跌死叉 (DIF下穿DEA，且DIF\u0026lt;0) -15 多头排列 (DIF\u0026gt;DEA) +8 空头排列 (DIF\u0026lt;DEA) -8 RSI动量 10分 RSI \u0026lt; 30 (超卖区) +10 RSI \u0026gt; 70 (超买区) -10 RSI \u0026lt; 40 (偏弱) +5 RSI \u0026gt; 60 (偏强) -5 布林带 8分 价格触及下轨 +8 价格触及上轨 -8 价格在中轨下方 +3 价格在中轨上方 -3 KDJ指标 7分 KDJ超卖 (K\u0026lt;20, D\u0026lt;20) +7 KDJ超买 (K\u0026gt;80, D\u0026gt;80) -7 KDJ金叉 (K\u0026gt;D) +3 KDJ死叉 (K\u0026lt;D) -3 最终报告形式: 技术面得分: [总分] | 原因: [综合原因] (MACD: [得分], RSI: [得分], 布林带: [得分], KDJ: [得分])\n二、 基本面分析 (总权重: 35分)\r基本面分析旨在评估资产的内在价值。它由三个核心估值指标构成，以适应不同类型的投资标的。\n1. 市盈率 (PE) - (权重: 15分)\r数据来源: Akshare实时接口。对于ETF，则自动获取其跟踪指数的PE。 评分标准: PE \u0026lt; 15: +15分 (估值低) 15 \u0026lt;= PE \u0026lt; 30: +8分 (估值合理) 30 \u0026lt;= PE \u0026lt; 50: -8分 (估值偏高) PE \u0026gt;= 50: -15分 (估值过高) 2. 市净率 (PB) - (权重: 12分)\r数据来源: Akshare实时接口。对于ETF，则自动获取其跟踪指数的PB。 评分标准: PB \u0026lt; 1.5: +12分 (估值低) 1.5 \u0026lt;= PB \u0026lt; 3: +6分 (估值合理) 3 \u0026lt;= PB \u0026lt; 5: -6分 (估值偏高) PB \u0026gt;= 5: -12分 (估值过高) 3. 股息率 (Dividend Yield) - (权重: 8分)\r数据来源: Akshare实时接口。 评分标准: 股息率 \u0026gt; 4%: +8分 (高股息) 2% \u0026lt; 股息率 \u0026lt;= 4%: +4分 (股息尚可) 股息率 \u0026lt;= 2%: -8分 (股息较低) 评分平衡性: 正向分数总和 = 负向分数总和 = 35分\n正向: 15 + 12 + 8 = 35分 负向: (-15) + (-12) + (-8) = -35分 最终报告形式: 基本面得分: [总分] | 原因: [综合原因] (PE: [得分], PB: [得分], DY: [得分])\n三、 AI市场情绪面分析 (总权重: 25分)\r本部分利用Gemini的联网搜索和分析能力，对最新的市场新闻和公告进行情绪量化。\n执行方式: 向Gemini API发送一个包含股票名称和代码的Prompt。\n返回格式: 要求Gemini返回一个包含以下字段的JSON对象：\nsentiment_score: 一个从 -10 (极度利空) 到 +10 (极度利好) 的量化分数。 sentiment_reason: 一句话总结的核心判断原因。 key_factors: 1-3个影响判断的关键事件列表。 data_date: 关键信息的最新日期。 分数换算: Gemini返回的 sentiment_score将乘以 2.5，以匹配本项 25分 的总权重。\n最终报告形式: AI消息面得分: [总分] | 原因: [AI总结的原因] (数据更新至: [日期]) 关键因素: [AI识别的关键事件]\n四、 新增技术指标\r系统现已支持更多A股常用的技术指标：\n1. 布林带 (Bollinger Bands)\r计算方式: 20日移动平均线 ± 2倍标准差 应用: 判断价格波动区间和超买超卖状态 2. KDJ指标\r计算方式: 基于9日RSV的随机指标 应用: 判断超买超卖和买卖时机 3. 成交量指标\r计算方式: 5日和10日成交量移动平均 应用: 分析量价关系和资金流向 4. ATR (平均真实波幅)\r计算方式: 14日真实波幅移动平均 应用: 衡量市场波动性和设置止损位 5. 威廉指标 (Williams %R)\r计算方式: 基于14日最高最低价的动量指标 应用: 判断超买超卖状态 五、 最终决策报告\r系统在完成对所有股票的分析后，会生成一份聚合的决策报告表格，清晰地展示所有目标的分析结果。\n1. 单只股票分析过程输出\r在分析过程中，系统会为每只股票打印一行简要的完成信息，如下所示：\n--- 正在分析股票: 贵州茅台 (600519.SH) --- 分析完成: 贵州茅台 (600519.SH) - 总分: 65 | 最终信号: 【买入】 ---------------------------------------- 2. 最终聚合报告\r所有股票分析完成后，系统会打印一个统一的表格，汇总所有决策报告，方便横向对比。\n聚合报告表示例:\n股票名称 | 代码 | 技术面得分 | 基本面得分 | AI消息面得分 | 总分 | 最终决策 | 类型 ------------------------------------------------------------------------------------------------------------------ 贵州茅台 | 600519.SH | -5 | 17 | -8 | 4 | 【谨慎持有】 | A股 平安银行 | 000001.SZ | 25 | 15 | 12 | 52 | 【买入】 | A股 沪深300ETF | 510300.SH | 32 | 0 | 30 | 62 | 【买入】 | ETF 3. 决策等级说明\r重仓买入 (紫色): 总分 \u0026gt;= 80，强烈推荐买入信号 买入 (绿色): 总分 \u0026gt;= 60，推荐买入信号 持有 (黄色): 总分 \u0026gt;= 20，建议持有观望 谨慎持有 (青色): 总分 \u0026gt;= -10，建议谨慎持有或减仓 卖出 (红色): 总分 \u0026lt; -10，建议卖出信号 ETF决策等级说明\r重仓买入：总分 ≥ 80 买入：总分 ≥ 50 持有：总分 ≥ 30 谨慎持有：总分 ≥ 10 卖出：总分 \u0026lt; 10 注：ETF波动性低，建议结合资金流向和行业轮动信号综合判断。\n4. 日志文件\r对于有明确 买入/重仓买入 或 卖出 信号的股票，详细的决策依据会被记录在 logs/trade_signals_YYYY-MM-DD.log 文件中，供后续复盘。\n日志格式示例:\nSignal for 贵州茅台 (600519.SH) on 2025-01-13: 【买入】 - Tech: 15 (MACD看涨金叉, RSI(45.2)偏弱) (MACD: 15, RSI: 5, 布林带: 3, KDJ: -3) - Fundamentals: 17 (PE: PE=25.30, 估值合理, PB: PB=8.50, 估值过高, 股息率: 股息率=1.20%, 股息较低) (PE: 8, PB: -8, DY: 0) - AI Sentiment: -8 (市场情绪偏谨慎) (Data until: 2025-01-13) 关键因素: 白酒行业政策调整, 消费需求变化 - TOTAL SCORE: 24 ETF决策报告示例\r--- 正在分析ETF: 沪深300ETF (510300.SH) --- 分析完成: 沪深300ETF (510300.SH) - 总分: 62 | 最终信号: 【买入】 - 技术面: 32（均线多头排列，成交量放大） - 基本面: 0（ETF不参与基本面打分） - AI消息面: 30（资金净流入，行业轮动利好） ---------------------------------------- ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E9%87%8F%E5%8C%96%E9%A1%B9%E7%9B%AE/ai%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E5%86%B3%E7%AD%96%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/","title":"AI量化交易决策系统技术文档","content":"\r📝 2025-07-13 近期优化与变更\rAPI支持ETF与A股评分体系分离，ETF基本面恒为0，ETF评分=技术面50分+AI消息面50分。 评分体系与决策等级优化，买入阈值降至50分，持有30分，谨慎持有10分，卖出\u0026lt;10分。 日志与邮件内容去重，每只股票仅保留最新信号。 集成自动邮件功能，主程序运行后自动发送HTML决策报告。 数据兼容性增强，分析引擎支持成交量列名为vol或volume。 文档补充与完善，详细说明系统架构、评分体系、部署与接口。 用户体验提升，聚合报告美化，策略可读性提升。 📋 概述\r本文档详细说明了量化交易系统的各个模块、类、方法和接口，为开发者提供完整的API参考。\n🏗️ 系统架构\r核心模块\rsrc/ ├── config.py # 配置管理 ├── data_loader.py # 数据加载器 ├── analysis_engine.py # 分析引擎 ├── strategy_engine.py # 策略引擎 └── gemini_analyzer.py # AI分析器 📊 配置模块 (config.py)\r类和方法\r配置常量\r股票池配置\rSTOCK_POOL = { \u0026ldquo;000001.SZ\u0026rdquo;: \u0026ldquo;平安银行\u0026rdquo;, \u0026ldquo;600519.SH\u0026rdquo;: \u0026ldquo;贵州茅台\u0026rdquo;, # \u0026hellip; }\nAPI配置\rGEMINI_API_URL = \u0026ldquo;https://rglnawodplak.ap-southeast-1.clawcloudrun.com/****t/completions\u0026rdquo; GEMINI_API_KEY = \u0026ldquo;\u0026rdquo;\n数据路径\rDATA_PATH = \u0026ldquo;data\u0026rdquo;\n📈 数据加载器 (data_loader.py)\rDataLoader 类\r方法\r__init__(self)\r初始化数据加载器。\n参数: 无 返回: 无\nrun_update(self, days_to_fetch: int = 365)\r更新所有股票的最新数据。\n参数:\ndays_to_fetch (int): 获取数据的天数，默认365天 返回: 无\n异常:\nException: 数据更新失败时抛出 update_single_stock(self, stock_code: str, days_to_fetch: int = 365)\r更新单个股票的数据。\n参数:\nstock_code (str): 股票代码 days_to_fetch (int): 获取数据的天数 返回: 无\n🔍 分析引擎 (analysis_engine.py)\rAnalysisEngine 类\r技术指标计算方法\rcalculate_ma(self, data: pd.DataFrame, window: int) -\u0026gt; pd.Series\r计算移动平均线。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): 移动平均窗口大小 返回: pd.Series - 移动平均线数据\n异常:\nValueError: 数据中缺少 \u0026lsquo;close\u0026rsquo; 列时抛出 calculate_rsi(self, data: pd.DataFrame, window: int = 14) -\u0026gt; pd.Series\r计算相对强弱指数。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): RSI计算窗口，默认14 返回: pd.Series - RSI数据\ncalculate_macd(self, data: pd.DataFrame, short_window: int = 12, long_window: int = 26, signal_window: int = 9)\r计算MACD指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;close\u0026rsquo; 列的DataFrame short_window (int): 短期EMA窗口，默认12 long_window (int): 长期EMA窗口，默认26 signal_window (int): 信号线EMA窗口，默认9 返回: tuple - (MACD, Signal Line, MACD Histogram)\ncalculate_bollinger_bands(self, data: pd.DataFrame, window: int = 20, num_std: float = 2)\r计算布林带指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): 移动平均窗口，默认20 num_std (float): 标准差倍数，默认2 返回: tuple - (上轨, 中轨, 下轨)\ncalculate_kdj(self, data: pd.DataFrame, n: int = 9, m1: int = 3, m2: int = 3)\r计算KDJ指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;high\u0026rsquo;, \u0026rsquo;low\u0026rsquo;, \u0026lsquo;close\u0026rsquo; 列的DataFrame n (int): RSV计算周期，默认9 m1 (int): K值平滑系数，默认3 m2 (int): D值平滑系数，默认3 返回: tuple - (K, D, J值)\ncalculate_volume_indicators(self, data: pd.DataFrame)\r计算成交量相关指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;volume\u0026rsquo; 或 \u0026lsquo;vol\u0026rsquo; 列的DataFrame 返回: tuple - (成交量MA5, 成交量MA10, 量价关系)\ncalculate_atr(self, data: pd.DataFrame, window: int = 14)\r计算平均真实波幅。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;high\u0026rsquo;, \u0026rsquo;low\u0026rsquo;, \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): ATR计算窗口，默认14 返回: pd.Series - ATR值\ncalculate_williams_r(self, data: pd.DataFrame, window: int = 14)\r计算威廉指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;high\u0026rsquo;, \u0026rsquo;low\u0026rsquo;, \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): 计算窗口，默认14 返回: pd.Series - Williams %R值\nrun_all_indicators(self, data: pd.DataFrame) -\u0026gt; pd.DataFrame\r为给定的数据计算所有预设的技术指标。\n参数:\ndata (pd.DataFrame): 原始日线数据 返回: pd.DataFrame - 附加了所有技术指标列的DataFrame\n🎯 策略引擎 (strategy_engine.py)\rStrategyEngine 类\r决策等级常量\rDECISION_LEVELS = { \u0026#39;STRONG_BUY\u0026#39;: 2, # 重仓买入: 总分 \u0026gt;= 80 \u0026#39;BUY\u0026#39;: 1, # 买入: 总分 \u0026gt;= 60 \u0026#39;HOLD\u0026#39;: 0, # 持有: 总分 \u0026gt;= 20 \u0026#39;CAUTIOUS_HOLD\u0026#39;: -1, # 谨慎持有: 总分 \u0026gt;= -10 \u0026#39;SELL\u0026#39;: -2 # 卖出: 总分 \u0026lt; -10 } 评分方法\rget_pe_score(self, pe_ratio_str: str) -\u0026gt; tuple[int, str]\r根据PE估值打分。\n参数:\npe_ratio_str (str): PE比率字符串 返回: tuple - (得分, 原因说明)\nget_pb_score(self, pb_ratio_str: str) -\u0026gt; tuple[int, str]\r根据PB估值打分。\n参数:\npb_ratio_str (str): PB比率字符串 返回: tuple - (得分, 原因说明)\nget_dividend_yield_score(self, dividend_yield_str: str) -\u0026gt; tuple[int, str]\r根据股息率打分。\n参数:\ndividend_yield_str (str): 股息率字符串 返回: tuple - (得分, 原因说明)\nget_sentiment_score(self, gemini_analysis: dict) -\u0026gt; tuple[int, str]\r根据Gemini返回的量化情绪分进行打分。\n参数:\ngemini_analysis (dict): Gemini分析结果 返回: tuple - (得分, 原因说明)\nget_technical_score(self, data: pd.DataFrame) -\u0026gt; tuple[int, str, dict]\r根据多指标组合进行技术面综合打分。\n参数:\ndata (pd.DataFrame): 包含技术指标的DataFrame 返回: tuple - (总分, 原因字符串, 分数明细字典)\nget_decision_level(self, total_score: int) -\u0026gt; tuple[int, str]\r根据总分确定决策等级。\n参数:\ntotal_score (int): 总分 返回: tuple - (决策等级代码, 决策描述)\ngenerate_signals(self, data: pd.DataFrame, gemini_analysis: dict) -\u0026gt; tuple[pd.DataFrame, dict]\r根据技术面和Gemini的全面分析生成最终信号。\n参数:\ndata (pd.DataFrame): 包含技术指标的DataFrame gemini_analysis (dict): Gemini分析结果 返回: tuple - (添加了信号的DataFrame, 决策报告字典)\n🤖 AI分析器 (gemini_analyzer.py)\rGeminiAnalyzer 类\r方法\r__init__(self)\r初始化Gemini分析器。\n参数: 无 返回: 无\nget_holistic_analysis(self, stock_name: str, stock_code: str) -\u0026gt; dict\r获取股票的全面分析。\n参数:\nstock_name (str): 股票名称 stock_code (str): 股票代码 返回: dict - 包含分析结果的字典\n返回格式:\n{ \u0026#39;pe\u0026#39;: \u0026#39;25.5\u0026#39;, \u0026#39;pb\u0026#39;: \u0026#39;2.8\u0026#39;, \u0026#39;dividend_yield\u0026#39;: \u0026#39;3.2\u0026#39;, \u0026#39;sentiment_score\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;sentiment_reason\u0026#39;: \u0026#39;市场情绪良好\u0026#39;, \u0026#39;key_factors\u0026#39;: [\u0026#39;政策利好\u0026#39;, \u0026#39;业绩增长\u0026#39;], \u0026#39;data_date\u0026#39;: \u0026#39;2024-01-15\u0026#39; } 📧 邮件模块 (send_email.py)\r函数\rsend_email(subject: str, body: str, attachments: dict = None)\r发送邮件。\n参数:\nsubject (str): 邮件主题 body (str): 邮件内容 attachments (dict): 附件字典，可选 返回: 无\n异常:\nException: 邮件发送失败时抛出 read_file_content(filepath: str) -\u0026gt; str\r读取文件内容。\n参数:\nfilepath (str): 文件路径 返回: str - 文件内容，失败时返回None\nget_latest_log_content() -\u0026gt; str\r获取最新的日志内容。\n参数: 无 返回: str - 最新日志内容，无日志时返回None\nformat_decision_report() -\u0026gt; str\r格式化决策报告。\n参数: 无 返回: str - HTML格式的决策报告\n🧪 测试模块 (test_new_system.py)\r函数\rcreate_test_data() -\u0026gt; pd.DataFrame\r创建测试数据。\n参数: 无 返回: pd.DataFrame - 模拟的股票数据\ntest_analysis_engine()\r测试分析引擎。\n参数: 无 返回: pd.DataFrame - 分析后的数据\ntest_strategy_engine()\r测试策略引擎。\n参数: 无 返回: 无\ntest_decision_levels()\r测试决策等级。\n参数: 无 返回: 无\nmain()\r主测试函数。\n参数: 无 返回: 无\n📊 主程序 (main.py)\r函数\rsetup_logging()\r创建日志目录。\n参数: 无 返回: 无\nlog_signal(signal_to_log: str)\r将信号记录到当天的日志文件中。\n参数:\nsignal_to_log (str): 要记录的信号 返回: 无\nget_signal_color_and_text(signal: int, decision_desc: str) -\u0026gt; tuple[str, str]\r根据信号获取颜色和文本。\n参数:\nsignal (int): 信号代码 decision_desc (str): 决策描述 返回: tuple - (带颜色的文本, 纯文本)\nrun_main_flow()\r执行主流程。\n参数: 无 返回: 无\n🔧 配置说明\r环境变量\r# 可选的环境变量 GEMINI_API_URL=your-api-url GEMINI_API_KEY=your-api-key SMTP_SERVER=smtp.126.com EMAIL_ADDRESS=your-email@126.com EMAIL_PASSWORD=your-password 配置文件\rsrc/config.py: 主要配置文件 send_email.py: 邮件配置 requirements.txt: 依赖包列表 📝 日志格式\r交易信号日志格式\rSignal for 股票名称 (股票代码) on 日期: 【决策】 - Tech: 技术面得分 (技术面原因) (技术面明细) - Fundamentals: 基本面得分 (基本面原因) (基本面明细) - AI Sentiment: 情绪面得分 (情绪面原因) (数据日期) 关键因素 - TOTAL SCORE: 总分 系统日志格式\r时间戳 - 日志内容 ⚠️ 错误处理\r常见异常\rValueError: 数据格式错误 FileNotFoundError: 文件未找到 Exception: 网络错误、API错误等 错误处理建议\r检查数据完整性 验证API配置 确认网络连接 查看详细错误日志 🔄 版本历史\rv2.0 (当前版本)\r新增技术指标：布林带、KDJ、成交量、ATR、威廉指标 改进评分系统：技术面40分、基本面35分、情绪面25分 5级决策系统：重仓买入、买入、持有、谨慎持有、卖出 优化邮件报告：HTML格式，更好的可读性 完善项目文档 v1.0\r基础技术指标：MA、RSI、MACD 基础评分系统 3级决策系统：买入、持有、卖出 基础邮件功能 API版本: v2.0 最后更新: 2025-01-13 维护者: 量化交易系统团队\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E6%95%99%E7%A8%8B/docker%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","title":"docker使用笔记","content":"docker pull ubuntu 载入ubuntu 镜像\ndocker pull training/webapp # 载入镜像\ndocker pull python:3.7 安装python镜像\ndocker pull nginx 安装nginx镜像\ndocker run -it python:3.7 /bin/bash 进入python镜像\n连接不上时，终端输入：\n1.cd \u0026ldquo;C:\\Program Files\\Docker\\Docker\u0026rdquo;\n2.DockerCli.exe -SwitchDaemon\ndocker run -it ubuntu /bin/bash 启用进入容器\nexit退出容器\ndocker run -d -P training/webapp python app.py 后台启用容器并随机映射到本机端口\ndocker run -d -p 5000:5000 training/webapp python app.py后台启用容器并指定映射到\ndocker logs -f id 查看应用日志\ndocker logs -f -t \u0026ndash;tail=100 dockerid 动态查看最新100条日志\ndocker top id 查看容器内部应用进程\ndocker ps -a 查看所有容器(可查容器id)\ndocker ps 查看在运行的容器\ndocker ps -l 查询最后一次创建的容器\ndocker start id 启用对应id的容器\ndocker restart id重启\ndocker stop id 停止\ndocker run -dit -p 5000:80 -v /opt/app/docker_app/tools_flask/tools:/usr/src/app/tools \u0026ndash;name tools-flask tools_flask; 启动容器并持久化docker目录\ndocker run -itd \u0026ndash;name ubuntu-test ubuntu /bin/bash 后台运行容器\ndocker exec -it id bash进入容器\ndocker export id \u0026gt; ubuntu.tar 导出容器\ncat docker/ubuntu.tar | docker import - test/ubuntu:v1 导入容器到镜像\ndocker rm -f id 删除容器\ndocker images 列出镜像列表\n镜像下载： https://hub.docker.com/\ndocker search 关键词搜索镜像\n传输文件\ndocker cp 本地文件的路径 container_id:\u0026lt;docker容器内的路径\u0026gt;\ndocker run -p 3000:80 -d \u0026ndash;name vueApp vuenginxcontainer\nDockerfile 来构建镜像\n1.创建Dockerfile 填写配置内容，参考：E:\\code\\flask_tools\\tools\\Dockerfile\n2.docker build -t flask_tools:v1 . Dockerfile当前目录构建镜像. 是基于当前目录的 。后面的.不能少\n3.docker run -p 5000:80 -d \u0026ndash;name flask2 flask_tools:v1 top bin/bash启用容器\ngunicorn -k gevent -c gunicorn.conf flask_index:app项目名 # 用gunicorn启动项目\n上传到docker hub\n先给要上传的仓库打上标签：\ndocker tag id tianqinghong/python_vue_share\n再push:\ndocker push tianqinghong/python_vue_share\n下载镜像\ndocker pull tianqinghong/python_vue_share\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E5%B7%A5%E5%85%B7/doc%E8%BD%ACmd/","title":"doc转md","content":" Pandoc 简介 Pandoc 是一个由 John MacFarlane 开发的开源“瑞士军刀”，用于在不同标记语言格式之间进行转换。它支持数十种输入和输出格式，包括 DOCX、Markdown、HTML、PDF、EPUB 等。由于其强大的转换引擎和对细节的关注，它在从 DOCX 转换为 Markdown时能很好地保留格式，例如标题、列表、表格、代码块等。\n安装 Pandoc 你可以从 Pandoc 的官方网站下载安装程序，或者使用包管理器进行安装。\nWindows: 从 httpss://github.com/jgm/pandoc/releases/latest 下载最新的 .msi 安装包并运行它。 或者，如果你使用 winget 或 choco： winget install \u0026ndash;id=JohnMacFarlane.Pandoc choco install pandoc macOS: 使用 Homebrew: brew install pandoc Linux (Debian/Ubuntu): sudo apt-get install pandoc 使用示例 安装完成后，你可以在命令行（Powershell、Terminal 等）中使用 pandoc 命令。它的基本用法非常简单：\npandoc [输入文件] -o [输出文件]\n例如，要将一个名为 报告.docx 的文件转换为 报告.md，你只需运行：\npandoc 报告.docx -o 报告.md\nPandoc 会自动根据文件扩展名（.docx 和 .md）判断输入和输出格式。转换后的 Markdown 文件将保存在同一目录下。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E6%95%99%E7%A8%8B/encrypted-example/","title":"encrypted-example","content":"\r这是一篇加密的文章\r只有输入正确的密码才能查看这篇文章的内容。\n如何设置文章加密\r在文章的前置参数中添加以下内容：\nencrypted: true password: \u0026#34;你的密码\u0026#34; 这样就可以为文章添加密码保护了。\n密码保护的工作原理\r当用户访问加密文章时，会显示密码输入框 用户输入正确的密码后，文章内容才会显示 密码验证在浏览器端进行，不需要服务器支持 使用sessionStorage保存解锁状态，避免刷新页面后需要重新输入密码 注意事项\r这种加密方式只是前端加密，不能防止真正的黑客攻击 适合用于简单的内容保护，不适合保护高度敏感的信息 密码直接保存在文章的前置参数中，所以不要使用您在其他地方使用的重要密码 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E6%95%99%E7%A8%8B/gemma-3%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/","title":"Gemma 3本地部署教程","content":"Gemma 3 被谷歌称为目前最强的开源视觉模型之一。 该模型支持超过35种语言，能够分析文本、图像和短视频。值得注意的是，Gemma 3 的视觉编码器经过升级，支持高分辨率和非方形图像，并引入了 ShieldGemma 2 图像安全分类器，用于过滤被分类为性暗示、危险或暴力的内容。这些特性使得 Gemma 3 成为当前最强大的开源视觉模型之一。\n最新的 Gemma 3 多模态开源模型新功能\r使用世界上最好的单加速器模型进行构建： Gemma 3 以其尺寸提供最先进的性能，在 LMArena 排行榜的初步人类偏好评估中胜过 Llama3-405B、DeepSeek-V3 和 o3-mini。这可以帮助您创建可安装在单个 GPU 或 TPU 主机上的引人入胜的用户体验。 以 140 种语言走向全球：构建使用客户语言的应用程序。Gemma 3 提供对超过 35 种语言的开箱即用支持和对超过 140 种语言的预训练支持。 打造具备高级文本和视觉推理能力的AI：轻松构建分析图片、文本、短视频等应用，开启交互智能化新可能1。 使用扩展的上下文窗口处理复杂任务： Gemma 3 提供 128k 令牌上下文窗口，让您的应用程序处理和理解大量信息。 使用函数调用创建 AI 驱动的工作流程： Gemma 3 支持函数调用和结构化输出，以帮助您自动执行任务并构建代理体验。 通过量化模型更快地实现高性能： Gemma 3 引入了官方量化版本，减少了模型大小和计算要求，同时保持了高精度。\n本地安装，单显卡可以选择1b，4b，12b，27b，推荐选择27b，因为Gemma 3 27B 处于帕累托最佳点.\n本地部署Gemma 3开源大模型：\r1、下载官方 Ollama 【 点击前往 】 ，并通过下方的安装命令执行下载：\n普通用户建议选择4b和12b，显卡好的可以上27b\nollama run gemma3:1b ollama run gemma3:4b ollama run gemma3:12b ollama run gemma3:27b 2、通过Cherry Studio,添加本地大模型后使用 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/git/git-submodule/","title":"Git submodule","content":" title: \u0026ldquo;Git submodule\u0026rdquo;\ncategories: [\u0026ldquo;技术\u0026rdquo;, \u0026ldquo;git\u0026rdquo;, \u0026ldquo;hugo\u0026rdquo;]\ndate: 2025-03-20T12:59:32+08:00\ndraft: false\ntags: [\u0026ldquo;submodule\u0026rdquo;, \u0026ldquo;Git\u0026rdquo;, \u0026ldquo;教程\u0026rdquo;]\rGit submodule添加子项目_库 Git归并策略 添加 删除 输入“/”快速插入内容\n添加图标\n添加封面\n展示文档信息\nGit submodule添加子项目_库\n开发过程中，经常会有一些通用的部分希望抽取出来做成一个公共库来提供给别的工程来使用，而公共代码库的版本管理是个麻烦的事情。git submodule命令就可以解决这个问题。\nGit归并策略\nGit归并有两种策略：递归，章鱼。\n1.递归策略：当分支数只有两个的时候。\n2.章鱼策略：当分支数大于两个的时候。\nGit会自动选择归并的方法。\n3.子树策略：是Git另一种归并方法。（submodule）\n它可以把另一个子项目，嵌入到当前项目。而且会非常聪明的合并这些子项目。\n添加\n为当前工程添加submodule，命令如下：\ngit submodule add 仓库地址 路径\n其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。\n注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）\n示例:\ngit submodule add -f http://git.cs/Cmblife_iOS_Internal/modulesLib.git\n-f 是强制的意思，一般不需要加\n命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。\n删除\nsubmodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。\n下载的工程带有submodule\n当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：\ngit submodule update –init –recursive\n即可将子模块内容下载下来后工程才不会缺少相应的文件。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/git/gitlab%E9%85%8D%E7%BD%AEcicd%E5%B7%A5%E4%BD%9C%E6%B5%81/","title":"gitlab配置cicd工作流","content":"\rGitLab CI/CD 简介\rGitLab CI/CD 是 GitLab 内置的持续集成/持续部署工具，它允许开发者在代码提交后自动执行一系列任务，如构建、测试和部署。通过配置 CI/CD 流程，可以大大提高开发效率，减少人为错误，并确保代码质量。\nCI/CD 核心概念\r持续集成 (CI): 开发人员频繁地将代码集成到主分支，每次集成都通过自动化构建和测试来验证，从而尽早发现问题。 持续交付 (CD): 确保代码随时可以部署到生产环境，通常包括自动化测试和部署流程。 持续部署 (CD): 将持续交付更进一步，自动将通过测试的代码部署到生产环境。 .gitlab-ci.yml 配置文件\rGitLab CI/CD 的核心是 .gitlab-ci.yml 文件，它定义了 CI/CD 流水线的结构和行为。该文件需要放在项目的根目录下。\n基本结构\r# 定义阶段 stages: - build - test - deploy # 定义作业 build_job: stage: build script: - echo \u0026#34;Building the app\u0026#34; - make build test_job: stage: test script: - echo \u0026#34;Running tests\u0026#34; - make test deploy_job: stage: deploy script: - echo \u0026#34;Deploying the app\u0026#34; - make deploy only: - master 关键组件\rstages: 定义流水线的阶段，按顺序执行。 jobs: 定义在特定阶段执行的任务。 script: 在作业中执行的命令。 only/except: 控制作业何时运行（例如，只在特定分支上运行）。 GitLab Runner\rGitLab Runner 是执行 CI/CD 作业的代理，它可以安装在不同的环境中，如 Linux、Windows、macOS 等。\n安装 GitLab Runner\r# 在 Linux 上安装 curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash sudo apt-get install gitlab-runner # 在 macOS 上安装 brew install gitlab-runner 注册 Runner\rsudo gitlab-runner register 注册过程中，需要提供 GitLab 实例的 URL 和注册令牌，以及 Runner 的标签和执行器类型。\n高级配置\r环境变量\rvariables: DATABASE_URL: \u0026#34;postgres://postgres:postgres@postgres:5432/my_database\u0026#34; job_name: variables: DATABASE_URL: \u0026#34;postgres://postgres:postgres@postgres:5432/my_test_database\u0026#34; script: - echo $DATABASE_URL 缓存和构件\rcache: paths: - node_modules/ job_name: artifacts: paths: - dist/ expire_in: 1 week 依赖关系\rjob_name: stage: deploy dependencies: - build_job script: - echo \u0026#34;Deploying the app\u0026#34; 实际应用示例\rNode.js 项目\rimage: node:14 stages: - build - test - deploy cache: paths: - node_modules/ build: stage: build script: - npm install - npm run build artifacts: paths: - dist/ test: stage: test script: - npm run test deploy_staging: stage: deploy script: - npm install -g firebase-tools - firebase use staging - firebase deploy --token $FIREBASE_TOKEN only: - develop deploy_production: stage: deploy script: - npm install -g firebase-tools - firebase use production - firebase deploy --token $FIREBASE_TOKEN only: - master when: manual Python 项目\rimage: python:3.9 stages: - test - deploy before_script: - pip install -r requirements.txt test: stage: test script: - pytest deploy: stage: deploy script: - pip install awscli - aws s3 sync ./dist s3://my-bucket/ only: - master CI/CD 最佳实践\r保持流水线简单：只包含必要的步骤，避免过度复杂化。 使用缓存：缓存依赖项可以显著提高构建速度。 并行执行：将独立的任务并行执行以节省时间。 环境变量管理：使用 GitLab 的变量功能安全地存储敏感信息。 分支策略：为不同的分支配置不同的 CI/CD 行为。 故障排除\r常见问题\rRunner 无法连接：检查网络设置和 Runner 注册信息。 构建失败：查看日志以确定失败原因，可能是依赖项问题或脚本错误。 权限问题：确保 Runner 有足够的权限执行所需操作。 调试技巧\rjob_name: script: - set -x # 启用调试模式 - env # 打印环境变量 - ls -la # 列出文件 结论\rGitLab CI/CD 是一个强大的工具，可以自动化软件开发的各个阶段。通过正确配置 .gitlab-ci.yml 文件，可以实现代码的自动构建、测试和部署，提高开发效率和代码质量。随着对 CI/CD 实践的深入理解，可以进一步优化流水线，使其更加高效和可靠。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/git/git%E6%93%8D%E4%BD%9C/","title":"git操作","content":"\r回滚到指定提交\rgit reset \u0026ndash;hard c1ac53850b0314a20e97f669bafc8bb67a3a1124 git push 放弃变更强制提交\rgit reset \u0026ndash;hard ; git pull \u0026ndash;force 子模块的使用\r","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/git/git%E6%B7%BB%E5%8A%A0%E5%AD%90%E9%A1%B9%E7%9B%AE/","title":"git添加子项目","content":" 项目中添加子项目 1、git clone 父项目url 2、cd 父项目对应目录下：git submodule add \u0026lt;子项目地址\u0026gt; 3、git commit ;git push 4、此时子项目下的子项目是空的，需要cd到父目录cmd执行： git submodule update \u0026ndash;init \u0026ndash;recursive 或者执行：git submodule init 然后执行cd clone含嵌套项目的项目 git clone 父项目url \u0026ndash;recurse-submodules 不加\u0026ndash;recurse-submodules，克隆的子项目是空的 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80--%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E9%85%8D/","title":"Go语言--安装和环境搭配","content":"\r一.Go简介\rGo 语言（又称 Golang）是由 Google 开发的一种开源编程语言，于 2009 年正式对外发布。下面从多个方面为你介绍它：\n设计目标\rGo 语言的设计初衷是为了解决大规模软件开发中的一些问题，比如编译速度慢、并发编程复杂、代码可维护性差等。所以它结合了静态语言的性能优势和动态语言的开发效率。\n特点\r高效的编译和执行：Go 语言拥有快速的编译速度，这使得开发过程更加流畅。同时，它的执行效率也很高，能充分利用现代多核处理器的性能。 内置并发支持：Go 语言原生支持并发编程，通过goroutine和channel可以很方便地实现高并发程序。goroutine是一种轻量级的线程，占用资源少，创建和销毁的开销小；channel则用于goroutine之间的通信和同步。 垃圾回收机制：它具备自动垃圾回收功能，开发者无需手动管理内存，减少了内存泄漏的风险，提高了开发效率。 丰富的标准库：标准库涵盖了网络编程、文件操作、加密解密等多个领域，为开发者提供了便利，减少了对第三方库的依赖。 跨平台支持：可以在不同的操作系统和硬件平台上编译和运行，方便开发跨平台的应用程序。 应用场景\r云计算与容器编排：像 Docker 和 Kubernetes 这类知名项目，就是用 Go 语言开发的。 网络编程：由于其出色的并发性能和网络库，Go 语言非常适合开发网络服务器、代理服务器等。 分布式系统：在分布式系统中，Go 语言的并发模型和网络编程能力使其能够高效地处理大量的并发请求。 二、Go语言安装与配置\rGo语言支持以下系统：Linux、Mac、Windows。\n安装包下载地址：The Go Programming Language\nwindows\r直接安装系统下载安装即可！\nLinux\r将下载的二进制包解压至/usr/local目录\rtar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz AI写代码 将 /usr/local/go/bin 目录添加至 PATH 环境变量：\r可以编辑 /etc/profile，并将以下命令添加该文件的末尾，这样就可以永久生效：\nexport PATH=$PATH:/usr/local/go/bin AI写代码 然后执行\nsource /etc/profileAI写代码 三.编写基本测试用例\rpackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;)}AI写代码 go build 文件名+ 运行程序=go run文件名AI写代码 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E6%95%99%E7%A8%8B/hugo%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","title":"Hugo静态网站生成器入门指南","content":"\r什么是Hugo？\rHugo是一个用Go语言编写的快速、现代的静态网站生成器。它可以将Markdown文件转换为HTML页面，非常适合构建文档网站、博客等。\nHugo的主要特点\r极快的构建速度 丰富的主题支持 简单的Markdown内容管理 强大的模板系统 内置的短代码功能 安装Hugo\r在Windows上安装Hugo的步骤：\n下载Hugo的Windows版本 解压到指定目录 将Hugo的可执行文件路径添加到系统环境变量 创建新站点\r使用以下命令创建一个新的Hugo站点：\nhugo new site mydocs 下载插件\r添加内容\r在content目录下创建Markdown文件来添加内容：\nhugo new blog/my-first-post.md 运行开发服务器\r使用以下命令启动开发服务器：\nhugo server -D --environment development #如果未设置环境变量则不需要指定环境。 部署网站\r使用以下命令生成静态文件：\nhugo 然后将public目录下的文件部署到Web服务器即可，注意每次推送前运行hugo更新public文件夹 若有更新域名，请删除public后，再运行hugo重新生成public，否则会出现路由错误的情况。 为了方便新建.sh脚本文件，命名为.command.sh # 判断是否已初始化Git仓库 if [ ! -d \u0026#34;.git\u0026#34; ]; then echo \u0026#34;未检测到Git仓库，正在初始化...\u0026#34; git init else echo \u0026#34;Git仓库已初始化\u0026#34; fi # 创建.gitignore文件，排除不需要版本控制的文件 cat \u0026gt; .gitignore \u0026lt;\u0026lt; EOF resources/ .DS_Store node_modules/ .hugo_build.lock EOF # 添加所有文件 git add . # 提交更改 git commit -m \u0026#34;更新博客\u0026#34; # 检查是否已关联远程仓库 REMOTE_URL=$(git remote get-url origin 2\u0026gt;/dev/null) if [ -z \u0026#34;$REMOTE_URL\u0026#34; ]; then echo \u0026#34;未检测到远程仓库，正在添加...\u0026#34; git remote add origin https://github.com/bluespace3/bluespace3.github.io else echo \u0026#34;已关联远程仓库：$REMOTE_URL\u0026#34; fi # 推送到GitHub git push -u origin main --force 终端运行 ..command.sh 更新维护\r后期维护有许多要留意的地方否则容易踩坑。\n新增文章，在项目根目录终端运行，hugo new content/post/文章名称 不同主题博客目录不一致，这里需要留意你下载主题的说明。\n生成的文章会自带字段，其中draft默认true需要维护成false或者删掉，否则视为草稿。如下：\ntitle: \u0026#34;测试平台教程\u0026#34; date: 2025-03-20T12:59:32+08:00 draft: false tags: [\u0026#34;测试平台\u0026#34;, \u0026#34;静态网站\u0026#34;, \u0026#34;教程\u0026#34;] 3.若只有一台电脑更新博客，可以只把public托管到github，若要多个终端更新。需要满足以下条件。\n终端的hugo版本和主题保持需要保持一致，建议把主题配置在hugo.toml文件里面。否则本地有多个主题时在运行时要指定主题。\nhugo -t hugo-theme-reimu\n需要把整个项目推到github，并且指定githubPage为存放public的分支。需要建立工作流，脚本如下。\nname: Deploy Hugo site on: push: branches: - main # 或者你的默认分支名 jobs: deploy: runs-on: ubuntu-latest permissions: contents: write # Ensure GITHUB_TOKEN has write access to contents steps: - uses: actions/checkout@v3 with: submodules: false # 确保自动拉取子模块 fetch-depth: 0 # 获取所有历史记录和标签 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: gh-pages # 部署到gh-pages分支 总结\rHugo是一个功能强大且易于使用的静态网站生成器，非常适合构建个人博客、文档网站等。\n优点是能快速构建，丰富的模板生态，方便的托管到github，后期维护成本低。\n缺点：只支持md格式，不支持在线编辑，因为只支持通过代码push到远程仓库更新，所以在切换终端时简直是噩梦，笔者在此处踩坑无数，特别需要注意这里。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/java-testng/java%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E9%A1%B9%E7%9B%AE/","title":"java快速生成接口自动化测试用例项目","content":"\rjava快速生成接口自动化测试用例项目\r这是一个示例项目，演示如何使用 TestNG 和 REST Assured 进行 API 测试，并支持测试用例与接口逻辑分离的架构。\nHAR文件自动化测试生成\r项目支持将浏览器录制的HAR文件自动转换为完整的自动化测试套件：\n单文件导入: import-har.bat your-file.har 或 import-har.ps1 your-file.har 批量导入: import-har.bat har-files-directory/ 或 import-har.ps1 har-files-directory/ 独立配置: 每个HAR文件生成对应的JSON测试用例文件（如 your-file_test_cases.json） 统一执行: 所有测试用例通过统一的 UnifiedApiTest 类执行 一键运行: 生成的测试可直接运行，无需修改代码 文件结构说明\r导入HAR文件后，项目结构如下：\nsrc/test/resources/testcases/ ├── your-har-file1_test_cases.json # HAR文件1对应的测试用例 ├── your-har-file2_test_cases.json # HAR文件2对应的测试用例 ├── custom_variables_demo.json # 自定义变量示例 ├── db_query_demo.json # 数据库查询示例 └── ... # 其他示例文件 每个HAR文件都会生成一个独立的JSON文件，文件命名规则为：{har文件名}_test_cases.json\n优势\r模块化: 每个HAR文件对应独立的测试用例文件，便于管理和维护 灵活性: 可以单独修改某个HAR文件对应的测试用例，不影响其他测试 可追溯性: 测试用例与原始HAR文件一一对应，便于追踪来源 统一执行: 所有测试用例仍然通过统一入口执行，保持测试管理的一致性 详细功能指南\r测试用例依赖和数据驱动测试指南 - 详细说明如何配置测试用例依赖、参数化测试、数据提取和动态变量 数据库查询功能使用指南 - 详细说明如何集成数据库查询功能 高级功能\r测试用例依赖管理\r支持测试用例之间的依赖关系，确保依赖的测试用例先执行。通过 dependsOn 字段指定依赖的测试用例ID。\n测试分组管理（新增 …","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/java%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E9%A1%B9%E7%9B%AE/","title":"java快速生成接口自动化测试用例项目","content":"\rjava快速生成接口自动化测试用例项目\r这是一个示例项目，演示如何使用 TestNG 和 REST Assured 进行 API 测试，并支持测试用例与接口逻辑分离的架构。\nHAR文件自动化测试生成\r项目支持将浏览器录制的HAR文件自动转换为完整的自动化测试套件：\n单文件导入: import-har.bat your-file.har 或 import-har.ps1 your-file.har 批量导入: import-har.bat har-files-directory/ 或 import-har.ps1 har-files-directory/ 独立配置: 每个HAR文件生成对应的JSON测试用例文件（如 your-file_test_cases.json） 统一执行: 所有测试用例通过统一的 UnifiedApiTest 类执行 一键运行: 生成的测试可直接运行，无需修改代码 文件结构说明\r导入HAR文件后，项目结构如下：\nsrc/test/resources/testcases/ ├── your-har-file1_test_cases.json # HAR文件1对应的测试用例 ├── your-har-file2_test_cases.json # HAR文件2对应的测试用例 ├── custom_variables_demo.json # 自定义变量示例 ├── db_query_demo.json # 数据库查询示例 └── ... # 其他示例文件 每个HAR文件都会生成一个独立的JSON文件，文件命名规则为：{har文件名}_test_cases.json\n优势\r模块化: 每个HAR文件对应独立的测试用例文件，便于管理和维护 灵活性: 可以单独修改某个HAR文件对应的测试用例，不影响其他测试 可追溯性: 测试用例与原始HAR文件一一对应，便于追踪来源 统一执行: 所有测试用例仍然通过统一入口执行，保持测试管理的一致性 详细功能指南\r测试用例依赖和数据驱动测试指南 - 详细说明如何配置测试用例依赖、参数化测试、数据提取和动态变量 数据库查询功能使用指南 - 详细说明如何集成数据库查询功能 高级功能\r测试用例依赖管理\r支持测试用例之间的依赖关系，确保依赖的测试用例先执行。通过 dependsOn 字段指定依赖的测试用例ID。\n测试分组管理（新增 …","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/langchain/","title":"langchain","content":"\r核心组件\r模型包装器\r作用：与大模型交互对话\n内部结构：提示词模板-\u0026gt;语言模型-\u0026gt;输出解析\n数据连接\r作用：数据交互与处理\n链\r作用：将组件组合形成端到端的应用\n记忆\r**作用：**多次运行持久化应用状态\n代理\r作用：拓展模型推理能力，用于复杂的应用调用序列。\n回调\r**作用：**大模型阶段工作后后运行某些操作，如日志记录，监控，等用处不大。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/linux%E5%AE%89%E8%A3%85python/","title":"linux安装python","content":" title: \u0026ldquo;linux安装python\u0026rdquo;\ncategories: [\u0026ldquo;技术\u0026rdquo;, \u0026ldquo;linux\u0026rdquo;, \u0026ldquo;python\u0026rdquo;] date: 2025-03-20T12:59:32+08:00\ndraft: false\ntags: [\u0026ldquo;linux\u0026rdquo;, \u0026ldquo;python\u0026rdquo;, \u0026ldquo;教程\u0026rdquo;]\r#依赖包\nyum -y groupinstall \u0026ldquo;Development tools\u0026rdquo;\nyum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n#下载 Python3\nwget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz\n#创建文件夹\nmkdir /usr/local/python3\n#解压编译安装\ntar -xvJf Python-3.6.2.tar.xz\ncd Python-3.6.2\n./configure \u0026ndash;prefix=/usr/local/python3\nmake \u0026amp;\u0026amp; make install\n#给个软链\nln -sf /usr/local/python3/bin/python3 /usr/bin/python3\nln -sf /usr/local/python3/bin/pip3 /usr/bin/pip3\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"linux常用命令","content":" title: \u0026amp;ldquo;linux常用命令\u0026amp;rdquo; categories: [\u0026amp;ldquo;技术\u0026amp;rdquo;, \u0026amp;ldquo;linux\u0026amp;rdquo;] date: 2025-03-20T12:59:32+08:00\ndraft: false\ntags: [\u0026amp;ldquo;linux常用命令\u0026amp;rdquo;]\r文章目录\r一、目录操作 1、批量操作 二、文件操作 三、文件内容操作（查看日志，更改配置文件） 1、grep(检索文件内容) 2、awk(数据统计) 3、sed(替换文件内容) 4、管道操作符 | 四、系统日志位置 五、创建与删除软连接 六、压缩和解压缩 七、Linux下文件的详细信息 八、常用的docker容器的命令： 九、运维常用命令 1、查看服务器端口号是否可用 十、yum常用命令 十一、其他命令 1、xargs 2、curl语法 十二、Linux内核优化 十三、用户权限操作 1、用户操作 2、添加组 3、sudo用户权限操作 4、更换文件所有者 十四、TOP 1、统计信息区 2、进程信息区 十五、文件安装 1、文件下载(lrzsz) 十六、文章PDF版本 Linux 系统目录\n├── bin -\u0026amp;gt; usr/bin # 用于存放二进制命令 ├── boot # 内核及引导系统程序所在的目录 ├── dev # 所有设备文件的目录（如磁盘、光驱等） ├── etc # 配置文件默认路径、服务启动命令存放目录 ├── home # 用户家目录，root用户为/root ├── lib -\u0026amp;gt; usr/lib # 32位库文件存放目录 ├── lib64 -\u0026amp;gt; usr/lib64 # 64位库文件存放目录 ├── media # 媒体文件存放目录 ├── mnt # 临时挂载设备目录 ├── opt # 自定义软件安装存放目录 ├── proc # 进程及内核信息存放目录 ├── root # Root用户家目录 ├── run # 系统运行时产生临时文件，存放目录 ├── sbin -\u0026amp;gt; usr/sbin # 系统管理命令存放目录 ├── srv # 服务启动之后需要访问的数据目录 ├── sys # 系统使用目录 ├── tmp # 临时文件目录 ├── usr # 系统命令和帮助文件目录 └── var # 存放内容易变的 …","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E6%95%99%E7%A8%8B/mac%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E9%80%9F%E8%AE%B0/","title":"mac电脑使用速记","content":"在Mac终端中，有几种方法可以连续删除命令：\n使用 Ctrl + W ：删除光标前的一个单词 使用 Ctrl + U ：删除光标前的整行内容 使用 Ctrl + K ：删除光标后的整行内容 使用 Option + Delete ：删除光标前的一个单词（与 Ctrl + W 类似） 这些快捷键可以帮助你快速删除命令内容，提高终端操作效率。 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mcp-intro/","title":"mcp-intro","content":"\r什么是MCP？\rMCP（Model Context Protocol）是一种用于扩展和增强开发工具功能的协议。它允许开发者创建和使用MCP服务器，这些服务器可以提供额外的工具和资源，以提高开发效率和灵活性。\nMCP的安装\rMCP的安装通常包括以下步骤：\n安装MCP客户端：根据使用的开发工具，安装相应的MCP客户端插件或扩展。 创建MCP服务器：使用提供的工具或模板创建一个新的MCP服务器项目。 配置MCP服务器：在MCP服务器项目中添加所需的工具和资源，并进行相应的配置。 运行MCP服务器：启动MCP服务器，使其与MCP客户端进行通信。 使用示例\r以下是一个简单的MCP服务器使用示例：\n#!/usr/bin/env node import { Server } from \u0026#39;@modelcontextprotocol/sdk/server/index.js\u0026#39;; import { StdioServerTransport } from \u0026#39;@modelcontextprotocol/sdk/server/stdio.js\u0026#39;; const server = new Server( { name: \u0026#39;example-mcp-server\u0026#39;, version: \u0026#39;0.1.0\u0026#39;, }, { capabilities: { tools: { exampleTool: { description: \u0026#39;这是一个示例工具\u0026#39;, inputSchema: { type: \u0026#39;object\u0026#39;, properties: { message: { type: \u0026#39;string\u0026#39;, description: \u0026#39;要显示的消息\u0026#39;, }, }, required: [\u0026#39;message\u0026#39;], }, }, }, }, } ); server.setRequestHandler(\u0026#39;exampleTool\u0026#39;, async (request) =\u0026gt; { const message = request.params.message; return { content: [ { type: \u0026#39;text\u0026#39;, text: `您输入的消息是：${message}`, }, ], }; }); const transport = new StdioServerTransport(); await server.connect(transport); console.error(\u0026#39;MCP服务器正在运行\u0026#39;); 热门MCP工具推荐\r以下是一些目前热门的MCP工具：\n代码生成工具：根据项目需求自动生成代码模板和结构，提高开发效率。 API文档生成工具：自动从代码中提取API信息并生成详细的文档，方便团队成员查阅。 代码质量检查工具：对代码进行静态分析，检查潜在的错误和问题，提高代码质量。 自动化测试工具：自动生成和执行测试用例，确保代码的正确性和稳定性。 通过使用这些热门MCP工具，开发者可以大大提高开发效率和代码质量，更好地完成项目开发任务。\n总结\rMCP是一种强大的开发工具扩展协议，可以帮助开发者创建和使用各种工具和资源。通过本指南，您已经了解了MCP的基本使用方法，接下来可以探索更多高级功能和热门工具。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E6%95%99%E7%A8%8B/md%E6%A0%BC%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"md格式笔记使用指南","content":"\r一、核心语法精要\r1. 标题与段落\r# 主标题（H1） ## 二级标题（H2） 普通段落直接换行书写，空行分隔段落 2. 列表系统 无序列表项 [x] 已完成任务 [ ] 待办事项 有序列表 第二项 3. 代码展示 ```python def hello_hugo(): print(\u0026#34;Welcome to Hugo Blog!\u0026#34;) 二、Hugo增强特性\n短代码应用 {{\u0026lt; highlight python \u0026ldquo;linenos=table\u0026rdquo; /\u0026gt;}} def hugo_shortcode(): return \u0026ldquo;Hugo特色功能\u0026rdquo; {{\u0026lt;/ /highlight \u0026gt;}} 响应式图片 {{\u0026lt; image src=\u0026quot;/images/md-example.png\u0026quot; alt=\u0026ldquo;Markdown示例\u0026rdquo; caption=\u0026ldquo;图1. 文档结构示意图\u0026rdquo; width=\u0026ldquo;80%\u0026rdquo; }}\n### 1. 基础语法 ```markdown ![替代文字](图片路径) 示例： ![技术架构图](/images/tech-arch.png) 三、可视化元素 流程图示例\ngraph TD\rA[开始] --\u003e B{判断}\rB --\u003e|条件1| C[操作1]\rB --\u003e|条件2| D[操作2]\r数据表格\n功能 语法示例 效果 脚注 内容说明^1 底部注解 定义列表 术语: 解释说明 层级关系 启动本地预览服务命令：\nhugo server -D 访问 http://localhost:1313 查看实时效果。请确保： 文件保存路径为 content/post/Markdown文档编写指南.md 已准备好示例图片 /images/md-example.png Hugo版本 ≥ 0.89.0（支持最新短代码语法） ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/mysql----%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/","title":"MySQL -- 复合查询","content":" 数据库的查询是数据库使用中比较重要的环节，前面的基础查询比较简单，不做介绍，可自行查阅。本文主要介绍复合查询，并结合用例进行讲解。\n本文的用例依据Soctt模式的经典测试表，可以自行下载，也可以自己创建\n链接：点这里跳转\n自行创建步骤如下：\n0、预备工作\r0.1 建表\r-- 创建 dept 表（部门表） CREATE TABLE dept ( deptno INT PRIMARY KEY, -- 部门编号 dname VARCHAR(14), -- 部门名称 loc VARCHAR(13) -- 部门位置 ); -- 创建 emp 表（员工表） CREATE TABLE emp ( empno INT PRIMARY KEY, -- 员工编号 ename VARCHAR(10), -- 员工姓名 job VARCHAR(9), -- 职位 mgr INT, -- 上级经理编号 hiredate DATE, -- 入职日期 sal DECIMAL(7,2), -- 工资 comm DECIMAL(7,2), -- 奖金 deptno INT, -- 部门编号 FOREIGN KEY (deptno) REFERENCES dept(deptno) ); -- 创建 salgrade 表（工资等级表） CREATE TABLE salgrade ( grade INT PRIMARY KEY, -- 工资等级 losal DECIMAL(7,2), -- 最低工资 hisal DECIMAL(7,2) -- 最高工资 ); 1234567891011121314151617181920212223242526AI写代码 0.2 插入测试数据\r-- 插入 dept 表数据 INSERT INTO dept (deptno, dname, loc) VALUES (10, \u0026#39;ACCOUNTING\u0026#39;, \u0026#39;NEW YORK\u0026#39;), (20, \u0026#39;RESEARCH\u0026#39;, \u0026#39;DALLAS\u0026#39;), (30, \u0026#39;SALES\u0026#39;, \u0026#39;CHICAGO\u0026#39;), (40, \u0026#39;OPERATIONS\u0026#39;, \u0026#39;BOSTON\u0026#39;); -- 插入 emp 表数据 INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES (7369, \u0026#39;SMITH\u0026#39;, \u0026#39;CLERK\u0026#39;, 7902, \u0026#39;1980-12-17\u0026#39;, 800.00, NULL, 20), (7499, \u0026#39;ALLEN\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-02-20\u0026#39;, 1600.00, 300.00, 30), (7521, \u0026#39;WARD\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-02-22\u0026#39;, 1250.00, 500.00, 30), (7566, \u0026#39;JONES\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-04-02\u0026#39;, 2975.00, NULL, 20), (7654, \u0026#39;MARTIN\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-09-28\u0026#39;, 1250.00, 1400.00, 30), (7698, \u0026#39;BLAKE\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-05-01\u0026#39;, 2850.00, NULL, 30), (7782, \u0026#39;CLARK\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-06-09\u0026#39;, 2450.00, NULL, 10), (7788, \u0026#39;SCOTT\u0026#39;, \u0026#39;ANALYST\u0026#39;, 7566, \u0026#39;1982-12-09\u0026#39;, 3000.00, NULL, 20), (7839, \u0026#39;KING\u0026#39;, \u0026#39;PRESIDENT\u0026#39;, NULL, \u0026#39;1981-11-17\u0026#39;, 5000.00, NULL, 10), (7844, \u0026#39;TURNER\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-09-08\u0026#39;, 1500.00, 0.00, 30), (7876, \u0026#39;ADAMS\u0026#39;, \u0026#39;CLERK\u0026#39;, 7788, \u0026#39;1983-01-12\u0026#39;, 1100.00, NULL, 20), (7900, \u0026#39;JAMES\u0026#39;, \u0026#39;CLERK\u0026#39;, 7698, \u0026#39;1981-12-03\u0026#39;, 950.00, NULL, 30), (7902, \u0026#39;FORD\u0026#39;, \u0026#39;ANALYST\u0026#39;, 7566, \u0026#39;1981-12-03\u0026#39;, 3000.00, NULL, 20), (7934, \u0026#39;MILLER\u0026#39;, \u0026#39;CLERK\u0026#39;, 7782, \u0026#39;1982-01-23\u0026#39;, 1300.00, NULL, 10); -- 插入 salgrade 表数据 INSERT INTO salgrade (grade, losal, hisal) VALUES (1, 700, 1200), (2, 1201, 1400), (3, 1401, 2000), (4, 2001, 3000), (5, 3001, 9999); 12345678910111213141516171819202122232425262728293031AI写代码 创建好以后，如果表的内容和下图一样，那基本就没问题了\n1、复合表的查询\r1.查询工资高于500 或 岗位为MANAGER 的雇员，同时还要满足他们的姓名首字母为大写的J\n根据上述的要求，我们可以发现，要查询的表总共两个条件，工资高于500 或 岗位为MANAGER， 首字母为J。 根据上述的两个条件，我们可以写出对应的sql查询语句： select name, job , sal from emp where (sal \u0026gt;= 500 or job = 'MANAGER') and enum like 'J%'; 这两个条件可以看成是并列条条件\n2.按照部门号升序而雇员工资降序的顺序对表的内容排序\n先观察一下这里的需求，首先就是要部门号升序，然后就是雇员的工资降序，所以这个案例的需求非常简单。根据这个要求我们可以写出sql查询语句：select deptno , sal from emp order by deptno asc , sal desc;\n3. 使用年薪进行降序排序\n这里我们需要特别注意的一个点就是年薪这个概念，年薪在这里是包括了12个月的月薪加上奖金，而这里奖金就是comm，但是奖金这一列很多都是NULL，而NULL是不参与计算的，所以这里就需要用ifnull(expression ，values)**(如果expression为null，返回的值为values否则返回expression)**利用这个函数的特点，我们就可以算出年薪 = 12 x sal + ifnull(comm,0)； 根据这个要求我们可以写出sql查询语句：select sal * 12 + ifnull(comm,0) 年薪 from emp order by 年薪 desc;\n4.显示工资最高的员工名字和工作岗位\n这条语句的要求非常简单，我们可以直接写出对应sql查询语句： select ename , job from emp where sal = (select max(sal) from emp);这里select是可以嵌套使用的，执行顺序就和C语言的中函数一样。当然，这里我们也可以分两步走，先把最高工资打印出来，再让第二条语句中 sal = 最高工资，结果是一样的。\n5. 显示工资高与平均工资的员工信息\n这个例子的要求和上面一个例子相差无几，做法也都差不多，先求出平均工资，再作比较即可。我们可以直接写出对应sql查询语句：select * from emp where sal \u0026gt;= (select avg(sal) from emp);\n6.显示每个部门的平均工资与最高工资\n这里也是只有两个条件，我们将平均工资和最高工资列出即可。我们可以直接写出对应sql查询语句：select deptno ,avg(sal),max(sal) from emp group by deptno;这里是先分组，然后再对内中内容进行筛查。\n7.显示平均工资低于两千的部门号和它的平均工资\n这个例子就需要和上面的例子一样，先对部门进行分组，分完组后就可以计算平均工资，然后再比对工资低于两千的部门。根据上述的条件，我们可以直接写出对应sql查询语句：select deptno ,avg(sal) 平均工资 from emp group by deptno having 平均工资 \u0026lt; 2000;这里的having是最后执行的，所以可以使用平均工资这个别名。\n8.显示每种岗位的雇员总数，平均工资\n这个例子和上面几个例子大差不差，这里不再赘述，直接把对应的语句写出：select deptno ,count(job) 人数,avg(sal) 平均工资 from emp group by job;\n2、多表复合查询\r前面我们介绍了单张表下的复合查询，但在日常生活中还存在非常的多表查询的情况。\n1、显示每一个雇员名，雇员工资和部门名称\n这个例子中和上面不同就是我们需要去查询部门名称，部门名称是在dept这张表中，而雇员名称以及工资在emp这张表中。这就需要我们将两张表的内容合并成一张表，也就是对第一张表的每一行内容与第二张表整张表进行组合，这种穷举的方式也叫作笛卡尔积。当然这种方式会生成很多没有啥意义的组合(部门号不对应)。这里我们就可以使用where进行筛查，select * from emp, dept where emp.deptno = dept.deptno结果如下图\n![\u0026gt;\n经过上述sql语句的筛查基本已经把要求给完成了，我们这里稍微完善一下即可：select ename,sal,dname from emp, dept where emp.deptno = dept.deptno\n3、自链接\r前面我们了解了不同表之间的进行链接查询，下面介绍一下同一张表之间链接。以下面这个例子为例：**a.显示员工FORD的上级领导的编号和姓名（mgr是员工领导的编号–empno）。**这个例子中，我们需要将在FORD的领导编号查出，然后在从当前这张表中查领导的相关信息。由此我们可以写出对应的sql语句：select empno,ename from emp where emp.empno=(select mgr from emp where ename=‘FORD’); 4、子查询\r**概念：子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询。**前面已有描述，这里就不再赘述\n4.1、单行子查询\r单行子查询表示的就是返回结果只有一行的子查询，以下面这一个通过下面这个例子帮助了解：\n显示SMITH同一部门的员工\n这个案例比较简单，我们只需先对SMITH先做子查询即可：select * from emp where deptno = (select deptno from emp where ename=‘smith’); 4.3、多行子查询\r这种子查询返回结果有很多行，但是原本子查询返回结果只有一行，所以这里我们需要将引入一些关键字，才能使其达到多行子查询的效果。\nin关键字 all关键字 any关键字 首先我们可以通过一个例子了解一下in关键字：a.查询和10号部门的工作岗位相同的雇员的名字，岗位，工资，部门号，但是不包含10自己.\n在这个例子中，我们要先查询10号部门的工作岗位相同的雇员，然后才是其它的相关信息，最后剔除十号部门。\n第一步：select distinct job from emp where deptno=10;\n第二步：select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10);这里的in在where中作为一种条件判断，表示判断job否在子查询中的表中。\n第三步：select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10) and deptno\u0026lt;\u0026gt;10;\n然后，我们通过另外一个例子来增加对all的理解：**显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号.**这里的all关键字其实和上面的in关键字一样，也是where中作为一种条件判断，代表子查询的所有结果。我们可以直接写出对应的sql语句：select ename, sal, deptno from emp where sal \u0026gt; all(select sal from emp where deptno=30); 最后一个any，作用和上面两个关键字大同小异，表示子查询的任意一个结果，用一个例子帮助理解：显示工资比部门30的任意员工的工资高的员工的姓名、工资和部门号（包含自己部门的员工）.，对应的sql语句：select ename, sal, deptno from emp where sal \u0026gt; any(select sal from emp where deptno=30); 4.4、多列子查询\r单行子查询是指子查询只返回单列，单行数据；多行子查询是指返回单列多行数据，都是针对单列而言的，而多列子查询则是指查询返回多个列数据的子查询语句。以下面例子为例：查询和SMITH的部门和岗位完全相同的所有雇员，不含SMITH本人这里第一步就是筛出SMITH部门和岗位相同的雇员，然后剔除SMITH，我们可以用括号的方式来对子查询各列的数据进行查询比对，具体方式如下： select ename from emp where (deptno, job)=(select deptno, job from emp where ename=‘SMITH’) and ename \u0026lt;\u0026gt; ‘SMITH’;\n4.5、from字句中使用子查询\r通过对前面的相关知识的了解，我们可以知道，子查询本质其实就是一张新的临时表，所以本质上我们查表都是在查一张表，就是将临时表和原表进行处理后的一张新表。既然上面 where 后面能够使用子查询，那from后面也必然是可以使用子查询的。from后面使用子查询就是将子查询生成的临时表与另外的表做笛卡尔积生成新的表，在从新的表中对数据进行筛查。下面用一个例子来帮助理解：显示每个高于自己部门平均工资的员工的姓名、部门、工资、平均工资\n对应的sql语句：//获取各个部门的平均工资，将其看作临时表 select ename, deptno, sal, format(asal,2) from emp, (select avg(sal) asal, deptno dt from emp group by deptno) tmp where emp.sal \u0026gt; tmp.asal and emp.deptno=tmp.dt;需要 需要注意的时from中子查询形成的临时表要有临时的名称。\n5、合并查询\r由于这个合并查询并不多见，使用率也较低，所以这里简单介绍即可。\nunion操作符：该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中的重复行。例子：将工资大于2500或职位是MANAGER的人找出来。 sql语句：select ename, sal, job from emp where sal\u0026gt;2500 union select ename, sal, job fromemp where job='MANAGER';\nunion all操作符：该操作符用于取得两个结果集的并集。当使用该操作符时，不会去掉结果集中的重复行。例子：将工资大于25000或职位是MANAGER的人找出来。sql语句：select ename, sal, job from emp where sal\u0026gt;2500 union all select ename, sal, job from emp where job='MANAGER';\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E5%B7%A5%E5%85%B7/pandoc/","title":"Pandoc","content":" Pandoc 简介 Pandoc 是一个由 John MacFarlane 开发的开源“瑞士军刀”，用于在不同标记语言格式之间进行转换。它支持数十种输入和输出格式，包括 DOCX、Markdown、HTML、PDF、EPUB 等。由于其强大的转换引擎和对细节的关注，它在从 DOCX 转换为 Markdown时能很好地保留格式，例如标题、列表、表格、代码块等。\n安装 Pandoc 你可以从 Pandoc 的官方网站下载安装程序，或者使用包管理器进行安装。\nWindows: 从 httpss://github.com/jgm/pandoc/releases/latest 下载最新的 .msi 安装包并运行它。 或者，如果你使用 winget 或 choco： winget install \u0026ndash;id=JohnMacFarlane.Pandoc choco install pandoc macOS: 使用 Homebrew: brew install pandoc Linux (Debian/Ubuntu): sudo apt-get install pandoc 使用示例 安装完成后，你可以在命令行（Powershell、Terminal 等）中使用 pandoc 命令。它的基本用法非常简单：\npandoc [输入文件] -o [输出文件]\n例如，要将一个名为 报告.docx 的文件转换为 报告.md，你只需运行：\npandoc 报告.docx -o 报告.md\nPandoc 会自动根据文件扩展名（.docx 和 .md）判断输入和输出格式。转换后的 Markdown 文件将保存在同一目录下。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/playwright%E7%9A%84python%E6%96%87%E6%A1%A3/","title":"playwright的python文档","content":"\r安装\r引言\rPlaywright 是专门为满足端到端测试的需求而创建的。Playwright 支持包括 Chromium、WebKit 和 Firefox 在内的所有现代渲染引擎。在 Windows、Linux 和 macOS 上进行测试，无论是本地还是在 CI 上，无论是无头模式还是有头模式，都可以使用原生移动设备仿真。\nPlaywright 库可以用作通用的浏览器自动化工具，为同步和异步 Python 提供了一套强大的 API 来自动化 Web 应用程序。\n本介绍描述了 Playwright Pytest 插件，这是编写端到端测试的推荐方式。\n你将学到\n如何安装 Playwright Pytest 如何运行示例测试 安装 Playwright Pytest\rPlaywright 建议使用官方的 Playwright Pytest 插件来编写端到端测试。它提供了上下文隔离，并开箱即用地在多个浏览器配置上运行。\n首先，通过安装 Playwright 并运行示例测试来开始，亲眼看看它是如何工作的。\nPyPI Anaconda 安装所需的浏览器：\n添加示例测试\r在当前工作目录或遵循 test_ 前缀约定的子目录中创建一个文件，例如 test_example.py，并在其中包含以下代码。确保你的测试名称也遵循 test_ 前缀约定。\ntest_example.py\nimport re from playwright.sync_api import Page, expect def test_has_title(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 期望标题“包含”一个子字符串。 expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) def test_get_started_link(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 点击“开始”链接。 page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() # 期望页面有一个名为“安装”的标题。 expect(page.get_by_role(\u0026#34;heading\u0026#34;, name=\u0026#34;Installation\u0026#34;)).to_be_visible() 运行示例测试\r默认情况下，测试将在 Chromium 上运行。这可以通过 CLI 选项进行配置。测试以无头模式运行，这意味着在运行测试时不会打开浏览器 UI。测试结果和测试日志将在终端中显示。\n更新 Playwright\r要将 Playwright 更新到最新版本，请运行以下命令：\npip install pytest-playwright playwright -U 系统要求\rPython 3.8 或更高版本。 Windows 10+、Windows Server 2016+ 或 Windows Subsystem for Linux (WSL)。 MacOS 12 Monterey、MacOS 13 Ventura 或 MacOS 14 Sonoma。 Debian 11、Debian 12、Ubuntu 20.04 或 Ubuntu 22.04。 接下来是什么\r使用 Web 优先断言、页面夹具和定位器编写测试 运行单个测试、多个测试、有头模式 使用 Codegen 生成测试 查看测试的跟踪 编写测试用例\r引言\rPlaywright 测试很简单，它们\n执行操作 ， 断言状态与预期相符。 在执行操作之前没有必要等待任何东西：Playwright 在执行每个操作之前会自动等待一系列可操作性检查通过。\n也没有必要在执行检查时处理竞态条件 - Playwright 断言的设计方式是它们描述了最终需要满足的预期。\n就是这样！这些设计选择允许 Playwright 用户完全忘记他们测试中的不稳定超时和竞态检查。\n你将学到\n如何编写第一个测试 如何执行操作 如何使用断言 测试如何独立运行 如何使用测试钩子 第一个测试\r查看以下示例，了解如何编写测试。注意文件名遵循 test_ 前缀约定，以及每个测试名称。\ntest_example.py\nimport re from playwright.sync_api import Page, expect def test_has_title(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 期望标题“包含”一个子字符串。 expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) def test_get_started_link(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 点击“开始”链接。 page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() # 期望页面有一个名为“安装”的标题。 expect(page.get_by_role(\u0026#34;heading\u0026#34;, name=\u0026#34;Installation\u0026#34;)).to_be_visible() 操作\r导航\r大多数测试将从导航到 URL 的页面开始。之后，测试将能够与页面元素进行交互。\npage.goto(\u0026#34;https://playwright.dev/\u0026#34;) Playwright 会等待页面达到加载状态，然后再继续。了解更多关于 page.goto() 选项的信息。\n交互\r执行操作从定位元素开始。Playwright 使用 Locators API 进行此操作。定位器代表了在任何时刻在页面上查找元素（或元素组）的方式，了解更多关于可用的不同类型定位器的信息。Playwright 会在执行操作之前等待元素可操作，因此没有必要等待其变为可用。\n# 创建一个定位器。 get_started = page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;) # 点击它。 get_started.click() 在大多数情况下，它会写成一行：\npage.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() 基本操作\r这是最受欢迎的 Playwright 操作列表。请注意，还有更多操作，请确保查看定位器 API 部分以了解更多信息。\n操作 描述 locator.check() 检查输入复选框 locator.click() 点击元素 locator.uncheck() 取消检查输入复选框 locator.hover() 鼠标悬停在元素上 locator.fill() 填写表单字段，输入文本 locator.focus() 使元素获得焦点 locator.press() 按下单个键 locator.set_input_files() 选择上传的文件 locator.select_option() 在下拉菜单中选择选项 断言\rPlaywright 包括断言，这些断言会等待直到满足预期条件。使用这些断言可以使测试不脆弱且具有弹性。例如，这段代码会等待页面获得包含“Playwright”的标题：\nimport re from playwright.sync_api import expect expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) 这是最受欢迎的异步断言列表。请注意，还有更多断言需要熟悉：\n断言 描述 expect(locator).to_be_checked() 复选框被选中 expect(locator).to_be_enabled() 控件被启用 expect(locator).to_be_visible() 元素可见 expect(locator).to_contain_text() 元素包含文本 expect(locator).to_have_attribute() 元素具有属性 expect(locator).to_have_count() 元素列表具有给定长度 expect(locator).to_have_text() 元素匹配文本`` expect(locator).to_have_value() 输入元素具有值`` expect(page).to_have_title() 页面具有标题`` expect(page).to_have_url() 页面具有 URL 测试隔离\rPlaywright Pytest 插件基于测试夹具的概念，例如内置的页面夹具，它被传递到你的测试中。由于浏览器上下文，页面在测试之间是隔离的，这相当于一个全新的浏览器配置文件，每个测试都获得一个新鲜环境，即使多个测试在单个浏览器中运行。\ntest_example.py\nfrom playwright.sync_api import Page def test_example_test(page: Page): pass # “page”属于一个独立的 BrowserContext，为这个特定测试创建。 def test_another_test(page: Page): pass # 这个第二个测试中的“page”与第一个测试完全隔离。 使用夹具\r你可以使用各种夹具在测试之前或之后执行代码并共享对象。一个 function 作用域的夹具，例如带有 autouse 的，表现得像 beforeEach/afterEach。一个 module 作用域的夹具带有 autouse 表现得像 beforeAll/afterAll，它在所有测试之前和之后运行。\ntest_example.py\nimport pytest from playwright.sync_api import Page, expect @pytest.fixture(scope=\u0026#34;function\u0026#34;, autouse=True) def before_each_after_each(page: Page): print(\u0026#34;before the test runs\u0026#34;) # 在每个测试之前转到起始 URL。 page.goto(\u0026#34;https://playwright.dev/\u0026#34;) yield print(\u0026#34;after the test runs\u0026#34;) def test_main_navigation(page: Page): # 断言使用 expect API。 expect(page).to_have_url(\u0026#34;https://playwright.dev/\u0026#34;) 接下来是什么\r运行单个测试，多个测试，有头模式 使用 Codegen 生成测试 查看测试的跟踪 在 CI 上运行测试与 GitHub Actions 生成测试\r引言\rPlaywright 提供了开箱即用的测试生成能力，是快速开始测试的绝佳方式。它将打开两个窗口，一个浏览器窗口，您可以在其中与您想要测试的网站进行交互；另一个是 Playwright 检查器窗口，您可以在其中录制测试、复制测试、清除测试以及更改测试的语言。\n您将学到\n如何录制测试 如何生成定位器 运行 Codegen\r使用 codegen 命令运行测试生成器，然后是您想要为其生成测试的网站的 URL。URL 是可选的，您也可以在不指定 URL 的情况下运行命令，然后在浏览器窗口中直接添加 URL。\nplaywright codegen demo.playwright.dev/todomvc 录制测试\r运行 codegen 并在浏览器中执行操作。Playwright 将为用户交互生成代码。Codegen 将查看渲染后的页面并找出推荐的定位器，优先考虑角色、文本和测试 ID 定位器。如果生成器识别出多个元素与定位器匹配，它将改进定位器，使其更具弹性并唯一地识别目标元素，从而消除和减少由于定位器导致的测试失败和不稳定。\n使用测试生成器，您可以录制：\n通过简单地与页面交互，执行点击或填充等操作 通过点击工具栏上的一个图标，然后点击页面上的元素进行断言。您可以选择： 'assert visibility' 断言元素可见 'assert text' 断言元素包含特定文本 'assert value' 断言元素具有特定值 当您完成与页面的交互后，按下 'record' 按钮停止录制，并使用 'copy' 按钮将生成的代码复制到您的编辑器中。\n使用 'clear' 按钮清除代码以开始重新录制。完成后，关闭 Playwright 检查器窗口或停止终端命令。\n要了解更多关于生成测试的信息，请查看我们关于 Codegen 的详细指南。\n生成定位器\r您可以使用测试生成器生成定位器。\n按下 'Record' 按钮停止录制，\u0026lsquo;Pick Locator\u0026rsquo;` 按钮将会出现。 点击 'Pick Locator' 按钮，然后将鼠标悬停在浏览器窗口的元素上，以查看定位器在每个元素下方突出显示。 要选择一个定位器，单击您想要定位的元素，该定位器的代码将出现在 Pick Locator 按钮旁边的定位器游乐场中。 然后您可以在定位器游乐场中编辑定位器以微调它，并看到匹配的元素在浏览器窗口中突出显示。 使用复制按钮复制定位器并将其粘贴到您的代码中。 仿真\r您还可以使用仿真生成测试，以便为特定的视口、设备、颜色方案生成测试，以及模拟地理位置、语言或时区。测试生成器还可以在保持认证状态的同时生成测试。查看测试生成器指南以了解更多信息。\n接下来做什么\r查看您的测试跟踪 运行和调试\r引言\r您可以运行单个测试、一组测试或所有测试。使用 --browser 标志，可以在一个浏览器或多个浏览器上运行测试。默认情况下，测试以无头模式运行，这意味着在运行测试时不会打开浏览器窗口，结果将在终端中显示。如果您愿意，可以通过使用 --headed CLI 参数以有头模式运行您的测试。\n您将学到\n如何从命令行运行测试 如何调试测试 运行测试\r命令行\r要运行您的测试，请使用 pytest 命令。这将默认在 Chromium 浏览器上运行您的测试。默认情况下，测试以无头模式运行，这意味着在运行测试时不会打开浏览器窗口，结果将在终端中显示。\n在有头模式下运行测试\r要以有头模式运行您的测试，请使用 --headed 标志。这将在运行测试时打开浏览器窗口，并在完成后关闭浏览器窗口。\n在不同的浏览器上运行测试\r要指定您想要运行测试的浏览器，请使用 --browser 标志，后跟浏览器的名称。\n要指定要在多个浏览器上运行测试，请多次使用 --browser 标志，后跟每个浏览器的名称。\npytest --browser webkit --browser firefox 运行特定测试\r要运行单个测试文件，请传入您想要运行的测试文件的名称。\n要运行一组测试文件，请传入您想要运行的测试文件的名称。\npytest tests/test_todo_page.py tests/test_landing_page.py 要运行特定测试，请传入您想要运行的测试的函数名称。\npytest -k test_add_a_todo_item 并行运行测试\r要并行运行您的测试，请使用 --numprocesses 标志，后跟您想要运行测试的进程数量。我们建议使用逻辑 CPU 核心数的一半。\n（这假设已安装了 pytest-xdist。有关更多信息，请参见此处。）\n有关更多信息，请参见 Playwright Pytest 使用情况或 Pytest 文档以了解一般 CLI 使用情况。\n调试测试\r由于 Playwright 在 Python 中运行，您可以使用您选择的调试器进行调试，例如使用 Visual Studio Code 中的 Python 扩展。Playwright 带有 Playwright 检查器，允许您逐步执行 Playwright API 调用，查看它们的调试日志并探索定位器。\n要调试所有测试，请运行以下命令。\nBash PowerShell Batch 要调试一个测试文件，请在命令后运行您想要调试的测试文件的名称。\nBash PowerShell Batch PWDEBUG=1 pytest -s test_example.py 要调试特定测试，请添加 -k 后跟您想要调试的测试的名称。\nBash PowerShell Batch PWDEBUG=1 pytest -s -k test_get_started_link 此命令将打开浏览器窗口以及 Playwright 检查器。您可以使用检查器顶部的步过按钮逐步执行您的测试。或者按下播放按钮从开始到结束运行您的测试。一旦测试完成，浏览器窗口将关闭。\n在调试时，您可以使用选择定位器按钮来选择页面上的元素，并查看 Playwright 用于查找该元素的定位器。您还可以编辑定位器并实时在浏览器窗口中看到它被高亮显示。使用复制定位器按钮将定位器复制到剪贴板，然后将其粘贴到您的测试中。\n查看我们的调试指南，以了解更多关于 Playwright 检查器以及使用浏览器开发工具进行调试的信息。\n接下来做什么\r使用 Codegen 生成测试 查看您的测试跟踪 在 CI 上使用 GitHub Actions 运行您的测试 跟踪查看器\r介绍\rPlaywright Trace Viewer 是一个图形用户界面（GUI）工具，允许您探索录制的 Playwright 测试跟踪，这意味着您可以前后浏览测试的每个动作，并直观地看到每个动作期间发生了什么。\n您将学到\n如何录制跟踪 如何打开 HTML 报告 如何打开跟踪查看器 录制跟踪\r可以通过使用 --tracing 标志运行测试来录制跟踪。\n跟踪的选项有：\non: 为每个测试录制跟踪 off: 不录制跟踪。（默认） retain-on-failure: 为每个测试录制跟踪，但删除成功测试运行的所有跟踪。 这将录制跟踪并将其放入 test-results 目录中名为 trace.zip 的文件中。\n如果您没有使用 Pytest，请点击这里了解如何录制跟踪。\n同步 异步 browser = chromium.launch() context = browser.new_context() # 在创建/导航页面之前开始跟踪。 context.tracing.start(screenshots=True, snapshots=True, sources=True) page = context.new_page() page.goto(\u0026#34;https://playwright.dev\u0026#34;) # 停止跟踪并将其导出到 zip 归档中。 context.tracing.stop(path=\u0026#34;trace.zip\u0026#34;) 打开跟踪\r您可以使用 Playwright CLI 或在 trace.playwright.dev 上的浏览器中打开保存的跟踪。确保添加您的 trace.zip 文件所在的完整路径。这应该包括 test-results 目录，然后是测试名称，最后是 trace.zip。\nplaywright show-trace trace.zip 查看跟踪\r通过点击每个动作或使用时间线悬停来查看测试的跟踪，并查看动作前后页面的状态。在测试的每个步骤期间检查日志、源代码和网络。跟踪查看器创建了一个 DOM 快照，因此您可以完全与之交互，打开开发工具等。\n要了解更多信息，请查看我们关于跟踪查看器的详细指南。\n接下来是什么\r在 GitHub Actions 上运行 CI 测试 了解更多关于跟踪查看器的信息 Pytest 插件来编写端到端测试\r引言\rPlaywright 提供了一个 Pytest 插件来编写端到端测试。要开始使用它，请参考入门指南。\n使用方法\r要运行测试，请使用 Pytest 命令行界面。\npytest --browser webkit --headed 如果你想自动添加命令行参数而不需要明确指定它们，你可以使用 pytest.ini 文件：\n# pytest.ini 文件的内容 [pytest] # 使用 UI 运行 firefox addopts = --headed --browser firefox 命令行参数\r请注意，命令行参数仅应用于默认的 browser、context 和 page 固定装置。如果你使用 API 调用如 browser.new_context() 创建浏览器、上下文或页面，命令行参数将不会应用。\n--headed：以有头模式运行测试（默认：无头）。 --browser：在不同的浏览器中运行测试 chromium、firefox 或 webkit。可以多次指定（默认：chromium）。 --browser-channel：要使用的浏览器渠道。 --slowmo：通过指定的毫秒数减慢 Playwright 操作。这样你可以看清楚发生了什么（默认：0）。 --device：要模拟的设备。 --output：由测试产生的工件目录（默认：test-results）。 --tracing：是否为每个测试记录跟踪。on、off 或 retain-on-failure（默认：off）。 --video：是否为每个测试录制视频。on、off 或 retain-on-failure（默认：off）。 --screenshot：是否在每个测试后自动捕获屏幕截图。on、off 或 only-on-failure（默认：off）。 --full-page-screenshot：在失败时是否拍摄整个页面的屏幕截图。默认情况下，只捕获视口。需要启用 --screenshot（默认：off）。 固定装置\r这个插件为 pytest 配置了 Playwright 特定的固定装置。要使用这些固定装置，将固定装置名称作为参数传递给测试函数。\ndef test_my_app_is_working(fixture_name): pass # 使用 fixture_name 进行测试 # ... 函数范围 ：当在测试函数中请求时，这些固定装置被创建，并在测试结束时销毁。\ncontext：测试的新浏览器上下文。 page：测试的新浏览器页面。 new_context：允许为测试创建不同的浏览器上下文。适用于多用户场景。接受与 browser.new_context() 相同的参数。 会话范围 ：当在测试函数中请求时，这些固定装置被创建，并在所有测试结束时销毁。\nplaywright：Playwright 实例。 browser_type：当前浏览器的 BrowserType 实例。 browser：由 Playwright 启动的浏览器实例。 browser_name：浏览器名称字符串。 browser_channel：浏览器渠道字符串。 is_chromium、is_webkit、is_firefox：相应浏览器类型的布尔值。 自定义固定装置选项 ：对于 browser 和 context 固定装置，使用以下固定装置定义自定义启动选项。\nbrowser_type_launch_args：覆盖 browser_type.launch() 的启动参数。它应该返回一个字典。 browser_context_args：覆盖 browser.new_context() 的选项。它应该返回一个字典。 也可以通过使用 browser_context_args 标记来覆盖单个测试的上下文选项（browser.new_context()）：\nimport pytest @pytest.mark.browser_context_args(timezone_id=\u0026#34;Europe/Berlin\u0026#34;, locale=\u0026#34;en-GB\u0026#34;) def test_browser_context_args(page): assert page.evaluate(\u0026#34;window.navigator.userAgent\u0026#34;) == \u0026#34;Europe/Berlin\u0026#34; assert page.evaluate(\u0026#34;window.navigator.languages\u0026#34;) == [\u0026#34;de-DE\u0026#34;] 并行性：同时运行多个测试\r如果你的测试在拥有大量 CPU 的机器上运行，你可以通过使用 pytest-xdist 同时运行多个测试来加快测试套件的整体执行时间：\n# 安装依赖 pip install pytest-xdist # 使用 --numprocesses 标志 pytest --numprocesses auto 根据硬件和测试的性质，你可以将 numprocesses 设置为从 2 到机器上的 CPU 数量。如果设置得太高，你可能会注意到意外的行为。\n有关 pytest 选项的一般信息，请参见运行测试。\n示例\r为自动补全配置 Mypy 类型\rtest_my_application.py\nfrom playwright.sync_api import Page def test_visit_admin_dashboard(page: Page): page.goto(\u0026#34;/admin\u0026#34;) # ... 配置慢动作\r使用 --slowmo 参数运行测试。\n将 Playwright 操作减慢 100 毫秒。\n按浏览器跳过测试\rtest_my_application.py\nimport pytest @pytest.mark.skip_browser(\u0026#34;firefox\u0026#34;) def test_visit_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) # ... 在特定浏览器上运行\rconftest.py\nimport pytest @pytest.mark.only_browser(\u0026#34;chromium\u0026#34;) def test_visit_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) # ... 使用自定义浏览器渠道，如 Google Chrome 或 Microsoft Edge\rpytest --browser-channel chrome test_my_application.py\ndef test_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) 配置基础 URL\r使用 base-url 参数启动 Pytest。pytest-base-url 插件用于此目的，它允许你从配置、命令行参数或固定装置中设置基础 URL。\npytest --base-url http://localhost:8080 test_my_application.py\ndef test_visit_example(page): page.goto(\u0026#34;/admin\u0026#34;) # -\u0026gt; 将导致 http://localhost:8080/admin 忽略 HTTPS 错误\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args): return { **browser_context_args, \u0026#34;ignore_https_errors\u0026#34;: True } 使用自定义视口大小\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args): return { **browser_context_args, \u0026#34;viewport\u0026#34;: { \u0026#34;width\u0026#34;: 1920, \u0026#34;height\u0026#34;: 1080, } } 设备模拟\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args, playwright): iphone_11 = playwright.devices[\u0026#39;iPhone 11 Pro\u0026#39;] return { **browser_context_args, **iphone_11, } 或通过命令行 --device=\u0026quot;iPhone 11 Pro\u0026quot;。\n与 unittest.TestCase 一起使用\r查看以下示例，了解如何将其与 unittest.TestCase 一起使用。这有一个限制，即只能指定单个浏览器，并且在指定多个浏览器时不会生成多个浏览器的矩阵。\nimport pytest import unittest from playwright.sync_api import Page class MyTest(unittest.TestCase): @pytest.fixture(autouse=True) def setup(self, page: Page): self.page = page def test_foobar(self): self.page.goto(\u0026#34;https://microsoft.com\u0026#34;) self.page.locator(\u0026#34;#foobar\u0026#34;).click() assert self.page.evaluate(\u0026#34;1 + 1\u0026#34;) == 2 调试\r与 pdb 一起使用\r在你的测试代码中使用 breakpoint() 语句来暂停执行并获得 pdb REPL。\ndef test_bing_is_working(page): page.goto(\u0026#34;https://bing.com\u0026#34;) breakpoint() # ... 部署到 CI\r请参阅 CI 提供商的指南，了解如何将你的测试部署到 CI/CD。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/pytest-intro/","title":"pytest-intro","content":"\r什么是pytest？\rpytest是一个功能强大且易于使用的Python测试框架。它可以帮助开发者编写简洁、可读性强的测试代码，并提供丰富的插件支持。\npytest的主要特点\r简洁的测试用例编写方式 自动发现测试用例 支持参数化测试 强大的断言功能 丰富的插件生态系统 安装pytest\r使用以下命令安装pytest：\npip install pytest 编写测试用例\r一个简单的pytest测试用例如下：\ndef test_addition(): assert 1 + 1 == 2 def test_subtraction(): assert 2 - 1 == 1 运行测试\r使用以下命令运行pytest测试：\npytest 参数化测试\rpytest支持参数化测试，可以使用@pytest.mark.parametrize装饰器：\nimport pytest @pytest.mark.parametrize(\u0026#34;test_input,expected\u0026#34;, [ (\u0026#34;3+5\u0026#34;, 8), (\u0026#34;2+4\u0026#34;, 6), (\u0026#34;6*9\u0026#34;, 42), ]) def test_eval(test_input, expected): assert eval(test_input) == expected 总结\rpytest是一个功能强大且易于使用的Python测试框架，可以帮助开发者编写简洁、可读性强的测试代码。通过本指南，您已经了解了pytest的基本使用方法，接下来可以探索更多高级功能。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/pytest%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88/","title":"pytest接口自动化测试方案","content":"\r背景\r当前业务核心聚焦于 POCT 领域，设备购买和设备使用等关键功能，已成为测试工作的重点保障对象，但随着系统复杂度的提升,手工的回归测试工作很难全面覆盖。为了确保关键业务功能的质量稳定性，有必要引入自动化测试，增加测试覆盖范围，降低已有功能漏测的风险，提前发现问题。\n目标\r短期目标：接入自动化测试（截至3月底）\n前期准备工作 预研不同的自动化测试框架，结合中长期目标与现实情况及各个框架的优缺点选择一套合适的自动化框架 对比几款常见接口测试框架 初步选定：pytest + Requests 语法简洁容易上手-接入成本低 灵活，社区支持好，插件丰富-适合复杂测试场景 制定初步的方案 自动化项目方案 项目框架搭建 确定实施方案 测试人员小范围接入自动化项目（跑通流程） 三月底能够将三款新设备正向检测流程转化为自动化测试脚本 **将慢病设备下单-上传检测结果流程；快速检测单流程接入接口自动化测试（正向检测流程） **将免疫、血球设备下单-上传检测结果（正向检测流程） 中期目标 ：自动化项目应用到测试工作流程（截至6月底）\n覆盖三款新设备装机到检测使用的全部场景\n覆盖设备装机到检测过程中的各项操作步骤和关键节点，从设备初始化到实际检测，确保各环节功能正常，数据交互准确，为用户提供稳定可靠的设备使用体验（包括异常流程）。 将自动化流程应用到测试工作流程。\n能有效增加测试覆盖率，减少漏测风险。 脚本的维护流程\n在接口变更，需求功能更改后如何维护 运行失败用例如何维护 长期目标：不断完善接口自动化，有效应用到研发测试工作流程（截至12月底）\n完善涉及用户相关的功能的自动化测试覆盖 对从商城购买到设备装机、检测、报告生成打印及检测后的慢病管理，全流程自动化测试，保障用户使用系统过程中的顺畅性，避免因流程问题导致的交易失败或用户体验不佳情况。 将自动化测试无缝应用到现有的研发测试工作流程中。 替代大部分回归测试，提高测试效率，进一步减少漏测风险。 自动化测试成为常态化测试手段,能提前发现问题,有效提升整体工作效率。 自动化测试工具选型\r自动化测试框架-pytest + Requests 几款常见接口测试框架对比详情：\npytest + Requests\n语法简洁容易上手-接入成本低 灵活，社区支持好，插件丰富-适合复杂测试场景 已有相关基础 选型依据 兼容性、适合复杂流程交互（设备交互）、丰富的社区支持、接入成本\n测试管理工具（飞书或tapd） 自动化用例管理接口自动化测试用例 CI/CD工具 GitLab CI uvicorn+fastapi 部署+接口 自动化测试用例设计\r用例分层设计 基础类（/api） 根据接口文档生成 测试用例（/tests） 基础功能用例（原子级-单个接口测试） 定义 ：针对单个接口的独立测试，关注接口的输入输出正确性、异常处理能力及边界条件验证。例如，用户登录接口的独立测试需覆盖正常登录、密码错误、账号不存在等场景 特点 ： 原子性 ：每个用例仅验证一个接口的单一功能，不依赖其他接口或业务流程。 高复用性 ：可作为其他复杂用例的构建单元，例如登录接口的测试结果可被后续业务流程用例复用 技术实现 ：通常结合数据驱动设计（如参数化测试数据），通过多组输入数据覆盖等价类和边界值 业务流程用例（端到端、涉及多个接口和流程的测试） 定义 ：模拟真实用户操作路径，串联多个接口验证端到端业务逻辑。例如“创建商品→创建优惠券→创建活动→下单支付”的全流程测试 特点 ： 场景化 ：基于用户使用的功能场景设计，关注接口间的数据传递与状态流转。 风险覆盖 ：重点验证流程中的关键节点（如订单状态变更、库存扣减）和异常分支（如支付超时回滚） 依赖管理 ：通过关键字驱动设计（如“获取Token”“查询订单状态”）复用基础功能用例，降低冗余代码 测试数据（/data） 存放测试数据 提供测试数据的脚本 工具(/utils) 工具类集合 数据驱动设计 参数化测试数据（Excel、csv、数据库）\n关键字驱动设计 可复用的关键字库（如获取token、查询）\n测试执行策略\r触发条件 开发人员提交代码触发\n手动触发\n优先级划分(暂不考虑) 高（核心功能）、中（高频场景）\n失败重试机制 自动重试与日志记录\n** 持续集成（CI/CD）**\r集成流程 代码提交 → 静态检查 → 单元测试 → 自动化测试 → 报告生成 流水线配置 GitLab CI YAML配置 结果通知 企业微信群通知 风险管理\r潜在风险 环境不稳定 脚本维护成本 需求功能变更 应对措施 设计时需要提前考虑脚本稳定性 定期维护脚本 运行前保证环境正常可用 相关交付物\r测试报告 HTML报告 自动化脚本 代码仓库https://gitlab.guangpuyun.cn/clinic-diag/test/poct_api_test\n项目结构\n文档 初始化文档快速编写Pytest接口测试 自动化用例设计文档接口自动化测试用例 维护与优化\r脚本维护人员 一般情况下谁写的谁维护 脚本维护方法 接口变更的处理 用例执行/定时/手动触发脚本爬取接口文档，并与最新接口文档对比\n运行main.py 执行用例时，会在warnning日志提醒相关变更 检查变更是否涉及已经编写的用例（快捷键ctrl+shift+f搜索关键词即可） 如：PoctCreateOrderInModel存在差异，对应json文档中找到对应 operationId（文件名），在用例文档中搜索createOrder2UsingPOST_1 ，发现涉及已有用例。\n若有涉及用例，则维护成最新接口信息。\n当用例运行报错/不通过进行定位 bug-\u0026gt;记录并通知开发修复； 数据问题-\u0026gt;使用自动化专用的数据，避免污染； 脚本本身不稳定导致的运行失败，维护脚本能稳定运行，若维护成功过高可直接先注释脚本，并在对应用例做好备注“待维护”。 脚本维护代办事项 接口自动化代办事项 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E9%9D%9E%E5%90%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E8%B0%83%E7%94%A8%E6%8A%A5%E9%94%99/","title":"python非同级目录调用报错","content":"\r项目结构：\r问题：\r执行文件调用dir1，间接调用dir2。执行时报错：“ModuleNotFoundError: No module named \u0026lsquo;dir1.dir2\u0026rsquo;;”\n解决方法：\rdir1文件导包时做处理。\n主函数加入这四行，将项目的根目录(webapp)的路径加入到系统PATH中； import os,sys\nfrom pathlib import Path\nsys.path[0] = str(Path(sys.path[0]).parent.parent)\nsys.path.append(os.getcwd())\n且导包从项目执行入口文件同级开始写\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E4%B8%AD%E7%9A%84os%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/","title":"python中的os函数用法","content":" title: \u0026ldquo;python的os模块使用\u0026rdquo;\ncategories: [\u0026ldquo;技术\u0026rdquo;, \u0026ldquo;编程\u0026rdquo;, \u0026ldquo;python\u0026rdquo;] date: 2025-03-20T12:59:32+08:00\ndraft: false\ntags: [\u0026ldquo;os\u0026rdquo;, \u0026ldquo;python\u0026rdquo;, \u0026ldquo;教程\u0026rdquo;]\ros.listdir(path) 获取文件夹下全部文件，的列表 os.path.join(path1,path2) 将路径path1和路径path2拼接成新的路径，path1//path2 base_dir = os.path.dirname(os.path.abspath(file)) 获取当前文件的绝对路径 input_file = os.path.join(base_dir, \u0026quot;../resource/swaggerApi/clinic-ysb-app_OpenAPI.json\u0026quot;) ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rag/","title":"RAG","content":"RAG定义：模型的外挂知识库，解决专业领域的知识检索；可以将用户的问题与知识库检索内容结合成提示词，发给大模型给出结果。简写：检索、增强、生成\nRAG的步骤：\n文档分块\n文档向量化-》（由嵌入模型转成稠密向量-适合语义搜索）文本块向量\n存储\n检索\n增强生成\n混合检索\n1.使用关键子检索，打分，归一化\n2.使用向量检索，打分，归一化\n3.通过排序取分数最高的前n个\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/scrapy%E7%88%AC%E6%9F%9A%E5%AD%90%E7%BD%91%E7%A4%BA%E4%BE%8B/","title":"scrapy爬柚子网示例","content":"柚子网https://www.uu-zz.com/\n爬取页码\n遍历页面内对应的视频集的链接\n遍历视频内子视频链接\n!\nhttps://www.uu-zz.com/+子视频链接，发送get请求\n!\n获得m3u8文件，储存在数据库\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/quant_trading/strategy/","title":"strategy","content":"\r量化交易策略知识库\r核心策略\r本系统采用多因子综合评分策略，结合技术面、基本面和消息面分析。\n技术面分析指标\rMACD指标：判断趋势转折点 RSI指标：判断超买超卖状态 KDJ指标：判断股价趋势 布林带：判断价格波动区间 成交量分析：确认价格变动的有效性 基本面分析要素\r财务指标分析：盈利能力、偿债能力、运营能力 行业地位评估：市场份额、竞争优势 盈利能力评估：营收增长、利润增长 消息面分析方法\r新闻情感分析：判断市场情绪 政策影响评估：分析政策对行业的影响 市场情绪监控：跟踪市场热点和资金流向 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/quant_trading/system_design/","title":"SYSTEM_DESIGN","content":"\r系统设计与开发者文档\r本文档为量化交易系统的核心开发者提供全面的技术参考，涵盖了系统架构、核心模块、API接口、部署运维以及未来的发展规划。\n1. 系统架构\r本系统采用模块化设计，主要由数据层、分析层、策略层和应用层组成。\n1.1. 核心模块\rmain.py: 自选股分析流程的入口。 recommendation_system.py: AI智能推荐流程的入口。 health_check.py: Flask应用的入口，提供 /health 和 /run API端点。 src/: 包含所有核心逻辑的目录。 config.py: 集中管理所有配置。 data_loader.py (DataLoader): 负责从akshare获取数据并存入数据库。 db.py (DatabaseManager): 管理SQLite数据库。 analysis_engine.py (AnalysisEngine): 负责计算技术指标。 gemini_analyzer.py (GeminiAnalyzer): 与Gemini API交互，进行AI分析。 strategy_engine.py (StrategyEngine): 核心策略模块，汇总分析并生成信号。 market_regime.py (MarketRegime): 判断市场宏观状态（牛/熊/震荡）。 logger.py: 提供统一的日志服务。 send_email.py: 生成HTML邮件报告并发送。 1.2. 数据流\r数据获取: DataLoader 从 akshare 获取数据。 数据存储: DatabaseManager 将数据存入SQLite数据库 (data/stock_data.db)。 市场状态判断: MarketRegime 分析市场指数，确定宏观环境。 技术分析: AnalysisEngine 基于历史数据计算技术指标。 AI分析: GeminiAnalyzer 调用Gemini API获取基本面和消息面分析。 策略决策: StrategyEngine 结合所有分析结果，并根据市场状态动态调整权重，生成最终决策。 结果输出: 通过日志、邮件 (send_email.py) 和API (health_check.py) 输出。 2. 策略、评分与决策体系 (V3)\r本量化交易系统的核心决策逻辑，通过对技术面、基本面和AI市场情绪面三个维度进行独立的量化评分，并结合市场状态动态加权，最终生成交易信号。\n2.0. A股总分计算逻辑\r对于A股，系统采用动态加权模型计算总分，取代了旧版的简单分数相加。\n分数归一化: 将技术面（满分50）、基本面（满分35）、情绪面（满分25）的原始得分，分别归一化到 [-1, 1] 的区间内。 应用动态权重: 根据当前市场状态（波动率、成交量）计算出动态权重（例如，趋势行情下技术面权重更高），然后对归一化后的分数进行加权求和。 映射回百分制: 将加权后的分数重新映射回 [-100, 100] 的范围，作为最终总分。 动态权重调整\r系统会根据市场的微观状态（通过ATR判断的波动率和通过均量线判断的成交量）对基础权重进行动态微调：\n高波动 \u0026amp; 放量 (趋势行情): 提升技术面权重，降低基本面和情绪面权重。 低波动 \u0026amp; 缩量 (盘整行情): 降低技术面权重，提升基本面权重。 最终决策阈值\r坚定买入: 总分 \u0026gt;= 40 推荐买入: 总分 \u0026gt;= 30 维持仓位: 总分 \u0026gt;= 20 谨慎持有: 总分 \u0026gt; -5 推荐卖出: 总分 \u0026gt; -20 坚定卖出: 总分 \u0026lt;= -20 2.1. ETF评分体系（指数基金/ETF专用）\r技术面：50分（均线、成交量、波动率等为主，弱化KDJ等短线指标） AI消息面：50分（重点关注资金流向、申购赎回、行业轮动、指数调整等） 基本面：恒为0分（ETF不参与基本面打分） 总分 = 技术面得分（归一化到50分） + AI消息面得分（归一化到50分）\n归一化方法：技术面满分已更新为50分，因此不再需要额外乘区。AI消息面原始得分(满分10) / 10 * 50。 ETF决策流程与A股一致，但分数分布和信号解释更侧重资金流和行业轮动。 2.2. 技术面分析 (V3, 总分: 50分)\r技术面分析旨在捕捉市场的短期趋势和动量。它由五个核心指标构成，各自有独立的评分和权重。\n指标 权重 触发条件 (优先级由上到下) 得分 MACD趋势 15分 看涨金叉 (DIF上穿DEA，且DIF\u0026gt;0) +15 看跌死叉 (DIF下穿DEA，且DIF\u0026lt;0) -15 多头排列 (DIF\u0026gt;DEA) +8 空头排列 (DIF\u0026lt;DEA) -8 RSI动量 10分 RSI上穿50中轴 (强动量信号) +10 RSI下穿50中轴 (强动量信号) -10 RSI \u0026lt; 30 (超卖区) +8 RSI \u0026gt; 70 (超买区) -8 RSI \u0026lt; 40 (偏弱) +4 RSI \u0026gt; 60 (偏强) -4 布林带 8分 价格触及下轨 +8 价格触及上轨 -8 价格在中轨下方 +3 价格在中轨上方 -3 KDJ指标 7分 KDJ超卖 (K\u0026lt;20, D\u0026lt;20) +7 KDJ超买 (K\u0026gt;80, D\u0026gt;80) -7 KDJ金叉 (K\u0026gt;D) +3 KDJ死叉 (K\u0026lt;D) -3 成交量 10分 趋势显著放量 (MA5 \u0026gt; MA20*1.2) +5 趋势温和放量 (MA5 \u0026gt; MA20) +2 趋势显著缩量 (MA5 \u0026lt; MA20*0.8) -5 当日巨量 (Vol \u0026gt; MA20*2.0) +5 当日放量 (Vol \u0026gt; MA20*1.5) +2 最终报告形式: 技术面得分: [总分] | 原因: [综合原因] (MACD: [得分], RSI: [得分], 布林带: [得分], KDJ: [得分], 成交量: [得分])\n2.3. 基本面分析 (总权重: 35分)\r基本面分析旨在评估资产的内在价值。它由三个核心估值指标构成，以适应不同类型的投资标的。\n1. 市盈率 (PE) - (权重: 15分)\r数据来源: Akshare实时接口。对于ETF，则自动获取其跟踪指数的PE。 评分标准: PE \u0026lt; 15: +15分 (估值低) 15 \u0026lt;= PE \u0026lt; 30: +8分 (估值合理) 30 \u0026lt;= PE \u0026lt; 50: -8分 (估值偏高) PE \u0026gt;= 50: -15分 (估值过高) 2. 市净率 (PB) - (权重: 12分)\r数据来源: Akshare实时接口。对于ETF，则自动获取其跟踪指数的PB。 评分标准: PB \u0026lt; 1.5: +12分 (估值低) 1.5 \u0026lt;= PB \u0026lt; 3: +6分 (估值合理) 3 \u0026lt;= PB \u0026lt; 5: -6分 (估值偏高) PB \u0026gt;= 5: -12分 (估值过高) 3. 股息率 (Dividend Yield) - (权重: 8分)\r数据来源: Akshare实时接口。 评分标准: 股息率 \u0026gt; 4%: +8分 (高股息) 2% \u0026lt; 股息率 \u0026lt;= 4%: +4分 (股息尚可) 股息率 \u0026lt;= 2%: -8分 (股息较低) 评分平衡性: 正向分数总和 = 负向分数总和 = 35分\n正向: 15 + 12 + 8 = 35分 负向: (-15) + (-12) + (-8) = -35分 最终报告形式: 基本面得分: [总分] | 原因: [综合原因] (PE: [得分], PB: [得分], DY: [得分])\n2.4. AI市场情绪面分析 (总权重: 25分)\r本部分利用Gemini的联网搜索和分析能力，对最新的市场新闻和公告进行情绪量化。\n执行方式: 向Gemini API发送一个包含股票名称和代码的Prompt。\n返回格式: 要求Gemini返回一个包含以下字段的JSON对象：\nsentiment_score: 一个从 -10 (极度利空) 到 +10 (极度利好) 的量化分数。 sentiment_reason: 一句话总结的核心判断原因。 key_factors: 1-3个影响判断的关键事件列表。 data_date: 关键信息的最新日期。 分数换算: Gemini返回的 sentiment_score将乘以 2.5，以匹配本项 25分 的总权重。\n最终报告形式: AI消息面得分: [总分] | 原因: [AI总结的原因] (数据更新至: [日期]) 关键因素: [AI识别的关键事件]\n2.7. 实现状态与验证\r状态: 已完成 (As of 2025-08-17)\n技术面评分 (V3, 2.2节): strategy_engine.py 中的逻辑已通过 _calculate_technical_score 函数完全实现，并通过 tests/test_scoring_logic.py 中的 test_technical_scoring_detailed 单元测试验证。V3版更新了RSI趋势判断和成交量评分体系。 动态权重与总分计算: A股的动态加权和总分计算逻辑已在 _get_dynamic_weights 和 _calculate_score 中实现，并通过 test_dynamic_weight_adjustment 和 test_calculate_score_with_dynamic_weights 验证。 基本面评分 (2.3节): strategy_engine.py 中的逻辑已通过 _calculate_fundamental_score 函数完全实现，并通过 tests/test_fundamental_scoring.py 单元测试验证。 核心评分逻辑已实现模块化，与本文档描述的设计完全对齐。\n2.5. 新增技术指标\r系统现已支持更多A股常用的技术指标：\n1. 布林带 (Bollinger Bands)\r计算方式: 20日移动平均线 ± 2倍标准差 应用: 判断价格波动区间和超买超卖状态 2. KDJ指标\r计算方式: 基于9日RSV的随机指标 应用: 判断超买超卖和买卖时机 3. 成交量指标\r计算方式: 5日和10日成交量移动平均 应用: 分析量价关系和资金流向 4. ATR (平均真实波幅)\r计算方式: 14日真实波幅移动平均 应用: 衡量市场波动性和设置止损位 5. 威廉指标 (Williams %R)\r计算方式: 基于14日最高最低价的动量指标 应用: 判断超买超卖状态 2.6. 最终决策报告与日志\r系统在完成对所有股票的分析后，会生成一份聚合的决策报告表格，清晰地展示所有目标的分析结果。\n1. 单只股票分析过程输出\r在分析过程中，系统会为每只股票打印一行简要的完成信息，如下所示：\n--- 正在分析股票: 贵州茅台 (600519.SH) --- 分析完成: 贵州茅台 (600519.SH) - 总分: 65 | 最终信号: 【买入】 ---------------------------------------- 2. 最终聚合报告\r所有股票分析完成后，系统会打印一个统一的表格，汇总所有决策报告，方便横向对比。\n聚合报告表示例:\n股票名称 | 代码 | 技术面得分 | 基本面得分 | AI消息面得分 | 总分 | 最终决策 | 类型 ------------------------------------------------------------------------------------------------------------------ 贵州茅台 | 600519.SH | -5 | 17 | -8 | 4 | 【谨慎持有】 | A股 平安银行 | 000001.SZ | 25 | 15 | 12 | 52 | 【买入】 | A股 沪深300ETF | 510300.SH | 32 | 0 | 30 | 62 | 【买入】 | ETF 3. 决策等级说明\r重仓买入 (紫色): 总分 \u0026gt;= 80，强烈推荐买入信号 买入 (绿色): 总分 \u0026gt;= 60，推荐买入信号 持有 (黄色): 总分 \u0026gt;= 20，建议持有观望 谨慎持有 (青色): 总分 \u0026gt;= -10，建议谨慎持有或减仓 卖出 (红色): 总分 \u0026lt; -10，建议卖出信号 ETF决策等级说明\r重仓买入：总分 ≥ 80 买入：总分 ≥ 50 持有：总分 ≥ 30 谨慎持有：总分 ≥ 10 卖出：总分 \u0026lt; 10 注：ETF波动性低，建议结合资金流向和行业轮动信号综合判断。\n4. 日志文件\r对于有明确 买入/重仓买入 或 卖出 信号的股票，详细的决策依据会被记录在 logs/trade_signals_YYYY-MM-DD.log 文件中，供后续复盘。\n日志格式示例:\nSignal for 贵州茅台 (600519.SH) on 2025-01-13: 【买入】 - Tech: 15 (MACD看涨金叉, RSI(45.2)偏弱) (MACD: 15, RSI: 5, 布林带: 3, KDJ: -3) - Fundamentals: 17 (PE: PE=25.30, 估值合理, PB: PB=8.50, 估值过高, 股息率: 股息率=1.20%, 股息较低) (PE: 8, PB: -8, DY: 0) - AI Sentiment: -8 (市场情绪偏谨慎) (Data until: 2025-01-13) 关键因素: 白酒行业政策调整, 消费需求变化 - TOTAL SCORE: 24 ETF决策报告示例\r--- 正在分析ETF: 沪深300ETF (510300.SH) --- 分析完成: 沪深300ETF (510300.SH) - 总分: 62 | 最终信号: 【买入】 - 技术面: 32（均线多头排列，成交量放大） - 基本面: 0（ETF不参与基本面打分） - AI消息面: 30（资金净流入，行业轮动利好） ---------------------------------------- 3. API接口说明\r服务启动后，可以通过HTTP请求与系统交互。\n3.1. 健康检查\rEndpoint: GET /health 功能: 检查服务是否正常运行。 返回: {\u0026quot;status\u0026quot;: \u0026quot;ok\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;service is healthy\u0026quot;} 3.2. 触发分析任务\rEndpoint: GET /run 功能: 触发一次完整的分析流程。 查询参数: codes (可选, string): 指定一个或多个股票代码（用逗号分隔），仅分析这些股票。如果未提供，则执行“自选股+AI推荐”的完整流程。 请求示例: 触发完整流程: curl \u0026quot;http://127.0.0.1:5000/run\u0026quot; 分析指定股票: curl \u0026quot;http://127.0.0.1:5000/run?codes=600519.SH,000001.SZ\u0026quot; 返回: 成功时返回分析结果的JSON。 失败时返回 {\u0026quot;status\u0026quot;: \u0026quot;fail\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;错误信息\u0026quot;}。 4. 配置说明\r所有配置项均位于 src/config.py，并支持通过环境变量覆盖。\n核心配置: GEMINI_API_KEY: Gemini的API密钥。 STOCK_POOL: 自选股股票池。 ETF_TO_INDEX_MAP: ETF与对应指数的映射。 邮件配置: ENABLE_EMAIL_SENDING: 邮件发送总开关。 SMTP_SERVER, EMAIL_ADDRESS, EMAIL_PASSWORD, RECIPIENT_EMAIL: 邮箱参数。 评分权重: TECHNICAL_WEIGHTS, FUNDAMENTAL_WEIGHTS, SENTIMENT_WEIGHT: 各维度权重。 MARKET_REGIME_WEIGHTS: 不同市场状态下的权重动态调整配置。 决策阈值: DECISION_THRESHOLDS: 定义买入、卖出、持有等决策的分数线。 5. 部署与运维\r5.1. Docker部署 (推荐)\r创建 .env 文件: 在项目根目录创建 .env 文件，并填入环境变量（如 GEMINI_API_KEY）。 构建镜像: docker build -t quant-trading . 运行容器: docker run -d -p 5000:5000 --env-file .env quant-trading 5.2. 本地直接运行\r安装依赖: pip install -r requirements.txt 配置环境变量 或直接修改 src/config.py。 启动服务: python health_check.py 5.3. 自动化任务\rLinux: 使用 crontab 定时调用 /run 接口。 Windows: 使用“任务计划程序”定时执行curl命令或Python脚本。 6. 项目路线图 (Roadmap)\r本文档规划了系统未来的主要开发方向，旨在将其从一个选股分析工具，演进为一个功能完备的综合性量化平台。\n第一阶段：技术架构优化 (已完成)\r性能优化: 引入并发处理，并行获取和分析股票。 成本与效率优化: 增加基于缓存的AI分析结果复用。 架构优化: 改造API为异步模式，提供任务状态查询接口。 数据管理优化: 实现股票数据的增量更新和数据库索引。 第二阶段：功能与策略优化 (已完成)\r功能完备性增强: 引入回测框架 (BacktestingEngine)。 引入投资组合与风险管理 (PortfolioManager)。 量化策略深度优化: 引入市场状态机 (MarketRegime)，实现权重动态调整。 深化AI模型应用（情绪时序分析、AI因子挖掘、因果推断）。 第三阶段：平台化与智能化 (规划中)\r实盘交易集成: 对接主流券商（如华泰、同花顺）的实盘交易API，实现从信号生成到自动下单的交易闭环。 策略市场与回测平台: 开发一个可视化的策略回测界面。 允许用户通过Web界面创建、修改和回测自己的量化策略。 交互式Web仪表盘: 使用Streamlit或Dash/Plotly创建一个丰富的Web界面。 展示持仓分析、收益曲线、风险指标、市场状态等。 深度学习模型引入: 探索使用LSTM、Transformer等模型进行股价短期趋势预测。 将预测结果作为一个新的评分因子整合进StrategyEngine。 事件驱动策略: 监控新闻、公告、财报发布等事件。 开发基于特定事件（如业绩预增、高管增持）的交易策略。 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%8C%AB%E5%92%AA/test_knowledge_base/","title":"test_knowledge_base","content":"\r这是一个测试知识库文件\r这是一个关于人工智能的段落。人工智能是计算机科学的一个分支，旨在创建能够像人类一样思考和学习的智能机器。\n另一个关于机器学习的段落。机器学习是人工智能的一个子集，它使系统能够从数据中学习，而无需明确编程。山咪爱黏人。山咪名字的来源是为了纪念他的两个主人是登上认识的。山咪完成了两针疫苗，还没有绝育。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/transformer%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","title":"Transformer的工作原理","content":"Transformer的工作原理\n拿到句子：从前有个国王，他有个女儿\n1.Token化：分词为得到token:从前|有个|国王|，|他|有个|女儿\n2.词嵌入、词向量：将每个token进行向量化（该token和其他对象的关联关系打分）-\u0026gt;转换成一堆数字,例如国王[0.9（权力）,0.8（城堡），0.7（严肃）\u0026hellip;.]，女儿[\u0026hellip;.]\n3.注意力机制：\n​\t编码器处理：分析问题用注意力划重点（如国王和女儿关系等）\n​\t解码器处理：边编故事边查表，用注意力确保连贯，生成内容。\n整体：进入计算-\u0026gt;注意力机制-\u0026gt;计算token与上下文的关系 ，据概率得到新词\n4.不断生成：再将新词进行上述计算，得到下一个新词。像玩文字无限接龙，每次参考所有历史信息，用注意力决定下一步重点。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/unnitest%E7%AC%94%E8%AE%B0/","title":"unnitest笔记","content":" 一、引入 1.导包，import unnitest 2.编写测试类，继承unnitest 二、运行 1.unnitest.main(),运行全部用例\n2.测试套：testsuite\n创建：suite=unnitest.Testsuite()\n测试套添加用例：suite.addtTest（类（方法））\n运行：runner=unnitest.TextTestRunner()\n运行：runner.run(suite) *运行必须在命令行运行否则是运行全部用例\n三、生成报告\n1.将HTMLTestRunner.py文件放到项目文件夹下 2.导包：如左图 3.创建测试套，参考上方 4.创建测试报告文件，且以测试套运行（参考左图） 与pytest的异同 pytest以mark方式组织用例（而非套件） 面试相关 pycharm关闭pytest测试模式 ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E6%90%9E%E6%9C%BA/v100%E6%98%BE%E5%8D%A1%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/","title":"v100显卡折腾笔记","content":"\r核显配合双卡V100对AI大模型本地部署和本地出图的性能分析\r核显与双卡V100的组合对AI大模型本地部署和本地出图有显著提升，主要体现在显存池化与NVLink互联带来的算力扩展，以及核显承担显示任务释放V100资源的协同效应。这种配置方案在2025年已成为性价比极高的AI本地部署选择，特别适合预算有限但需要运行32B参数级别大模型的用户。\n一、双V100的核心性能优势\r双V100配置通过NVLink实现显存池化与算力扩展，为AI大模型本地部署提供了强大支持。每张V100单卡在FP16精度下具备125 TFLOPS的算力 ，双卡组合可提供高达250 TFLOPS的混合精度计算能力。在实际应用测试中，双V100在运行Qwen3-32B-GPTQ-INT4模型时，预填充速度达到1500 tokens/s，输出速度达45 tokens/s，分别是双MI50（300/25 tokens/s）的5倍和1.8倍 。对于文生图任务，双V100的每次迭代耗时约为1.39秒，比RTX 2080 Ti的2.17秒快36% 。\n双V100的显存池化能力尤为突出，单卡16GB HBM2显存，双卡可达32GB 。这一特性使其能够轻松处理32B参数级别的大模型（如DeepSeek-R1 32B、千问3 32B） ，支持高分辨率图像生成（如1024x1024及以上） 。在本地部署中，核显与双V100的协同工作模式使系统能够同时满足AI计算需求与图形显示需求，避免了因V100显存满载导致的显示卡顿或崩溃问题 。\n二、核显在AI任务中的角色与局限性\r核显在双V100配置中主要承担图形输出任务，确保系统显示稳定。核显不参与AI计算，其作用是释放V100的显示资源，使V100能够全功率用于计算任务 。这一分工模式通过驱动配置实现，用户需在运行计算任务时通过环境变量强制指定使用V100（如CUDA_VISIBLE_DEVICES=\u0026quot;0\u0026quot;） 。\n核显的局限性主要体现在三个方面：首先，其AI加速能力有限，现代核显（如Intel UHD）虽支持DL Boost指令集，但算力仅在10-45 TOPS范围内 ，远低于V100的Tensor Core性能（125 TFLOPS FP16） ；其次，核显工作时会占用部分内存带宽 ，可能对系统整体带宽造成影响；最后，核显与V100的驱动兼容性存在一定挑战，需通过特定驱动版本（如特斯拉专用驱动）和系统设置确保协同工作 。\n值得注意的是，核显在本地出图流程中可能承担轻量级图像后处理任务（如降噪、分辨率调整），但需依赖框架支持。例如，OpenVINO与核显的结合可加速部分图像处理流程，但这一加速效果与V100的计算任务基本独立，不会直接影响大模型推理性能。\n三、双V100+核显的性能提升幅度\r双V100+核显组合在AI大模型本地部署和本地出图任务中展现出显著的性能提升。在本地部署方面，双V100通过显存池化和NVLink高速互联（带宽约300GB/s） ，使系统能够处理更大规模的模型和数据集。例如，在千问3 32B模型上，双V100的token生成速度达每秒20.34个，而RTX 2080 Ti仅为13.43个，提升幅度约51% 。在DeepSeek R1 32B模型上，双V100的token生成速度为每秒21.28个，比RTX 2080 Ti的18个提升约18% 。\n在本地出图方面，双V100的显存池化和Tensor Core加速使Stable Diffusion等模型的生成速度大幅提升。测试数据显示，双V100在NF4量化版本的flux1-dev-bnb-nf4-v2模型上，每次迭代耗时约为1.39秒，比RTX 2080 Ti的2.17秒快36% 。通过显存优化策略（如FP16模式、显存交错分配等），双V100可将单卡训练速度提升34%，多机多卡场景下线性加速比达0.92 。\n核显在这一组合中的间接贡献主要体现在系统稳定性方面。当V100全负载运行AI任务时，核显负责显示输出，避免了因独显显存满载导致的系统崩溃或显示卡顿问题 。这种稳定性对于长时间运行的大模型训练和推理任务尤为重要。\n四、配置方案的性价比与适用场景\r双V100+核显的配置方案在2025年展现出极高的性价比。单张V100显卡价格已降至600元左右 ，双卡总成本约1200元。加上转接板（200元）和散热改装（80元） ，总投入约2000元，远低于消费级大显存卡（如RTX 5090需3.8万元） 。在AI任务性能上，双V100方案可达到RTX 4090的90%以上水平，但成本仅为后者的一半 。\n这一配置方案主要适用于以下场景：首先是大语言模型本地部署，如32B参数级别的DeepSeek-R1、千问3等 ，双V100的32GB显存池化足以支持这些模型的完整加载与并行计算；其次是高分辨率图像生成，如Stable Diffusion XL等复杂模型的本地出图 ，双V100的显存和算力优势可大幅缩短生成时间；第三是科学计算与数据分析，如分子动力学模拟、气候建模等需要大规模并行计算的任务 ，双V100的NVLink互联和Tensor Core加速可显著提升计算效率。\n然而，该配置方案也存在一些局限性：首先，V100采用服务器专用的SXM2接口，需通过转接板和散热器改装才能在消费级平台上使用 ，安装过程较为复杂；其次，V100需专用驱动（如特斯拉驱动），与核显驱动共存时可能需额外配置 ；最后，V100功耗较高（单卡300W），双卡总功耗约600W ，对电源和散热系统要求较高。\n五、实际应用中的优化策略\r为充分发挥双V100+核显组合的性能优势，用户需采取一系列优化策略。在驱动配置方面，建议使用特斯拉专用驱动（而非英伟达官网的Data Center驱动） ，并通过CUDA环境变量强制指定V100为计算卡。在系统设置方面，需通过Xorg配置指定核显为主显示设备，确保V100专注计算任务 。\n在显存管理方面，核显与双V100的分工模式可避免显存竞争。核显共享系统内存作为显存（最大占50%内存） ，而V100的32GB HBM2显存独立分配，两者显存资源互不干扰。通过显存优化策略（如FP16模式、显存交错分配等） ，双V100可将显存利用率提升至86%以上，有效支持大规模模型训练和推理。\n在本地出图流程中，可通过以下方式进一步提升性能：首先，降低图片分辨率至512x512或更低，生成后再用\u0026quot;高清修复\u0026quot;放大 ；其次，选择轻量模型（如SD 1.5基础版）并关闭非必要插件 ；最后，启用半精度推理（FP16），显存占用可减少约30% 。这些优化策略与双V100的算力优势相结合，可使本地出图效率达到最佳状态。\n六、未来发展趋势与替代方案\r随着AI技术的快速发展，双V100+核显的配置方案在未来几年内仍具有较高的实用价值。然而，用户也需关注新兴替代方案。例如，RTX 5090虽然价格较高（约3.8万元），但其32GB GDDR7显存和更高的显存带宽（1.5TB/s） ，使其在本地出图和大模型部署方面表现更佳。\n对于预算有限的用户，AMD的MI50显卡也是一个值得考虑的选择。MI50价格仅为800-1500元 ，虽然性能略逊于V100，但在某些应用场景（如显存带宽密集型任务）中表现不俗 。此外，消费级显卡如RTX 4090（约2.8万元） 和RTX 5080（约8400元） 也在AI任务性能上不断提升，适合对光追和DLSS有需求的用户。\n总体而言，双V100+核显的配置方案在2025年仍是性价比极高的AI本地部署选择，特别适合预算有限但需要运行大型AI模型的用户。通过合理配置和优化，这一方案能够提供接近高端消费级显卡的AI性能，同时避免高昂的成本和复杂的安装流程。对于长期AI开发需求，用户可考虑逐步升级至更先进的硬件平台，但双V100+核显的组合在短期内仍具有显著的实用价值。\n说明：报告内容由通义AI生成，仅供参考。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E7%AC%94%E8%AE%B0/","title":"大模型概述笔记","content":"\r\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; Updated upstream\rtitle: \u0026lsquo;大模型概述笔记\u0026rsquo; categories: [\u0026ldquo;技术\u0026rdquo;] date: 2025-11-20T15:58:13+00:00 lastmod: 2025-11-20T15:58:13+00:00\r大模型概述笔记\r大模型通识\rStashed changes\n大模型（LLM）：lage langrage model，基本都是基于transformer\ndeepseek r1 参数 671B 25年国内AI元年\nAGI\n通用人工智能，能模拟人类抽象推理，因果理解等能力，解决未知环境的复杂问题，是人工智能的终极目标之一。大模型是AI发展的里程碑，也是实现AGI的重要步骤。\n大模型类似公司实习生，要接入公司业务需要\r言传身教，亲自指导-提示词 熟悉工作流程SOP-agents 岗前培训-模型微调（通过新知识的理解，会改变模型能力-知识理解） 提供相关的业务资料-rag（知识增强） AIGC与AGI区别\rAGI是强人工智能，AIGC是人工智能生成内容\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/aigc%E9%80%9A%E8%AF%86/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E8%AF%86/","title":"大模型通识","content":"","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%80%9A%E8%AF%86/","title":"大模型通识","content":"大模型（LLM）：lage langrage model，基本都是基于transformer\ndeepseek r1 参数 671B 25年国内AI元年\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%98%B2%E6%AD%A2%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7/","title":"防止提示词注入技巧","content":"1.系统提示词设置固定角色和现在工作范围。例如：\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E6%9E%84%E5%BB%BAfastapi+vue%E9%A1%B9%E7%9B%AEdockerfile/","title":"构建fastapi+vue项目dockerfile","content":"\r构建fastapi步骤\r1.在fast_api项目下，创建文件gunicorn.conf.py 其内容如下： workers = 5 # 定义同时开启的处理请求的进程数量，根据网站流量适当调整 worker_class = \u0026#34;gevent\u0026#34; # 采用gevent库，支持异步处理请求，提高吞吐量 bind = \u0026#34;0.0.0.0:80\u0026#34; # 监听IP放宽，以便于Docker之间、Docker和宿主机之间的通信 2.python依赖存于项目requirements.txt文件内 3.fast_api项目下，构建Dockerfile，其内容如下： FROM python:3.7 WORKDIR /usr/src/app COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple COPY . . CMD [\u0026#34;gunicorn\u0026#34;, \u0026#34;fast_api:app\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;./gunicorn.conf.py\u0026#34;] 4.fast_api项目根目录终端，执行： docker build -t tools_flask .打包为镜像 #此处的fast_api为后端项目文件名称含fastapi的实现逻辑，注意文件名不要用“api.py”与已有模块冲突，运行不起来。 5.运行docker run -dit -p 5000:80 --name tools-flask tools_flask 启动为容器 dockerfile内容\rFROM python:3.9.2 WORKDIR /usr/src/app/tools/tools_flask ENV TZ Asia/Shanghai RUN ln -fs /usr/share/zoneinfo/${TZ} /etc/localtime \\ \u0026amp;\u0026amp; echo ${TZ} \u0026gt; /etc/timezone COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple COPY . . CMD [\u0026#34;uvicorn\u0026#34;, \u0026#34;fastapi_index:app\u0026#34;, \u0026#34;--host\u0026#34;, \u0026#34;0.0.0.0\u0026#34;, \u0026#34;--port\u0026#34;, \u0026#34;80\u0026#34;] 构建vue的步骤\r1.在项目tools_vue根目录，创建nginx夹，该文件夹下新建文件 default.conf。 default.conf内容如下： server { listen 80; server_name localhost; #charset koi8-r; access_log /var/log/nginx/host.access.log main; error_log /var/log/nginx/error.log error; location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 2.tools_vue项目根目录终端，执行npm run build，打包生成dist文件夹 3.在项目tools_vue根目录构建Dockerfile文件 FROM nginx COPY dist/ /usr/share/nginx/html/efctools COPY nginx/default.conf /etc/nginx/conf.d/default.conf 4.tools_vue项目根目录终端，执行： docker build -t tools_vue2 .打包为镜像 5.运行docker run -p 3002:80 -d --name tools-vue-v2 tools_vue2 启动为容器 dockerfile内容\rFROM nginx COPY dist/ /usr/share/nginx/html/ COPY nginx/default.conf /etc/nginx/conf.d/default.conf ","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","title":"机器学习","content":"\r\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; Updated upstream\rtitle: \u0026lsquo;机器学习\u0026rsquo; categories: [\u0026ldquo;技术\u0026rdquo;] date: 2025-11-20T15:58:13+00:00 lastmod: 2025-11-20T15:58:13+00:00\r机器学习\r机器学习\nStashed changes\n步骤：\n准备历史数据-\u0026gt;创建模型并训练历史数据-\u0026gt;新数据输入预测结果\n机器学习的分类\n监督学习：数据带结果/标签\n无监督学习：一大堆没有标签结果，让机器自行分类检测。\n自监督学习：无需人工标注，通过数据本身结果生成伪标签或辅助任务(通常办法)\n强化学习：不断尝试和环境互动得到的反馈改变行为做出最有决策AIRgo。\n模型训练的3大阶段\n预训练-\u0026gt;海量无标注的文本，进行自监督学习。\nSFT监督微调。-\u0026gt;使用有标注的数据对基座模型进行微调，让模型能够适用特定任务，最终得到一个有偏好的模型。\nRLHF强化学习，-\u0026gt;基于人类反馈的期望进行学习(奖励模型)。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E7%AE%A1%E7%90%86/%E7%BB%A9%E6%95%88%E8%A1%8C%E4%B8%BA/","title":"绩效、行为","content":"监督目标执行三步骤：\n第一步.对比结果，发现问题\n第二步.遇见偏差，分析原因\n第三部.补充计划，纠正偏差\n四种跟踪方法：\n1.管理岗的个人观察\n2、统计报告;数据\n3、员工的口头汇报\n4、员工的 书面报告\n纠偏三方案：\n1、纠正实际工作\n2、优化流程方法\n3、修正目标\n有效反馈的两个原则\n1.及时\n2.具体\n赞扬型反馈BAR模型：表述背景（B）、行为（A）、结果（R）\n描述事情背景、具体行为以及行为带来好的影响。\n建设性反馈：BAR-AR模型\nB：背景\nA：需要改进的行为\nR：带来不理想的结果\nA：建议的行为\nR：理想的结果\n反馈三原则：\n1.建议的行为要具体\n2.对事不对人\n3.以赞扬形式结束反馈\n辅导方法\n1.辅导的意义：经理人协助和引导下属提升工作绩效的过程，辅导是一对一的，并且是一个持续影响的过程\n2.辅导的目的：让员工技能完成任务，又能锻炼技能，来帮助管理岗减轻压力\n3.辅导的类型及时机：\n辅导三类型\n1.成功式辅导\n工作之前,协助员工找到问题并共创解决办法=预防病灶\n2.改进式辅导\n工作中,对工作出现的偏差进行辅导=阻截微病\n3.挽救式辅导\n对员工业绩不佳或行为不当进行辅导，配合行政管理手段=挽救生命\n成功式辅导两个关键点\n第一点：辅导的内容\n第二点：辅导的技巧:平衡“传授”与“提问\n传授：当员工没有经验时、当员工能力不足时\n提问：当员工具备一定经验时、当需要下属积极担责时\n成功式辅导技巧\n技巧1\nBAR反馈/赞扬型反馈\nB 前两次汇报时\nA 准备工作很细致\nR 你的准备最简洁、清楚\n成功式辅导的两个关键点\n① 辅导的内容:处理情绪与解决问题\n② 辅导的技巧:需要平衡“传授”与“提问\n成功式辅导的两个技巧\n① 树立信心BAR反馈\n② 引导成功的三大问题\n顾虑与担忧\n方案与方法\n信心与承诺\n1、绩效评估阶段两种错误打分倾向\n宽大化倾向\n平均化倾向\n2、三种绩效评估误区\n主观印象\n光环效应\n就近原则\n绩效管理\n5分制业绩打分标准\n5分：远超预定目标:完成目标的130%(及以上)\n4分：超出预定目标:完成目标的115%~130%(不含)\n3分：达到预定目标:完成目标的100%~115%(不含)\n2分：接近预定目标:完成目标的80%~100%(不含)\n1分：远未达到目标:完成目标的80%以下\n绩效计划阶段\n① 明确员工的“绩效目标”和“目标衡量标准’② 管理者打分时要剔除主观感情因素。\n打分标准设定的两个注意事项\n① 打分标准中,用具体的、可衡量的数字诠释文字标准。\n②) 定义业绩得分每一档区间时,要考虑员工付出的努力因素来参考设定。\n03员工各项得分取平均值或加权平均值\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%BE%E7%A8%8B%E7%9B%AE%E6%A0%87/","title":"课程目标","content":"把握好转行的机会！\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bpytest%E9%A1%B9%E7%9B%AE/","title":"快速上手pytest项目","content":"\rtags: [\u0026ldquo;pytest\u0026rdquo;, \u0026ldquo;python\u0026rdquo;]\r快速上手Pytest接口测试\r背景\r以前有分享过httprunner+pytest相关的使用方法，并且一直使用httprunner编写用自动化脚本，以前的经验可以快速帮我们上手pytest框架。为了快速上手pytest，HttpRunner 与Pytest 在编写自动化脚本异同点对比：\n对比维度HttpRunnerPytest用例编写方式支持YAML/JSON（低代码）和 pytest代码138纯 Python代码编写，支持函数式执行框架基于pytest（3.x版本后）18原生pytest框架，支持更灵活的参数化通过parameters在YAML/JSON中实现，或在 pytest代码中使用参数化装饰器16原生支持 @pytest.mark.parametr 高，支持动态生成数据断言机制基于validate关键字，支持jmespath 表达式18使用Python原生assert或第三方 pytest-assume 多断言)测试报告支持Allure（3.x版本后不再自带HTML报告）18依赖插件（如pytest-html、allure- 定制性强59扩展性通过debugtalk.py自定义函数，但框架耦合度高18原生支持插件开发，可通过conf fixture，扩展性极强5用例分层明确分层（APl/TestSuite/TestCase），适合原子接 口与流程组合18无强制分层，但可通过模块化 page_object模式）实现类学习曲线低代码门槛，适合快速上手15需 Python基础，但灵活性更高，道\r项目初始化\r克隆项目◦ git clone git@gitlab.guangpuyun.cn:clinic-diag/test/poct_api_test.git 了解项目结构\n安装依赖\r◦ 项目根目录下打开终端，执行pip install -r requirements.txt\n测试用例格式\r用例文件以test_开头或_test结尾◦ 建议以场景命名-如四合一的快速检测：test_zk_quicktest.py 用例集合——类，以Test开头（可以无）◦ 包含1个或多个测试用例函数 测试用例函数以test_开头◦ 一个函数代表一条用例- $_-\u0026gt;$ 一个明确的测试点 用例转换\r1、运行脚本utils/swaager.py——爬取swagger文档资源,存放于/api/swaggerApi目录 2、运行脚本api/generateTestCases.py，生成基础用例，存放于/api目录 3、基础用例结构\n此时只是生成了接口的对象，还需要编写实现逻辑和传参进一步实现该对象，完成测试用例编写（见用例编写）\n用例编写\r在/test对应的目录下新建用例文件，命名以test_开头，表明测试场景 导入必要的包和基础用例，如： from utils.logger import loggerfrom api.poctMina.addcartusingPosT import YsbMallCartController\n3. 编写测试用例\rfrom utils.logger import logger fron api.poctMina.addCartUsinqPosT import YsbMallCartController def test_addCartUsing(getTokenBySecret,pytestconfig): 用例名称-体现在报告上 addCartUsing $\\mathbf{\\sigma}=\\mathbf{\\sigma}$ YsbHallCartController ( addcartUsing.base_url $\\mathbf{\\sigma}=\\mathbf{\\sigma}$ pytestconfig.getini(\u0026lsquo;poct-host\u0026rsquo;) 构造url addCartUsinq.data[\u0026lsquo;addNum\u0026rsquo;]=1 addCartUsing.data[\u0026lsquo;packageId\u0026rsquo;] $=2\\dot{0}\\dot{\\Theta}$ addCartUsing.data[*token\u0026rsquo;]=getTokenBySecret(store=3o15659) 构造传参 response_data=addcartUsing.addcart() .json() 获取返回值 logger.info(response_data) assert response_data[\u0026lsquo;code\u0026rsquo;] $\\scriptstyle==$ \u0026lsquo;40001\u0026rsquo; 断言\n用例参数化\r1. 直接传参给函数 （小数据量）\r@pytest.mark.parametrize(x,y,[（x1，y1），（x2\u0026rsquo;，y2\u0026rsquo;）],indirect=True)\n2. 当需要对参数进行处理时\r@pytest.fixture(scope=\u0026lsquo;class\u0026rsquo;,autouse $\\risingdotseq$ True, params $\\c=$ order_id,ids $\\c=$ ids)scope作用域-可以是function，class,module，session;配合@pytest.mark.parametrize(x,[1,2],indirect $\\varXi^{-}$ True)传参使用， #indirect $\\varXi^{-}$ True代表使用fixture函数处理数据。 request.param 在 fixture 中获取原始参数值。\n1 import pytest 2 3 @pytest.fixture 4 def number(request): 5 return request.param $\\star$ 2 6 7 @pytest.mark.parametrize(\u0026ldquo;number\u0026rdquo;, [1, 2, 3], indirect=True) 8 def test_number(number): 9 assert number in [2, 4, 6]\n3. 参数化从文件读取数据\r从外部文件（如 CSV、JSON、YAML）读取测试数据，适用于数据量较大或需要动态生成数据的场景。\n1 import pytest 2 import json 3 4 def load_test_data(file_path): 5 with open(file_path, $\u0026ldquo;r\u0026rdquo;$ ) as f: 6 return json.load(f) 7 8 @pytest.mark.parametrize(\u0026ldquo;test_case\u0026rdquo;, load_test_data(\u0026rsquo;test_data.json\u0026rsquo;)) 9 def test_from_file(test_case): 10 assert test_case[\u0026lsquo;input\u0026rsquo;] $^+$ test_case[\u0026lsquo;addend\u0026rsquo;] $\\scriptstyle==$ test_case[\u0026rsquo;expected\u0026rsquo;]\npytest_generate_tests 钩子函数来自定义参数化。\r在测试收集阶段动态生成参数。 适用于需要在多个测试函数中共享参数化逻辑的情况。\n1 def pytest_generate_tests(metafunc): 2 if \u0026ldquo;num\u0026rdquo; in metafunc.fixturenames: 3 numbers $\\mathbf{\\Psi}=\\mathbf{\\Psi}$ [1, 2, 3] 4 metafunc.parametrize(\u0026ldquo;num\u0026rdquo;, numbers) 5 def test_number(num): 6 assert num in [1, 2, 3]\n5. 用例参数化 Fixture\r参数化 fixture，使其在不同的测试中提供不同的数据。\n1 import pytest 2 @pytest.fixture(params $\\c=$ [1, 2, 3]) 3 def number(request): 4 return request.param 5 def test_number(number): 6 assert isinstance(number, int)\n用例封装\r1. fixture关键字驱动\r方法：\n通过@pytest.fixture装饰器封装一些常用的工具函数放到conftest.py作用：\na. 用例中可实现不用导包直接使用。b. 可实现用例之间的参数传递c. 可作用于全局，也可灵活定义作用域\n例如：conftest.py中定义fixture函数获取token\n在用例中直接使用getTokenBySecret函数获取token：\r2. 公用模块的封装\r存放一些封装好的可复用的公共模块，如连接数据库，reques请求，日志模块等\n用例断言\ra. 判断是否为真： assert xxb. 判断不为真： assert not xxc. 判断a是否包含b： assert a in bd. 判断a不包含b： assert a not in be. 判断两值相等： assert b $\\mathtt{\\Gamma}==\\mathtt{a}$ f. 判断两值不相等： assert a != b\n运行\r1. 终端\r◦ pytest -q/-s 静默运行/运行时显示打印 ◦ 运行结果生成报告 pytest \u0026ndash;html=report.html ◦ 运行指定用例 pytest test_se.py::TestClassone::test_one ◦ 多进程数（NUM）运行 pytest test_se.py -n NUM ◦ 运行失败重试（NUM）次：pytest test_se.py \u0026ndash;reruns NUM ◦ 跳过用例运行@pytest.mark.skip ◦ 重试@pytest.mark.flaky(reruns $^{:=3}$ , reruns_delay $^{\\prime=2}$ ) #失败时重试3次，每次间隔2秒\n2. 代码运行\r直接运行main.py（提交代码前必须运行通过）\n测试报告\r浏览器打开pytest_report.html\r光谱接口自动化测试报告\rReport generated on 12-Mar-2025 at 16:13:25 by pytest-html v4.1.1\nEnvironment\rPython3.10.4执行时间2025-03-12 16:12:14项目名称POCT系统测试报告\rsummary\r17 tests took 00:01:11\n(Un)check the boxes to filter the results\nResultTest 用例路径TestName 用例名称执行时间Passedtests/test_poct_mal/test_addCart.py::test_addCartUsing加购物功能测试00:00:05Passedtests/test_poct_mall/test_getUsefulPoctProductsV2.py:test_getUsefulPoctProducts测试用例1：MachineSampleController查询所有有效的产品信息00:00:03Passedtests/test_poct_mal/test_getUsefulPoctProductsV2.pytest_getUsefulPoctProducts1测试用例2：PoctMinaMachineSampleController查询所有有效的产品信息00:00:01Passedtests/test_poct_mal/test_getUsefulPoctProductsV2.py:test_getUsefulPoctProducts2测试用例3：YsbMachineSampleController查询所有有效的产品信息00:00:01Passedtests/test_poct_mall/test_getUsefulPoctProductsV2.py:test_getUsefulPoctProducts3测试用例4：查询YtjMachineSampleController所有有效的产品信息933 msPassedtests/test_poct_mal/test_listAccount_2.py::TestPoctMinaOrderReportControllr:test_listAccount不分页查询下单账号00:00:01Passedtests/test_poct_mina/test_createOrder.py::TestMinaOrder:test_createOrder创建单项目订单，成功生成订单00:00:06Passedtests/test_poct_mina/test_createOrder.py.:TestMinaOrder::test_createOrder2创建多项目订单，成功生成订单00:00:04Passedtests/test_process_cases/test_zk_archivestest.py::TestArchivesTest:test_getArchives建档患者信息-信息同步00:00:01Passedtests/test_process_cases/test_zk_archivestest.py::TestArchivesTest:test_uploudArchives上传建档患者检测结果-患者信息正确00:00:05Passedtests/test_process_cases/test_zk_minaOrder.py::TestMinaOrder:test_get_orderld小程序下单后-订单同步到设备00:00:05Passedtests/test_process_cases/test_zk_minaOrder.py:TestMinaOrder:test_order_state小程序下单-设备上传检测结果-订单状态变为已完成00:00:05Passedtests/test_process_cases/test_zk_minaOrder.py::TestMinaOrder:test_product_state小程序下单-设备上传订单部分检测结果-检测项目状态变为已完成且无结果项目取消00:00:07Passedtests/test_process_cases/test_zk_minaOrder.py::TestMinaOrder:test_product_state_change小程序下单-设备细项加样上传细项检测结果日志-检测项目状态变为检测中00:00:15Passedtests/test_process_cases/test_zk_quicktest.py::Testquicktets::test_uploud_single_results测试上传单条检测结果创建订单-生成订单00:00:03Passedtests/test_process_cases/test_zk_quicktest.py::Testquicktets:test_upload_duplicate测试上传上传四个联检项目检测结果，创建订单且项目正确00:00:05Passedtests/test_process_cases/test_zk_quicktest.py::Testquicktets:test_upload_twice重复上传多次相同machine_id的同一条结果，只生成一个订单00:00:03\r","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/","title":"模型微调","content":"\r模型微调\r定义:在开源模型上，用领域内专业数据调整参数以适应特定任务。\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/git/%E4%BD%BF%E7%94%A8gihub%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/","title":"使用GiHub作为图床","content":"\r使用 GitHub 作为免费图床的文档\r最近就想找一款免费的图床来放置自己的图片，逛了一圈下来发现GitHub可以白嫖，于是乎，就有了这篇文章。\nGitHub 是一个非常流行的代码托管平台，除了代码存储外，你还可以使用 GitHub 来托管静态资源，比如图片。通过将图片上传到 GitHub 的仓库，你可以轻松获取图片的 URL，从而在网页或文档中嵌入这些图片。以下是如何使用 GitHub 作为免费图床的详细步骤。\n步骤 1: 创建 GitHub 仓库\r登录到 GitHub。\n点击右上角的 \u0026ldquo;+\u0026rdquo; 按钮，然后选择 \u0026ldquo;New repository\u0026rdquo;。\n填写仓库的名称（例如：my-image-hosting），并设置为公开（Public）。\n点击 \u0026ldquo;Create repository\u0026rdquo; 创建仓库。\n步骤 2: GitHub获取个人的Token\r访问：settings-tokens ，点击Generate new token 2.设置 token 属性 ，Expiration：永不过期，Select scopes：repo 一定要全选，其他的无所谓 ，点击最下方创建\n就会获得一个token字符串， ⚠️ 注意：一定要收藏好 token，因为只会显示一次！，关掉这个页面就再也看不见了。 [!IMPORTANT] 后续会继续使用这个token!!!!\n步骤 3: 下载PicGo\r在PicGo最新页面上下载它的安装包。PicGo下载页面 安装PicGo。无需赘述\n配置GitHub\n​\nPicGo 上传区配置选中你的配置 ​ 选择完成配置之后就可以拖拉拽上传文件了。\n步骤 4: Typora中使用\r打开Typora，在文件选项中选中偏好设置。 在图像选项中勾选你的安装路径 使用方式： 在Typora粘贴一张图片，右击图片上传，图片会上传并自动转换成链接\n++++\n使用 GitHub 图床大功告成！\r恭喜你完成了 GitHub 图床的配置！ 通过本文的引导，你已经学会了如何：\n创建 GitHub 仓库并上传图片； 获取并配置个人 Token； 使用 PicGo 工具进行图片上传； 在 Typora 中无缝集成并自动生成图片链接。 通过这个流程，你可以快速搭建自己的高效图床，结合 GitHub 和 JsDelivr CDN，免费、稳定且速度快！无论是博客写作还是前端项目开发，这都将是一个非常棒的工具！\n详情请参考我的博文: 使用GiHub作为图床 | 变量人生\n希望这篇教程对你有所帮助！祝你工作愉快，写作顺利！\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%8F%82%E8%80%83%E8%8C%83%E4%BE%8B/","title":"提示词参考范例","content":"\r通用提示词\r# 角色：角色名称 - 角色概述和主要职责的一句话描述 ## 技能： 1. 角色需要具备的技能1 2. 角色需要具备的技能2 3. 角色需要具备的技能3 # 要求： 1. 用户的具体需求1 2. 用户的具体需求2 3. 用户的具体需求3 # 任务： - 需要让大模型执行的具体任务 # 工作流： 1. 描述角色工作流程的第一步 2. 描述角色工作流程的第二步 3. 描述角色工作流程的第三步 # 示例： - 提供示例1:成功示例/失败范例,提供示例格式模板 - 提供示例2:成功示例/失败范例,提供示例格式模板 # 限制： - 描述角色在互动过程中需要遵循的限制条件1 - 描述角色在互动过程中需要遵循的限制条件2 - 描述角色在互动过程中需要遵循的限制条件3 基于知识的回答示例\r产品智能问答客服\r# 角色 你是一个专业的产品智能问答客服，能够依据产品上下文，准确、清晰地回答用户关于产品的各种问题。 ## 技能 ### 技能1: 回答产品相关问题 1. 当用户提出关于产品的问题时，仔细分析问题的关键信息。 2. 依据产品上下文，查找与问题相关的内容。 3. 用简洁明了的语言，将找到的信息整理成答案回复给用户。 ### 技能2: 处理复杂问题 1. 若用户的问题较为复杂，涉及多个方面，对问题进行拆解。 2. 分别从产品上下文中查找各部分相关信息。 3. 将整合后的信息有条理地呈现给用户，确保回答完整、准确。 # 回复示例: 关于您提出的[具体问题]，根据产品上下文，答案是[具体回答内容]。 # 限制: - 只回答与产品相关的问题，拒绝回答与产品无关的话题。 - 回答内容必须基于产品上下文，不能随意编造信息。 - 回答需简洁明了，避免冗长复杂的表述。 基于知识的提示模板示例\r# 角色 你是一个专业的产品智能问答客服，能够依据产品上下文，准确、清晰地回答用户关于产品的各种问题。 ## 技能 ### 技能1: 回答产品相关问题 1. 当用户提出关于产品的问题时，仔细分析问题的关键信息。 2. 依据产品上下文，查找与问题相关的内容。 3. 用简洁明了的语言，将找到的信息整理成答案回复给用户。 ### 技能2: 处理复杂问题 1. 若用户的问题较为复杂，涉及多个方面，对问题进行拆解。 2. 分别从产品上下文中查找各部分相关信息。 3. 将整合后的信息有条理地呈现给用户，确 …","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/","title":"提示词技巧","content":"\u0026amp;laquo;\u0026amp;laquo;\u0026amp;laquo;\u0026amp;lt; Updated upstream\n提示词技巧 总结：\r提示词模板\r通用提示词\r# 角色：角色名称 - 角色概述和主要职责的一句话描述 ## 技能： 1. 角色需要具备的技能1 2. 角色需要具备的技能2 3. 角色需要具备的技能3 # 要求： 1. 用户的具体需求1 2. 用户的具体需求2 3. 用户的具体需求3 # 任务： - 需要让大模型执行的具体任务 # 工作流： 1. 描述角色工作流程的第一步 2. 描述角色工作流程的第二步 3. 描述角色工作流程的第三步 # 示例： - 提供示例1:成功示例/失败范例,提供示例格式模板 - 提供示例2:成功示例/失败范例,提供示例格式模板 # 限制： - 描述角色在互动过程中需要遵循的限制条件1 - 描述角色在互动过程中需要遵循的限制条件2 - 描述角色在互动过程中需要遵循的限制条件3 基于知识的回答示例\r产品智能问答客服\r# 角色 你是一个专业的产品智能问答客服，能够依据产品上下文，准确、清晰地回答用户关于产品的各种问题。 ## 技能 ### 技能1: 回答产品相关问题 1. 当用户提出关于产品的问题时，仔细分析问题的关键信息。 2. 依据产品上下文，查找与问题相关的内容。 3. 用简洁明了的语言，将找到的信息整理成答案回复给用户。 ### 技能2: 处理复杂问题 1. 若用户的问题较为复杂，涉及多个方面，对问题进行拆解。 2. 分别从产品上下文中查找各部分相关信息。 3. 将整合后的信息有条理地呈现给用户，确保回答完整、准确。 # 回复示例: 关于您提出的[具体问题]，根据产品上下文，答案是[具体回答内容]。 # 限制: - 只回答与产品相关的问题，拒绝回答与产品无关的话题。 - 回答内容必须基于产品上下文，不能随意编造信息。 - 回答需简洁明了，避免冗长复杂的表述。 基于知识的提示模板示例\r# 角色 你是一个专业的产品智能问答客服，能够依据产品上下文，准确、清晰地回答用户关于产品的各种问题。 ## 技能 ### 技能1: 回答产品相关问题 1. 当用户提出关于产品的问题时，仔细分析问题的关键信息。 2. 依据产品上下文，查找与问题相关的内容。 3. 用简洁明了的语言，将找到的信息整理成答案回复给用户。 ### 技能2: 处理复杂问题 1. 若用户的问题较为复杂，涉及 …","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1763828471","permalink":"/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%99%BA%E8%83%BD%E4%BD%93/","title":"智能体","content":"\r智能体\r定义：自主执行任务的AI系统，可协调多个子代理完成复杂流程\n具备：工具调用、记忆、规划、行动等能力\n","date":"2025-11-22 16:21:11","updated":"2025-11-22 16:21:11"},{"objectID":"1745863200","permalink":"/post/hugo%E5%8D%9A%E5%AE%A2%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86/","title":"Hugo博客如何加密","content":"filePath: e:\\code\\golang\\hugo\\hugo-source-private\\layouts_default\\single.html\nchanges:\nnewStr: {{ if .Params.encrypted }}\n{{ end }}\r{{ .Content }}\r{{ if .Params.encrypted }}\r{{ end }}\roldStr: {{ .Content }}\n已成功为Hugo博客集成前端加密功能，以下是具体修改内容：\n{{ define \u0026#34;main\u0026#34; }} {{ if .Params.encrypted }} \u0026lt;div id=\u0026#34;encrypted-content\u0026#34; data-password=\u0026#34;{{ .Params.password }}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; {{ end }} \u0026lt;div class=\u0026#34;e-content article-entry\u0026#34;\u0026gt; {{ .Content }} \u0026lt;/div\u0026gt; {{ if .Params.encrypted }} \u0026lt;script src=\u0026#34;/js/encrypt.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} {{ end }} 实现效果：\n当文章front matter设置encrypted: true时自动加载加密模块 密码通过data-password属性安全传递 加密样式已适配主题默认布局 支持sessionStorage会话保持功能 测试方法：\n新建示例文章并添加front matter： --- title: \u0026#34;加密测试文章\u0026#34; encrypted: true password: \u0026#34;tian123456\u0026#34; --- 这里是加密内容 运行本地开发服务器测试加密功能 ","date":"2025-04-28 11:00:00","updated":"2025-04-28 11:00:00"},{"objectID":"1745765972","permalink":"/archives/%E5%85%B3%E4%BA%8Emac%E7%94%B5%E8%84%91%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%B4%A9%E6%BA%83%E7%9A%84%E5%8F%8D%E6%80%9D/","title":"关于mac电脑系统更新崩溃的反思","content":"\r事件描述\r今天在mac电脑上更新系统的时候，突然出现了一个问题，就是系统更新崩溃了，因为系统是装在移动硬盘上的，当初只为了追求移动硬盘空间更大，速度更快选择把系统装在了移动硬盘上。关键我也没有打开时间机器（mac自动备份程序），导致系统崩溃后需要重装，文件、应用都丢失了，特别是电脑的环境，如python、nodejs、go等环境都丢失了，导致我重新安装系统的时候，需要重新安装这些环境，非常麻烦，还有这几年积累的一些好用的应用和设置全没了损失惨重。\n反思\r当初不应该为了一丁点速度和硬盘空间，把系统装在移动硬盘上，应该把系统装在电脑上，这样才能保证系统的稳定性和安全性。 应该打开时间机器备份系统，这样可以避免系统崩溃后，原文件和应用不至于丢失。 后续步骤\r把系统装在电脑上，这样才能保证系统的稳定性和安全性。 格式化移动硬盘，把移动硬盘当作放文件的地方，并设置好分区。 打开时间机器备份系统，同时将移动硬盘作为系统备份盘，利用好空间大的优势，并且做好分区管理与正常文件隔离。 ","date":"2025-04-27 22:59:32","updated":"2025-04-27 22:59:32"},{"objectID":"1744297172","permalink":"/archives/%E5%85%B3%E4%BA%8E%E6%8A%95%E8%B5%84%E7%9A%84%E5%8F%8D%E6%80%9D_%E5%89%AF%E6%9C%AC/","title":"关于投资的反思","content":"\r25年一季度投资反思\r最近几天资产缩水严重，大概亏了1w左右。因为一个黑天鹅事件，美国向中国加了125%关税。 虽然后面又涨回来了，但是我在市场最恐慌的时候卖出了至少2/3的股票仓位，导致后面的反弹与我无缘。经过这次亏损我有一下几点反思。\n这说明我对这种短期的方向判断力是不够的，不太适合做短线。 另外一定要合理控制仓位，我之所以承受这么大的波动损失是因为我的股票型基金+股票的配比太大。借这次减仓后，需要合理配置这类高风险的资产。以后股票资产不能超过总账户的10% 另一个反思的点是我需要拉长定投周期，如果定投只能坚持几个月往往是在在左侧定投右侧卖出造成较大的亏损。既然选择了定投就应该让定投起到平滑操作带来的损失，去博大方向上的机会。 最后一个点是，在打算定投一个标的的适合一定要看看是否足够便宜，如果处于高点我宁可不参与。 ","date":"2025-04-10 22:59:32","updated":"2025-04-10 22:59:32"},{"objectID":"1744292612","permalink":"/archives/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","title":"《金字塔原理》解析","content":"\r《金字塔原理》读书笔记（全）\r一、 表达的逻辑 1. 为什么要用金字塔？ 2. 金字塔内部结构 3. 如何构建金字塔？ 4. 序言的具体写法 5. 演绎推理与归纳推理 二、 思考的逻辑 6.应用逻辑顺序 （一）时间顺序 （二）结构顺序 （三）程度顺序 7.概括这种思想 （一）行动性思想的概括——说明采取行动的结果/目标 （二）描述性思想的概括——找出各结论之间的共性 三、 解决问题的逻辑 8.界定问题 （一）界定问题的连续分析法： （二）界定问题的框架 9.结构化分析问题 四、 演示的逻辑 10.在书面上呈现金字塔 11.在PPT中呈现金字塔 12.在字里行间呈现金字塔 读后心得 部分参考笔记： 《金字塔原理》资源EPUB：链接：https://pan.baidu.com/s/1-2uv0ktITGT51ft603KfCQ 提取码：aioh 《金字塔原理》资源PDF：链接：https://pan.baidu.com/s/1Z5WIpUSCm9qr7sJhDyf-sQ 提取码：h1sk 12345AI写代码 金字塔原理是为了解决沟通、表达或是思考问题时思维混乱、分不清主次的问题。而其背后的方法论就是–搭建金字塔，以金字塔原理进行表达。书分为四部分：\n表达的逻辑：说，使用金字塔原理的原因和具体构建方法； 思考的逻辑：想，使用金字塔原理过程中的应用逻辑要素； 解决问题的逻辑：做，在实例中界定、解构、分析、解决问题； 演示的逻辑：表演，在PPT演示中和文字中呈现金字塔。 一、 表达的逻辑\r1. 为什么要用金字塔？\r究其原因是和人脑的思维逻辑有关系，人们思考的习惯方式倾向于对输入信息进行自动联想和关联，而对于那些没有逻辑或关联的内容习惯性忽略。所以金字塔结构表达，加强逻辑关联，可以让我们沟通更加高效。《金字塔原理》中指出，人类的思维结构一般有以下几个规律：\n大脑会自动将有相关联的信息进行归类； 一次记忆不超过7个思想、概念或项目； 在进行观点阐述时将背景、冲突、疑问等进行说明与解答可以更好地吸引读者注意力。 因此当我们在进行写作和演讲活动时，为了让受众更好地了解并接受我们所表达的观点我们必须：\n归类分组，将思想组织成金字塔：将关键词罗列出来，并组织归类； 找出逻辑关系，抽象概况：找到同类内容之后，我们需要对这部分共性内容进行抽象； 自上而下表达，结论先行：当我们先提出总的概念，再列出具体项目，即自上而下地呈现思想时，可以最有效的进行沟通和写作表达，类似于从收敛到发散的过程，脑图结构； 自下而上思考，总结概括：思维从底层开始构建，句子按照某种逻辑顺序组成段落，之后将段落组成章节，最后章节组成文章，金字塔最顶端的思想（中心思想、核心观点）代表整片文章观点。文章的思想有三种关联方式：向上、向下、横向。 纵向：文章中每一层次上的思想必须是对下一层次思想的概括 横向：每组中的思想必须同属于同一逻辑范畴 横向：每组中思想必须按逻辑顺序组织 而思想的组织存在4种逻辑顺序：\n演绎顺序：大前提、小前提、结论 时间（步骤）顺序：第一、第二、第三 结构（空间）顺序：波士顿、纽约、华盛顿 程度（重要性）顺序：最重要、次重要 2. 金字塔内部结构\r纵向关系：纵向关系是疑问-回答式的表达方式，让读者产生”为什么这么做的想法“，类似于层层推理。 横向关系：横向关系是某一个层次的表述需要能够承上启下，保证本层次内容合乎逻辑。 序言结构：为了让读者在文章开头就能够了解作者想要表达的内容，也就是说为了读者和作者从文章开始可以“站在同一角度”看问题，我们可以对文章的背景和问题进行描述，这样也可以使得接下来的叙述可以更好地进行。\n3. 如何构建金字塔？\r自上而下：\n提出文章主题思想 设想受众主要疑问 写序言：背景—冲突—疑问—回答，说明“背景”，指出“冲突”，检查“疑问”和“回答 与受众进行疑问—回答式对话 对受众的新疑问，重复进行疑问—回答式对话 自下而上：\n提出文章主题思想 设想受众主要疑问 写序言：背景—冲突—疑问—回答，说明“背景”，指出“冲突”，检查“疑问”和“回答” 与受众进行疑问—回答式对话 对受众的新疑问，重复进行疑问—回答式对话 初学者注意事项：\n先搭结构，尝试自上而下法 序言先写背景，将背景作为序言的起点 多花时间思考序言（背景—冲突—疑问—回答），不要省略 将历史背景放序言中 序言仅涉及读者不会对其真实性提出质疑的内容 在关键句层次上，更宜选择归纳推理法 4. 序言的具体写法\r基本结构：SCQA（背景—冲突—疑问—回答）\nS-Situation—介绍背景 C-Complication—指出冲突 Q-Question—引发疑问 A-Answer—给出答案 eg. 背景（S）—本公司的业务多元化研究服务在过去5年中增长了40% 冲突（C）—无法保证我们的工作对客户有明显益处 疑问（Q）—如何确保多元化研究确实对客户研究有明显益处？ 回答（A）—实施“公司发展项目”，以研究该问题 序言的常见模式：根据文章的风格陈述顺序也可以做出调整：\n标准式：背景—冲突—答案 开门见山式：答案—背景—冲突 突出忧虑式：冲突—背景—答案 突出信心式：疑问—背景—冲突—答案 书写序言时需要遵循以下原则： 1.序言的目的是“提示”读者而不是“告诉”读者某些信息 2.序言必须包含故事所需要的3个要素，“冲突”、“背景”、“答案” 3.序言的长度取决于读者和主题的需要\n5. 演绎推理与归纳推理\r演绎推理：是一系列线性的推理过程，譬如最经典的三段论，大前提+小前提，推导出结论。最终是为了得出一个由逻辑词“因此”引出的结论。 ☞ 举个例子: 比如用这三个步骤去进行推理，就可以按照以下步骤 ➀ 出现的问题或存在的现象 ➁ 产生问题的根源 / 原因 ➂ 解决问题的方案 归纳推理：将具有共同点的事实、思想或观点归类分组，并概括其共同性。\n其中在归纳时，应遵循 MECE 原则：\n1.各部分之间相互独立，相互排斥，没有重叠。（Mutually Exclusive ） 2.所有部分完全穷尽，没有遗漏。（Collectively Exhaustive ）\n演绎推理与归纳推理的区别： 演绎推理，第二点是对第一点主语或谓语的论述。 归纳推理，同组中的思想具有类似的主语或谓语。\n二、 思考的逻辑\r这部分介绍了如何深入细致地把握思维的细节 以保证你使用的语句真实，明确地呈现你希望表达的思想 12AI写代码 在上文中介绍了金字塔模型的结构，但在我们日常写作中依旧会面临以下两个问题：\n概括在一起的思想并不具有关联性 表达中心思想的句子“缺乏思想性” 因此为了将所有表达的思想联系起来，确定逻辑顺序并概括隐含意义，我们就需要继续学习逻辑顺序的确定和概括各组思想的方法。\n6.应用逻辑顺序\r大脑的归纳分组活动：\n1.确定前因后果关系——时间（步骤）顺序 2.将整体分割为部分——结构（空间）顺序 3.将类似事物归为一组——程度（重要性）顺序 （一）时间顺序\r运用时间顺序，首先一定要区分出原因和结果，其次需要揭示出隐含的逻辑思路。\n例： 在第一阶段应采取以下措施： 1.与主要管理人员及监管人员谈话 2.跟踪并记录交易行为和工作流程 3.确定所有关键业务环节 4.分析组织结构 5.理解服务和绩效措施 6.评估业务职能的绩效水平 7.找出问题和原因 8.发现提高生产效率的潜在可能性 12345678910AI写代码 分析上面例子我们发现它超出了我们之前说的大脑一次最多记忆的数字“7”，并且表达的思想逻辑出现混乱，如果我们能区分以上例子中行动的原因和行动产生的结果，就可以达到以下效果：\n1.确定企业的关键业务（3） —与主要人员沟通（1） —跟踪并记录交易行为和工作流程（2） 2.找出开展业务时存在的弱点（7） —调整组织结构（4） —制定并实施服务和绩效管理措施（5） —评估绩效水平（6） 3.提出切实可行的改革建议（8） 12345678AI写代码 在按照时间顺序组织的思想中，主题句是要达到的结果，表述思想的顺序与采取行动的顺序（第一步、第二步、第三步）一致。 1AI写代码 （二）结构顺序\r在使用结构顺序时，我们先需要了解MECE原则： 1.各部分之间相互独立，相互排斥，没有重叠。（Mutually Exclusive ） 2.所有部分完全穷尽，没有遗漏。（Collectively Exhaustive ） 以上图为例，在一个公司分支结构中轮胎部、硬件部、体育设备部等部门之间是相互独立的，但是在公司的下级结构中所有部门又都要包含到，因此就是“相互独立，完全穷尽”。\n如果划分时强调活动本身，那么各部分展现的就是一个逻辑过程（流程），应采用时间顺序。 如果划分时强调地点，那么各部分呈现的地理状况，应采用结构顺序。 如果划分时强调与某一产品或市场有关的活动，那么划分就是一种归类。 （三）程度顺序\r程度顺序，也称为重要性顺序，对一组因为具有某种共同特点而聚集在一起的事物进行陈述或分析时采用的顺序。例如在思考“一家公司存在的问题”时，一般会列出该公司存在的主要三个问题以及存在的其他次要问题，当然这几个问题要满足完全穷尽的要求，也要做到相互排斥。 一般情况下第一步，先明确每组中的问题具有的共同特性，确保将拥有同一特性的问题列入同一组中；第二步，每组问题中，所有特性的程度高低排序，最有问题的放在第一位，先强后弱。\n例：客户对销售报告和库存报告不满意： 1.提交报告的周期不恰当 2.库存数据不可靠 3.获得库存数据的时间太迟 4.库存数据与销售数据不吻合 5.客户希望能改进报告的格式 6.客户希望除去无意义的数据 7.客户希望突出说明特殊情况 8.客户希望减少手工计算 123456789AI写代码 正确分类归组的例子\n1.时机不对 1）提交报告的周期不恰当 3）获得库存数据的时间太迟 2.数据不符合要求 2）数据库存不可靠 4）库存数据与销售数据不符合 6）客户希望去除无意义的数据 3.格式不对 5）客户希望能改进报告的格式 7）客户希望突出说明特殊情况 8）客户希望减少手工计算 1234567891011AI写代码 最后根据需要的回答来进行重要性程度的排序：\n问题一：为什么系统会生成没有意义的报告（编制过程） 2.收集的数据不可靠 3.报告的格式混乱 1.生成报告的时间太晚，无法采取有效的行动 问题二：为什么客户不喜欢这种报告（阅读过程） 1.提交报告的时间太晚 3.阅读报告时无法找到所需数据 2.即使找到数据，数据也是错误的 问题三：如何解决该问题（解决问题的过程） 3.确定所需要的数据及其格式 2.确保报告中数据的可靠性 1.确保及时提交报告 1234567891011121314AI写代码 在了解一组思想表达观点的流程，要做到：\n1.确定该组思想的类别\n2.将同一类型的思想归类、分组\n3.找出各类别思想之间的顺序\n7.概括这种思想\r缺乏思想的句子对于一方面对于读者而言枯燥无味，另一方面对于作者而言很难表达出自己想要表达的含义。因此我们要避免使用缺乏思想的句子，说明采取行动的结果/目标，找出各结论之间的共性。\n在金字塔结构中我们提到过，上一层的思想是从下一层中衍生、提炼、总结出来的。因此，我们可以通过将一组思想归类，再进行抽象、提炼、概括的方法，来得到得到概括性思想。当我们获得概括性思想，就可以使用 演绎法（对其做进一步评论）或者使用归纳法（找出与之类似的思想） 的方法来扩展思路。\n所以，多花些精力从思想组提炼出正确的概括性思想非常重要！ 如何概括呢？一般分为行动性思想的概括和描述性思想的概括。\n概括行动性思想（介绍采取的行动、行为、步骤、流程）时，应说明采取行动后取得的“结果”（效果、达到的目标）。\n概括描述性思想（介绍背景、信息）时，应说明这些思想具有的“共同点的含义”（共同点的意义）。\n如何表达？ 1.在将各行动（步骤、流程等）联系起来之前，先用明确的语句描述各行动（步骤、流程等）。 2.找出明显的因果关系组合，尽量将每一组中的行动、步骤控制在5个以下。 3.直接从这些行动、步骤、流程，总结、概括行动的结果、目标。 1234AI写代码 （一）行动性思想的概括——说明采取行动的结果/目标\r在进行行动性思想概括时，我们要先采取行动是为了达到某种目的。当我们采取一系列行动，会产生特定的结果，然后根据这些特定的结果我们又会采取下一部行动。因此根据相互独立、完全穷尽的行动性思想及所产生的结果，就形成一个封闭体系。\n根据产生的结果将行动性思想分组\n当罗列出一些实现某一目标应当采取的行动时，必须先指出这些行动将会达到的结果，才能判断自己是否有遗漏，因此在使用行动性思想进行概括时，可以记住以下几个原则：（P169） 1.总结句要用明确的语言概括，说明行动产生的结果，用明确的语言描述各项行动、步骤、流程等 2.区分行动、步骤的层次找出明显的因果关系，将每一组行动、步骤控制在5个以内 3.直接概括行动的结果，利用行动、步骤、流程来总结、概括行动的结果、目标\n总结行动产生的结果之后要注意： 1.该组行动、步骤之间必须相互独立不重叠、完全穷尽无遗漏 2.总结概括性语句必须说明各项行动、步骤导致的直接结果，且措辞必须明确、具体 3.先用明确的语句表述各项行动、步骤、流程等，然后区分不同的抽象层次，再从各行动、步骤、流程等总结概括出行动的结果 1234AI写代码 （二）描述性思想的概括——找出各结论之间的共性\r描述性思想通常可以用“原因”“问题”或“结论”之类的单一名词表示，对描述性思想的概括可以帮助读者更好发现作者想要表达的观点。概括的基础是这些思想具有某种共性，如果要能够从描述性思想中提炼出概括性语言，就可以根据以下步骤来完成推论：\n找共性：首先要找出这些思想结构上的共性，即明白一组思想是否属于同一范畴，因此可以观察这些思想是否针对同一类主语、同一类谓语（动作或对象）或者具有同一类隐含思想 找联系：其次发现思想之间所具有的共性之后，再寻找这些思想更密切的联系 概括主旨：最后完成归纳跃进，概括出主题思想 三、 解决问题的逻辑\r这类文章需要回答的3个问题之一： 我们应该做什么？（如果不知道解决方案） 我们应该做吗？（如果已经给出了解决方案） 我们应该怎么做？你会怎么做？（如果已经知道且接收解决方案） 1234AI写代码 解决问题逻辑的流程：\n界定问题\u0026mdash;\u0026ndash;\u0026gt;结构化\u0026mdash;\u0026ndash;\u0026gt;分析/找到\u0026mdash;\u0026mdash;-\u0026gt;组成金字塔 分析问题 解决方案 与他人交流\n提高写资讯报告效率的秘密：\n界定问题。 有条理地搜集和分析数据，转换为金字塔的形式。 8.界定问题\r（一）界定问题的连续分析法：\r概念： （1）判断问题是否存在：看经过努力得到的结果（现状），与希望得到的结果（目标）之间是否有差距。 （2）非期望结果（R1）：即现状，由某一特定背景导致的某一特定结果 （3）期望结果（R2）：即目标，你不喜欢某一结果，想得到其他结果 （4）解决方案：如何从R1到R2 连续分析方法： （1） 界定问题（文章的序言） - 有没有/是否有可能有问题（或机会）？ - 问题在哪里？ （2） 结构化分析原因：为什么存在？（产生问题的根源、原因） （3） 寻找解决方案 - 我们能做什么？ - 我们应该做什么？ 12345678AI写代码 （二）界定问题的框架\r界定问题的框架需要回答的3个问题：\n发生了什么事？【背景（切入点/序幕+困扰/困惑）】 我们不喜欢它什么？（非期望结果R1） 我们想要什么？（期望结果R2） 把“界定的问题”写成序言：\n方法： 得出界定问题的框架后，只需遵循从左到右，再到下的原则，把读者最后了解的事实作为序言的冲突部分，并在此基础上提出问题。 目的： 分析和修改解决方案的辅助手段 - 展开问题的基本部分（运用框架） - 你的解决方案处于哪一阶段（已经提出了，还是已经被接受了） - 提出适当的疑问 - 检查序言是否呈现了界定的问题 - 检查金字塔原理是否回答了疑问 展开问题的各要素：\n切入点/序幕：简单的设想和简短的描述 困扰/困惑：外部原因、内部原因、近期认识到的其他原因 R1现状，非期望结果 对公司结构或流程产生负面影响 扰乱某一特定方面的工作 引发对业务、产品、流程的重新考虑 挑战有关客户、市场、竞争、核心竞争力、流程或技术的基本假设 R2目标，期望结果（具体和定量的描述） 用具体数字 用具体的最终结果 发掘读者的疑问（1） 最常见的问题\n不知道如何从R1（现状）到R2（目标） 知道如何从R1到R2，但不敢肯定是否正确 知道从R1到R2的正确方案，但不知道如何实施 （2） 最常见问题的变形\n知道从R1到R2的解决方案，并且已经实施，但由于某种原因行不通 确定了好几个解决方案，但不知道选哪一个 （3） 可能但不常见的情形\n知道R1，但不能具体描述R2，所以无法找到解决方案 知道R2，但不清楚自己是否处在R1（典型的杠杆比对） 开始写序言 （1） 我们应该做什么 S：系统目前的工作情况 C：它不做它该做的工作 Q：如何让它做它该做的工作？ （2） 我们是否应该做我们想做的事 S：我们存在问题 C：我们计划采取行动 Q：该行动是否正确？ （3） 我们应该如何做我们想做的事 S：我们曾经存在的问题 C：通过X行动我们解决问题 Q：你是如何进行X行动的？ （4） 解决方案行不通，我们应该做什么？ S：我们遇到问题并采取了数项措施 C：目前没有任何效果 Q：我们应该做什么 （5） 我们应该选择哪种方案？ S：我们计划实施X方案 C：有人提出Y可能是更好的方案 Q：哪种方案最好？ （6） 我们应该采用哪些战略？ S：我们目前是大市场中的小企业 C：不知道潜力是否发挥，但知道和顶级企业还有较大差距 Q：我们应该采取哪些战略？ （7） 我们存在问题吗？ S：新的市场划分带来很大变化 C：有看法认为这些变化对处于该行业中的企业不利 Q：该看法有无道理？为什么？ 1234567891011121314151617181920212223242526272829AI写代码 9.结构化分析问题\r从信息资料入手 设计诊断框架 如何设计诊断框架：相互独立， 完全穷尽的列举 呈现有形结构 寻找因果关系：还是穷举的方案，进行层层的原因下分，并把可能的原因进行分类 1.财务结构 2.活动（行动、措施）结构 将产生问题的可能原因进行分类 使用诊断框架 客户面临的问题 分析的方法 建立逻辑树 序列分析法：P271 1.是否有问题？ 2.问题在哪里？ 3.为什么存在？ 4.我们能做什么？ 5.我们因该做什么？ 寻找解决方案 （1）根据“相互独立，完全穷尽”的原则，对各种可能性作一个系统的逻辑细分 （2）计算相关收益和评估每种行动方案的风险，以便确定一套最终的解决方案 寻找各组思想的缺陷 是非问题分析 适用框架： -需要做出紧急决策 -不止一个方案有优点 -存在很多变数，需要考虑的目标也很多 -衡量结果的标准各不相同，还经常冲突 -行动的最终结果可能对其他方面的决策产生显著影响 是非问题分析的错误概念 关键步骤： 1.按先后顺序画出该政策领域的图解，标明每个阶段的主要决策变量（MVD），包括影响每项活动的环境、经济、管理和社会因素。 2.对这些主要决策变量如何影响目标的实现提出假设，并根据对目标实现有重要影响的主要决策变量，决定应该作出哪些决策。 12345678910111213141516171819202122232425262728293031323334AI写代码 PS： 关于这两章的内容不理解这两章想表达的含义 1、所举的例子似乎不太贴合自身的应用范围 2、举例冗余，表达不够简洁。\n四、 演示的逻辑\r10.在书面上呈现金字塔\r在页面上实现的金字塔的结构，在篇幅比较长的时候可通过：\n多级标题 下划线发 数字编号法 行首缩进法 项目符号法 PS:主要是格式问题需要注意。\n11.在PPT中呈现金字塔\rPPT展示文稿必须要了解和掌握的基本规则：\n文字幻灯片应仅包含最重要的、经过分组和总结的思想 PPT展示应当图文并茂 PPT应当是经过深思熟虑的故事梗概和脚本 PPT内容的 图片：文字 = 9：1 关键点： 1.每次展示仅一个论点 2.论点采用陈述句 3.文字尽量简短 4.简单的词语和数字 5.字号足够大 6.幻灯片的趣味性 7.逐级展开 12345678AI写代码 PS：这些都是做PPT的最常用最基本的原则。\n12.在字里行间呈现金字塔\r表达的词藻不一定要专业术语的堆砌，读者理解为首要。 图像以说明抽象概念（以强调自己表述的内容） 读者通常会以“图像”的方式进行信息的摄取。 因此，在文字表述前自己应当对要表述的内容建立脑图，不仅帮助自己理解要表达的内容，同时，也能够帮助作者写出文章。\n读后心得\r这本书主要是讲一些方法论，本文中心：\n任何事情都可以归纳出一个中心论点，而此中心论点可由三至七个论据支持，这些一级论据本身也可以是个论点，被二级的三至七个论据支持，如此延伸，状如金字塔； 界定问题，搜集分析，条理明晰，大胆归纳，小心演绎。 个人感觉需要“理论联系实际”才能把这本书的作用发挥到最大程度。没读这本书之前，其实在平常的工作生活中已经悄然的用上了书中部分方法，譬如：“总-分-总”三段式写法、脑图、PPT制作原则等。在读完之后，也能更加清楚的了解到自己需要使用哪种方法论来进行阐述自己的观点，可以更加灵活的运用起来，也确实是能够帮助自己快速融入以后的职场，以结果为导向，能够迅速抓住重点，并进行归类分析，帮助自己快速发现问题。\n部分参考笔记：\r[1] 读书笔记|《金字塔原理》—思考问题的逻辑. [2] 表达、思考和解决问题的逻辑（金字塔原理-高质量读书笔记）. [3] 十分钟读完《金字塔原理》. [4]《金字塔原理》这样的书应该怎样阅读，读起来会不会有很累的感觉？.\n","date":"2025-04-10 21:43:32","updated":"2025-04-10 21:43:32"},{"objectID":"1743173972","permalink":"/archives/25%E5%B9%B4%E4%B8%80%E5%AD%A3%E5%BA%A6%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/","title":"25年一季度汇报总结反思","content":"\r关于汇报过程的反思\r汇报过程难免还是有些紧张，感觉到不是内心害怕什么，就是单纯的紧张，可能是缺乏长时间汇报的经验，或者当初不擅长表达和总结。不过与以前对比效果稍好，这次准备的反而不多，可能是最后汇报的原因。并没有太多火力集中在我身上。 汇报往往会有许多问题和意见，对于别人的意见的看法，有些是好的意见，但是也不乏一些意见仅仅是提问人为了找存在感而提出来的。而且有些人相当强势，咄咄逼人，不给你反驳的机会。这种人往往都是狭隘和傲娇的，往往沉浸在自己的世界。对于这种意见，一笑了知即可。但是当触及到我们的棱角时，需要适当的发作。否则这些人会得寸进尺。 这次汇报准备并不充分，但是汇报效果反而不错。与之前精心准备，但是效果欠佳形成鲜明对比，这可能是心态上不重视，反而给自己临产发挥的空间，不至于被前期的准备束缚。当然，有些总结是不够的，更多的只是把组内做的事情陈列出来，缺乏系统性的总结，思路是不够清晰的。下次重点的提炼总结相关事项。 ","date":"2025-03-28 22:59:32","updated":"2025-03-28 22:59:32"},{"objectID":"1742533172","permalink":"/post/%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%88%86%E4%BA%AB/","title":"测试平台教程","content":"一、基本介绍：（） 桌面端工具（一年左右），使用python的wxpython框架编写，使用pyinstaller打包为桌面exe文件；缺点：体积大，不便于分享；\nweb端应用（10月初至今）：flask+vue实现；优点，通过脚本实现热更新；链接形式便于分享。\n二、功能介绍：\n三、技术实现\n测试平台采用前后端分离的方式实现:\n后端由flask框架实现； （1）flask项目结构 （2）在项目入口文件中构建接口 Flask：用于创建一个flask应用,app = Flask(name) CORS:解决跨域问题，cors = CORS(app) request:接受请求的参数，request.args.get()；phone = request.json[] jsonify:以json格式返回结果：jsonify({\u0026ldquo;data\u0026rdquo;: res}) 接口的基本组成：\n构建一个接口的基本步骤： 导包：Flask、CORS、request、jsonify 在app.route()装饰器中定义接口的请求类型、url路径 写一个接口函数 获取入参（可选） get请求 request.args.get() post请求 request.json[] 对得到的参数进行基本校验：如参数类型校验、字段长度、是否空、鉴权等。 根据传参进行逻辑处理，调用对应功能，得到结果 构建响应头（可选，返回类型是文件时必须） 构建结果，使用jsonify将返回结果构建成一个js （可选） return结果 启动flask app.run(ip,port,debug=True),其中debug=True代表以调试模式启动，代码改动后自动重启；debug默认为False。 包的管理 requirements.txt 代码中引入了的包，需要填写在该文件中，格式：“ 包名==版本号”\n（3）采用gunnicorn+gevent部署flask项目 介绍： 一个HTTP 服务器，可以增加项目的并发，通常和gevent一起使用。 安装gunicorn和gevent： pip install gunicorn -i https://pypi.tuna.tsinghua.edu.cn/simple pip install gevent-i https://pypi.tuna.tsinghua.edu.cn/simple 配置文件 gunicorn.conf.py workers = 10 定义同时开启的处理请求的进程数量，根据网站流量适当调整 worker_class = \u0026ldquo;gevent\u0026rdquo; 采用gevent库，支持异步处理请求，提高吞吐量 bind = \u0026ldquo;0.0.0.0:80\u0026rdquo; 监听IP放宽，以便于Docker之间、Docker和宿主机之间的通信,docker部署固定 采用启动服务： gunicorn flask_index:app -c ./gunicorn.conf.py 注意：Gunicorn只能运行在Linux环境中，不支持windows平台，因此在windows调试的时候不要用这个方式启动flask； 2. 前端：vue 、node.js（前端的包管理工具，类似python的pip包管理工具）、vue-cli（vue项目的脚手架）、element-ui、echats提供页面交互;\n（1）项目结构\n(2) 配置环境 安装node.js，前端包管理工具，直接下载安装即可 全局安装cnpm： npm install cnpm -g，解决npm速度慢的问题 cnpm install vue-cli -g 全局安装脚手架vue-cli 通过脚手架创建项目： vue init webpack my-project 启动项目：npm run serve 打包：npm run build (3)配置本地环境和正式环境：\n手动切换：url决定正式环境还是本地测试环境 （4）通过nginx部署：\n部署：docker（ ）+WebHooks（ ）+脚本的方式实现，合并代码后自动化部署。 构建Dockerfile： flask： Vue:\n打包docker（自动化形式）：\n以demo的方式演示实现一个工具： 后端：用flask分别写一个接口demo，实现：根据传参生成新诊所，并绑定到指定账号 安装flask、flask_cors (pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple) 新建一个flask项目 导包 简单实现一个get类型接口： 写一个post类型接口，调用已有函数： 启动flask\n前端：一个单页面的vue+elementui的demo： 准备文件（要引入的插件），将以下文件下载到项目的目录下\n、\n引入文件，在html的head标签中引入以上文件\n（需要先了解下html\\css\\js） 创建vue应用骨架 html部分 js部分 vue部分只需重点关注：模板语法、事件处理、以及常用指令 在页面中使用element-ui组件，以按钮为例，并给按钮添加事件处理： 使用axios发送请求 js\n写一个按钮用于触发POST接口请求、一个文本框用于显示接收的结果。 html部分：\njs部分\n四、后续方向 继续加入能提升效率的工具、加强提供测试数据的能力 自动化测试项目的可视化、测试用例少代码化\nfrom flask import Flask,request,jsonify from opened_new_clinic import opened_new_clinic from flask_cors import CORS @app.route(\u0026#39;/demo\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def get_msg(): msg=request.args.get(\u0026#34;message\u0026#34;) print(f\u0026#39;message, {msg}\u0026#39;) return {\u0026#34;data\u0026#34;:f\u0026#34;来自服务端的回复{msg}\u0026#34;} @app.route(\u0026#39;/create_clinic\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def create_clinic(): phone = request.json[\u0026#39;phone\u0026#39;] storeid = request.json[\u0026#39;storeid\u0026#39;] if phone != \u0026#39;\u0026#39; and storeid != \u0026#39;\u0026#39;: res = opened_new_clinic(phone, storeid) elif phone != \u0026#39;\u0026#39; and storeid == \u0026#39;\u0026#39;: res = opened_new_clinic(phone=phone) elif phone == \u0026#39;\u0026#39; and storeid != \u0026#39;\u0026#39;: res = opened_new_clinic(clinic_id=storeid) else: res = opened_new_clinic() return jsonify({\u0026#34;data\u0026#34;: res}) \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: {}, methods: {} }); \u0026lt;/script\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;send()\u0026#34;\u0026gt;{{name}}\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; create_clinic(){ var _this = this; axios .post(\u0026#39;http://localhost:5000/create_clinic\u0026#39; , { storeid:_this.form.store_id, phone:_this.form.phone }) .then( function(response) { _this.form.res = response.data.data console.log(info) }) .catch(function (error) { // 请求失败处理 console.log(error); }); } \u0026lt;div style=\u0026#34;height: 100px; margin-top: 100px;\u0026#34;\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;form.phone\u0026#34; placeholder=\u0026#34;请输入手机号-默认15898563796\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;form.store_id\u0026#34; placeholder=\u0026#34;请输入诊所id-空则随机开通\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;create_clinic()\u0026#34;\u0026gt;点击创建诊所\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;p\u0026gt;结果：\u0026lt;/p\u0026gt; \u0026lt;textarea v-model=\u0026#34;form.res\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data:{ name:\u0026#34;测试平台\u0026#34;, url: \u0026#34;http://test-platform.guangpuyun.cn/\u0026#34;, info:\u0026#34;\u0026#34;, form:{ phone:\u0026#39;\u0026#39;, store_id:\u0026#39;\u0026#39;, res:\u0026#39;\u0026#39; } }, methods: { send(){ var _this = this; axios .get(\u0026#39;http://localhost:5000/demo?message=test\u0026#39;) .then( function(response) { _this.info = response.data.data console.log(info) }) .catch(function (error) { // 请求失败处理 console.log(error); }); }, create_clinic(){ var _this = this; axios .post(\u0026#39;http://localhost:5000/create_clinic\u0026#39; , { storeid:_this.form.store_id, phone:_this.form.phone }) .then( function(response) { _this.form.res = response.data.data console.log(info) }) .catch(function (error) { // 请求失败处理 console.log(error); }); } } }); \u0026lt;/script\u0026gt; ","date":"2025-03-21 12:59:32","updated":"2025-03-21 12:59:32"}]