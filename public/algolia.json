
[
  
  
  {
    "objectID": "1761227921",
    "permalink": "/post/%E9%87%8F%E5%8C%96%E9%A1%B9%E7%9B%AE/ai%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E5%86%B3%E7%AD%96%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88/",
    "title": "AI量化交易决策系统方案",
    
    "content": "\r📝 2025-07-13 近期优化与变更\r新增布林带、KDJ、成交量、ATR、威廉指标，技术指标体系更丰富。 评分体系优化：技术面40分、基本面35分、情绪面25分，ETF与A股评分规则分离，ETF基本面恒为0，ETF评分=技术面50分+AI消息面50分。 决策等级优化：5级决策（重仓买入、买入、持有、谨慎持有、卖出），买入阈值降至50分，持有30分，谨慎持有10分，卖出\u0026lt;10分。 日志与邮件去重：每只股票仅保留最新信号，输出和报告更简明。 自动邮件集成：主程序运行后自动发送HTML格式决策报告，内容美化，信号带emoji和中文名。 数据兼容性增强：分析引擎支持成交量列名为vol或volume。 AI分析优化：ETF和A股分开提示，ETF基本面恒为0，AI消息面更关注资金流和行业新闻。 文档完善：补充README、部署、API、策略等文档，详细说明系统架构、评分体系、部署与接口。 用户体验提升：聚合报告美化，策略可读性提升，项目说明更精炼。 本文档详细阐述了本量化交易系统的核心决策逻辑。系统通过对技术面、基本面和AI市场情绪面三个维度进行独立的量化评分，最终加权汇总，生成交易信号。\n总分 = 技术面得分 + 基本面得分 + AI市场情绪面得分\n重仓买入阈值: 总分 \u0026gt;= 80 买入阈值: 总分 \u0026gt;= 60 持有阈值: 总分 \u0026gt;= 20 谨慎持有阈值: 总分 \u0026gt;= -10 卖出阈值: 总分 \u0026lt; -10 ETF评分体系（指数基金/ETF专用）\r技术面：50分（均线、成交量、波动率等为主，弱化KDJ等短线指标） AI消息面：50分（重点关注资金流向、申购赎回、行业轮动、指数调整等） 基本面：恒为0分（ETF不参与基本面打分） 总分 = 技术面得分（归一化到50分） + AI消息面得分（归一化到50分）\n归一化方法：技术面原始得分/40×50，AI消息面原始得分/25×50，四舍五入取整。 ETF决策流程与A股一致，但分数分布和信号解释更侧重资金流和行业轮动。 一、 技术面分析 (总权重: 40分)\r技术面分析旨在捕捉市场的短期趋势和动量。它由四个核心指标构成，各自有独立的评分和权重。\n指标 权重 触发条件 得分 MACD趋势 15分 看涨金叉 (DIF上穿DEA，且DIF\u0026gt;0) +15 看跌死叉 (DIF下穿DEA，且DIF\u0026lt;0) -15 多头排列 (DIF\u0026gt;DEA) +8 空头排列 (DIF\u0026lt;DEA) -8 RSI动量 10分 RSI \u0026lt; 30 (超卖区) +10 RSI \u0026gt; 70 (超买区) -10 RSI \u0026lt; 40 (偏弱) +5 RSI \u0026gt; 60 (偏强) -5 布林带 8分 价格触及下轨 +8 价格触及上轨 -8 价格在中轨下方 +3 价格在中轨上方 -3 KDJ指标 7分 KDJ超卖 (K\u0026lt;20, D\u0026lt;20) +7 KDJ超买 (K\u0026gt;80, D\u0026gt;80) -7 KDJ金叉 (K\u0026gt;D) +3 KDJ死叉 (K\u0026lt;D) -3 最终报告形式: 技术面得分: [总分] | 原因: [综合原因] (MACD: [得分], RSI: [得分], 布林带: [得分], KDJ: [得分])\n二、 基本面分析 (总权重: 35分)\r基本面分析旨在评估资产的内在价值。它由三个核心估值指标构成，以适应不同类型的投资标的。\n1. 市盈率 (PE) - (权重: 15分)\r数据来源: Akshare实时接口。对于ETF，则自动获取其跟踪指数的PE。 评分标准: PE \u0026lt; 15: +15分 (估值低) 15 \u0026lt;= PE \u0026lt; 30: +8分 (估值合理) 30 \u0026lt;= PE \u0026lt; 50: -8分 (估值偏高) PE \u0026gt;= 50: -15分 (估值过高) 2. 市净率 (PB) - (权重: 12分)\r数据来源: Akshare实时接口。对于ETF，则自动获取其跟踪指数的PB。 评分标准: PB \u0026lt; 1.5: +12分 (估值低) 1.5 \u0026lt;= PB \u0026lt; 3: +6分 (估值合理) 3 \u0026lt;= PB \u0026lt; 5: -6分 (估值偏高) PB \u0026gt;= 5: -12分 (估值过高) 3. 股息率 (Dividend Yield) - (权重: 8分)\r数据来源: Akshare实时接口。 评分标准: 股息率 \u0026gt; 4%: +8分 (高股息) 2% \u0026lt; 股息率 \u0026lt;= 4%: +4分 (股息尚可) 股息率 \u0026lt;= 2%: -8分 (股息较低) 评分平衡性: 正向分数总和 = 负向分数总和 = 35分\n正向: 15 + 12 + 8 = 35分 负向: (-15) + (-12) + (-8) = -35分 最终报告形式: 基本面得分: [总分] | 原因: [综合原因] (PE: [得分], PB: [得分], DY: [得分])\n三、 AI市场情绪面分析 (总权重: 25分)\r本部分利用Gemini的联网搜索和分析能力，对最新的市场新闻和公告进行情绪量化。\n执行方式: 向Gemini API发送一个包含股票名称和代码的Prompt。\n返回格式: 要求Gemini返回一个包含以下字段的JSON对象：\nsentiment_score: 一个从 -10 (极度利空) 到 +10 (极度利好) 的量化分数。 sentiment_reason: 一句话总结的核心判断原因。 key_factors: 1-3个影响判断的关键事件列表。 data_date: 关键信息的最新日期。 分数换算: Gemini返回的 sentiment_score将乘以 2.5，以匹配本项 25分 的总权重。\n最终报告形式: AI消息面得分: [总分] | 原因: [AI总结的原因] (数据更新至: [日期]) 关键因素: [AI识别的关键事件]\n四、 新增技术指标\r系统现已支持更多A股常用的技术指标：\n1. 布林带 (Bollinger Bands)\r计算方式: 20日移动平均线 ± 2倍标准差 应用: 判断价格波动区间和超买超卖状态 2. KDJ指标\r计算方式: 基于9日RSV的随机指标 应用: 判断超买超卖和买卖时机 3. 成交量指标\r计算方式: 5日和10日成交量移动平均 应用: 分析量价关系和资金流向 4. ATR (平均真实波幅)\r计算方式: 14日真实波幅移动平均 应用: 衡量市场波动性和设置止损位 5. 威廉指标 (Williams %R)\r计算方式: 基于14日最高最低价的动量指标 应用: 判断超买超卖状态 五、 最终决策报告\r系统在完成对所有股票的分析后，会生成一份聚合的决策报告表格，清晰地展示所有目标的分析结果。\n1. 单只股票分析过程输出\r在分析过程中，系统会为每只股票打印一行简要的完成信息，如下所示：\n--- 正在分析股票: 贵州茅台 (600519.SH) --- 分析完成: 贵州茅台 (600519.SH) - 总分: 65 | 最终信号: 【买入】 ---------------------------------------- 2. 最终聚合报告\r所有股票分析完成后，系统会打印一个统一的表格，汇总所有决策报告，方便横向对比。\n聚合报告表示例:\n股票名称 | 代码 | 技术面得分 | 基本面得分 | AI消息面得分 | 总分 | 最终决策 | 类型 ------------------------------------------------------------------------------------------------------------------ 贵州茅台 | 600519.SH | -5 | 17 | -8 | 4 | 【谨慎持有】 | A股 平安银行 | 000001.SZ | 25 | 15 | 12 | 52 | 【买入】 | A股 沪深300ETF | 510300.SH | 32 | 0 | 30 | 62 | 【买入】 | ETF 3. 决策等级说明\r重仓买入 (紫色): 总分 \u0026gt;= 80，强烈推荐买入信号 买入 (绿色): 总分 \u0026gt;= 60，推荐买入信号 持有 (黄色): 总分 \u0026gt;= 20，建议持有观望 谨慎持有 (青色): 总分 \u0026gt;= -10，建议谨慎持有或减仓 卖出 (红色): 总分 \u0026lt; -10，建议卖出信号 ETF决策等级说明\r重仓买入：总分 ≥ 80 买入：总分 ≥ 50 持有：总分 ≥ 30 谨慎持有：总分 ≥ 10 卖出：总分 \u0026lt; 10 注：ETF波动性低，建议结合资金流向和行业轮动信号综合判断。\n4. 日志文件\r对于有明确 买入/重仓买入 或 卖出 信号的股票，详细的决策依据会被记录在 logs/trade_signals_YYYY-MM-DD.log 文件中，供后续复盘。\n日志格式示例:\nSignal for 贵州茅台 (600519.SH) on 2025-01-13: 【买入】 - Tech: 15 (MACD看涨金叉, RSI(45.2)偏弱) (MACD: 15, RSI: 5, 布林带: 3, KDJ: -3) - Fundamentals: 17 (PE: PE=25.30, 估值合理, PB: PB=8.50, 估值过高, 股息率: 股息率=1.20%, 股息较低) (PE: 8, PB: -8, DY: 0) - AI Sentiment: -8 (市场情绪偏谨慎) (Data until: 2025-01-13) 关键因素: 白酒行业政策调整, 消费需求变化 - TOTAL SCORE: 24 ETF决策报告示例\r--- 正在分析ETF: 沪深300ETF (510300.SH) --- 分析完成: 沪深300ETF (510300.SH) - 总分: 62 | 最终信号: 【买入】 - 技术面: 32（均线多头排列，成交量放大） - 基本面: 0（ETF不参与基本面打分） - AI消息面: 30（资金净流入，行业轮动利好） ---------------------------------------- ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E9%87%8F%E5%8C%96%E9%A1%B9%E7%9B%AE/ai%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E5%86%B3%E7%AD%96%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/",
    "title": "AI量化交易决策系统技术文档",
    
    "content": "\r📝 2025-07-13 近期优化与变更\rAPI支持ETF与A股评分体系分离，ETF基本面恒为0，ETF评分=技术面50分+AI消息面50分。 评分体系与决策等级优化，买入阈值降至50分，持有30分，谨慎持有10分，卖出\u0026lt;10分。 日志与邮件内容去重，每只股票仅保留最新信号。 集成自动邮件功能，主程序运行后自动发送HTML决策报告。 数据兼容性增强，分析引擎支持成交量列名为vol或volume。 文档补充与完善，详细说明系统架构、评分体系、部署与接口。 用户体验提升，聚合报告美化，策略可读性提升。 📋 概述\r本文档详细说明了量化交易系统的各个模块、类、方法和接口，为开发者提供完整的API参考。\n🏗️ 系统架构\r核心模块\rsrc/ ├── config.py # 配置管理 ├── data_loader.py # 数据加载器 ├── analysis_engine.py # 分析引擎 ├── strategy_engine.py # 策略引擎 └── gemini_analyzer.py # AI分析器 📊 配置模块 (config.py)\r类和方法\r配置常量\r股票池配置\rSTOCK_POOL = { \u0026ldquo;000001.SZ\u0026rdquo;: \u0026ldquo;平安银行\u0026rdquo;, \u0026ldquo;600519.SH\u0026rdquo;: \u0026ldquo;贵州茅台\u0026rdquo;, # \u0026hellip; }\nAPI配置\rGEMINI_API_URL = \u0026ldquo;https://rglnawodplak.ap-southeast-1.clawcloudrun.com/****t/completions\u0026rdquo; GEMINI_API_KEY = \u0026ldquo;\u0026rdquo;\n数据路径\rDATA_PATH = \u0026ldquo;data\u0026rdquo;\n📈 数据加载器 (data_loader.py)\rDataLoader 类\r方法\r__init__(self)\r初始化数据加载器。\n参数: 无 返回: 无\nrun_update(self, days_to_fetch: int = 365)\r更新所有股票的最新数据。\n参数:\ndays_to_fetch (int): 获取数据的天数，默认365天 返回: 无\n异常:\nException: 数据更新失败时抛出 update_single_stock(self, stock_code: str, days_to_fetch: int = 365)\r更新单个股票的数据。\n参数:\nstock_code (str): 股票代码 days_to_fetch (int): 获取数据的天数 返回: 无\n🔍 分析引擎 (analysis_engine.py)\rAnalysisEngine 类\r技术指标计算方法\rcalculate_ma(self, data: pd.DataFrame, window: int) -\u0026gt; pd.Series\r计算移动平均线。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): 移动平均窗口大小 返回: pd.Series - 移动平均线数据\n异常:\nValueError: 数据中缺少 \u0026lsquo;close\u0026rsquo; 列时抛出 calculate_rsi(self, data: pd.DataFrame, window: int = 14) -\u0026gt; pd.Series\r计算相对强弱指数。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): RSI计算窗口，默认14 返回: pd.Series - RSI数据\ncalculate_macd(self, data: pd.DataFrame, short_window: int = 12, long_window: int = 26, signal_window: int = 9)\r计算MACD指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;close\u0026rsquo; 列的DataFrame short_window (int): 短期EMA窗口，默认12 long_window (int): 长期EMA窗口，默认26 signal_window (int): 信号线EMA窗口，默认9 返回: tuple - (MACD, Signal Line, MACD Histogram)\ncalculate_bollinger_bands(self, data: pd.DataFrame, window: int = 20, num_std: float = 2)\r计算布林带指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): 移动平均窗口，默认20 num_std (float): 标准差倍数，默认2 返回: tuple - (上轨, 中轨, 下轨)\ncalculate_kdj(self, data: pd.DataFrame, n: int = 9, m1: int = 3, m2: int = 3)\r计算KDJ指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;high\u0026rsquo;, \u0026rsquo;low\u0026rsquo;, \u0026lsquo;close\u0026rsquo; 列的DataFrame n (int): RSV计算周期，默认9 m1 (int): K值平滑系数，默认3 m2 (int): D值平滑系数，默认3 返回: tuple - (K, D, J值)\ncalculate_volume_indicators(self, data: pd.DataFrame)\r计算成交量相关指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;volume\u0026rsquo; 或 \u0026lsquo;vol\u0026rsquo; 列的DataFrame 返回: tuple - (成交量MA5, 成交量MA10, 量价关系)\ncalculate_atr(self, data: pd.DataFrame, window: int = 14)\r计算平均真实波幅。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;high\u0026rsquo;, \u0026rsquo;low\u0026rsquo;, \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): ATR计算窗口，默认14 返回: pd.Series - ATR值\ncalculate_williams_r(self, data: pd.DataFrame, window: int = 14)\r计算威廉指标。\n参数:\ndata (pd.DataFrame): 包含 \u0026lsquo;high\u0026rsquo;, \u0026rsquo;low\u0026rsquo;, \u0026lsquo;close\u0026rsquo; 列的DataFrame window (int): 计算窗口，默认14 返回: pd.Series - Williams %R值\nrun_all_indicators(self, data: pd.DataFrame) -\u0026gt; pd.DataFrame\r为给定的数据计算所有预设的技术指标。\n参数:\ndata (pd.DataFrame): 原始日线数据 返回: pd.DataFrame - 附加了所有技术指标列的DataFrame\n🎯 策略引擎 (strategy_engine.py)\rStrategyEngine 类\r决策等级常量\rDECISION_LEVELS = { \u0026#39;STRONG_BUY\u0026#39;: 2, # 重仓买入: 总分 \u0026gt;= 80 \u0026#39;BUY\u0026#39;: 1, # 买入: 总分 \u0026gt;= 60 \u0026#39;HOLD\u0026#39;: 0, # 持有: 总分 \u0026gt;= 20 \u0026#39;CAUTIOUS_HOLD\u0026#39;: -1, # 谨慎持有: 总分 \u0026gt;= -10 \u0026#39;SELL\u0026#39;: -2 # 卖出: 总分 \u0026lt; -10 } 评分方法\rget_pe_score(self, pe_ratio_str: str) -\u0026gt; tuple[int, str]\r根据PE估值打分。\n参数:\npe_ratio_str (str): PE比率字符串 返回: tuple - (得分, 原因说明)\nget_pb_score(self, pb_ratio_str: str) -\u0026gt; tuple[int, str]\r根据PB估值打分。\n参数:\npb_ratio_str (str): PB比率字符串 返回: tuple - (得分, 原因说明)\nget_dividend_yield_score(self, dividend_yield_str: str) -\u0026gt; tuple[int, str]\r根据股息率打分。\n参数:\ndividend_yield_str (str): 股息率字符串 返回: tuple - (得分, 原因说明)\nget_sentiment_score(self, gemini_analysis: dict) -\u0026gt; tuple[int, str]\r根据Gemini返回的量化情绪分进行打分。\n参数:\ngemini_analysis (dict): Gemini分析结果 返回: tuple - (得分, 原因说明)\nget_technical_score(self, data: pd.DataFrame) -\u0026gt; tuple[int, str, dict]\r根据多指标组合进行技术面综合打分。\n参数:\ndata (pd.DataFrame): 包含技术指标的DataFrame 返回: tuple - (总分, 原因字符串, 分数明细字典)\nget_decision_level(self, total_score: int) -\u0026gt; tuple[int, str]\r根据总分确定决策等级。\n参数:\ntotal_score (int): 总分 返回: tuple - (决策等级代码, 决策描述)\ngenerate_signals(self, data: pd.DataFrame, gemini_analysis: dict) -\u0026gt; tuple[pd.DataFrame, dict]\r根据技术面和Gemini的全面分析生成最终信号。\n参数:\ndata (pd.DataFrame): 包含技术指标的DataFrame gemini_analysis (dict): Gemini分析结果 返回: tuple - (添加了信号的DataFrame, 决策报告字典)\n🤖 AI分析器 (gemini_analyzer.py)\rGeminiAnalyzer 类\r方法\r__init__(self)\r初始化Gemini分析器。\n参数: 无 返回: 无\nget_holistic_analysis(self, stock_name: str, stock_code: str) -\u0026gt; dict\r获取股票的全面分析。\n参数:\nstock_name (str): 股票名称 stock_code (str): 股票代码 返回: dict - 包含分析结果的字典\n返回格式:\n{ \u0026#39;pe\u0026#39;: \u0026#39;25.5\u0026#39;, \u0026#39;pb\u0026#39;: \u0026#39;2.8\u0026#39;, \u0026#39;dividend_yield\u0026#39;: \u0026#39;3.2\u0026#39;, \u0026#39;sentiment_score\u0026#39;: \u0026#39;5\u0026#39;, \u0026#39;sentiment_reason\u0026#39;: \u0026#39;市场情绪良好\u0026#39;, \u0026#39;key_factors\u0026#39;: [\u0026#39;政策利好\u0026#39;, \u0026#39;业绩增长\u0026#39;], \u0026#39;data_date\u0026#39;: \u0026#39;2024-01-15\u0026#39; } 📧 邮件模块 (send_email.py)\r函数\rsend_email(subject: str, body: str, attachments: dict = None)\r发送邮件。\n参数:\nsubject (str): 邮件主题 body (str): 邮件内容 attachments (dict): 附件字典，可选 返回: 无\n异常:\nException: 邮件发送失败时抛出 read_file_content(filepath: str) -\u0026gt; str\r读取文件内容。\n参数:\nfilepath (str): 文件路径 返回: str - 文件内容，失败时返回None\nget_latest_log_content() -\u0026gt; str\r获取最新的日志内容。\n参数: 无 返回: str - 最新日志内容，无日志时返回None\nformat_decision_report() -\u0026gt; str\r格式化决策报告。\n参数: 无 返回: str - HTML格式的决策报告\n🧪 测试模块 (test_new_system.py)\r函数\rcreate_test_data() -\u0026gt; pd.DataFrame\r创建测试数据。\n参数: 无 返回: pd.DataFrame - 模拟的股票数据\ntest_analysis_engine()\r测试分析引擎。\n参数: 无 返回: pd.DataFrame - 分析后的数据\ntest_strategy_engine()\r测试策略引擎。\n参数: 无 返回: 无\ntest_decision_levels()\r测试决策等级。\n参数: 无 返回: 无\nmain()\r主测试函数。\n参数: 无 返回: 无\n📊 主程序 (main.py)\r函数\rsetup_logging()\r创建日志目录。\n参数: 无 返回: 无\nlog_signal(signal_to_log: str)\r将信号记录到当天的日志文件中。\n参数:\nsignal_to_log (str): 要记录的信号 返回: 无\nget_signal_color_and_text(signal: int, decision_desc: str) -\u0026gt; tuple[str, str]\r根据信号获取颜色和文本。\n参数:\nsignal (int): 信号代码 decision_desc (str): 决策描述 返回: tuple - (带颜色的文本, 纯文本)\nrun_main_flow()\r执行主流程。\n参数: 无 返回: 无\n🔧 配置说明\r环境变量\r# 可选的环境变量 GEMINI_API_URL=your-api-url GEMINI_API_KEY=your-api-key SMTP_SERVER=smtp.126.com EMAIL_ADDRESS=your-email@126.com EMAIL_PASSWORD=your-password 配置文件\rsrc/config.py: 主要配置文件 send_email.py: 邮件配置 requirements.txt: 依赖包列表 📝 日志格式\r交易信号日志格式\rSignal for 股票名称 (股票代码) on 日期: 【决策】 - Tech: 技术面得分 (技术面原因) (技术面明细) - Fundamentals: 基本面得分 (基本面原因) (基本面明细) - AI Sentiment: 情绪面得分 (情绪面原因) (数据日期) 关键因素 - TOTAL SCORE: 总分 系统日志格式\r时间戳 - 日志内容 ⚠️ 错误处理\r常见异常\rValueError: 数据格式错误 FileNotFoundError: 文件未找到 Exception: 网络错误、API错误等 错误处理建议\r检查数据完整性 验证API配置 确认网络连接 查看详细错误日志 🔄 版本历史\rv2.0 (当前版本)\r新增技术指标：布林带、KDJ、成交量、ATR、威廉指标 改进评分系统：技术面40分、基本面35分、情绪面25分 5级决策系统：重仓买入、买入、持有、谨慎持有、卖出 优化邮件报告：HTML格式，更好的可读性 完善项目文档 v1.0\r基础技术指标：MA、RSI、MACD 基础评分系统 3级决策系统：买入、持有、卖出 基础邮件功能 API版本: v2.0 最后更新: 2025-01-13 维护者: 量化交易系统团队\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E6%95%99%E7%A8%8B/docker%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/",
    "title": "docker使用笔记",
    
    "content": "docker pull ubuntu 载入ubuntu 镜像\ndocker pull training/webapp # 载入镜像\ndocker pull python:3.7 安装python镜像\ndocker pull nginx 安装nginx镜像\ndocker run -it python:3.7 /bin/bash 进入python镜像\n连接不上时，终端输入：\n1.cd \u0026ldquo;C:\\Program Files\\Docker\\Docker\u0026rdquo;\n2.DockerCli.exe -SwitchDaemon\ndocker run -it ubuntu /bin/bash 启用进入容器\nexit退出容器\ndocker run -d -P training/webapp python app.py 后台启用容器并随机映射到本机端口\ndocker run -d -p 5000:5000 training/webapp python app.py后台启用容器并指定映射到\ndocker logs -f id 查看应用日志\ndocker logs -f -t \u0026ndash;tail=100 dockerid 动态查看最新100条日志\ndocker top id 查看容器内部应用进程\ndocker ps -a 查看所有容器(可查容器id)\ndocker ps 查看在运行的容器\ndocker ps -l 查询最后一次创建的容器\ndocker start id 启用对应id的容器\ndocker restart id重启\ndocker stop id 停止\ndocker run -dit -p 5000:80 -v /opt/app/docker_app/tools_flask/tools:/usr/src/app/tools \u0026ndash;name tools-flask tools_flask; 启动容器并持久化docker目录\ndocker run -itd \u0026ndash;name ubuntu-test ubuntu /bin/bash 后台运行容器\ndocker exec -it id bash进入容器\ndocker export id \u0026gt; ubuntu.tar 导出容器\ncat docker/ubuntu.tar | docker import - test/ubuntu:v1 导入容器到镜像\ndocker rm -f id 删除容器\ndocker images 列出镜像列表\n镜像下载： https://hub.docker.com/\ndocker search 关键词搜索镜像\n传输文件\ndocker cp 本地文件的路径 container_id:\u0026lt;docker容器内的路径\u0026gt;\ndocker run -p 3000:80 -d \u0026ndash;name vueApp vuenginxcontainer\nDockerfile 来构建镜像\n1.创建Dockerfile 填写配置内容，参考：E:\\code\\flask_tools\\tools\\Dockerfile\n2.docker build -t flask_tools:v1 . Dockerfile当前目录构建镜像. 是基于当前目录的 。后面的.不能少\n3.docker run -p 5000:80 -d \u0026ndash;name flask2 flask_tools:v1 top bin/bash启用容器\ngunicorn -k gevent -c gunicorn.conf flask_index:app项目名 # 用gunicorn启动项目\n上传到docker hub\n先给要上传的仓库打上标签：\ndocker tag id tianqinghong/python_vue_share\n再push:\ndocker push tianqinghong/python_vue_share\n下载镜像\ndocker pull tianqinghong/python_vue_share\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E6%95%99%E7%A8%8B/encrypted-example/",
    "title": "encrypted-example",
    
    "content": "\r这是一篇加密的文章\r只有输入正确的密码才能查看这篇文章的内容。\n如何设置文章加密\r在文章的前置参数中添加以下内容：\nencrypted: true password: \u0026#34;你的密码\u0026#34; 这样就可以为文章添加密码保护了。\n密码保护的工作原理\r当用户访问加密文章时，会显示密码输入框 用户输入正确的密码后，文章内容才会显示 密码验证在浏览器端进行，不需要服务器支持 使用sessionStorage保存解锁状态，避免刷新页面后需要重新输入密码 注意事项\r这种加密方式只是前端加密，不能防止真正的黑客攻击 适合用于简单的内容保护，不适合保护高度敏感的信息 密码直接保存在文章的前置参数中，所以不要使用您在其他地方使用的重要密码 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E6%95%99%E7%A8%8B/gemma-3%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/",
    "title": "Gemma 3本地部署教程",
    
    "content": "Gemma 3 被谷歌称为目前最强的开源视觉模型之一。 该模型支持超过35种语言，能够分析文本、图像和短视频。值得注意的是，Gemma 3 的视觉编码器经过升级，支持高分辨率和非方形图像，并引入了 ShieldGemma 2 图像安全分类器，用于过滤被分类为性暗示、危险或暴力的内容。这些特性使得 Gemma 3 成为当前最强大的开源视觉模型之一。\n最新的 Gemma 3 多模态开源模型新功能\r使用世界上最好的单加速器模型进行构建： Gemma 3 以其尺寸提供最先进的性能，在 LMArena 排行榜的初步人类偏好评估中胜过 Llama3-405B、DeepSeek-V3 和 o3-mini。这可以帮助您创建可安装在单个 GPU 或 TPU 主机上的引人入胜的用户体验。 以 140 种语言走向全球：构建使用客户语言的应用程序。Gemma 3 提供对超过 35 种语言的开箱即用支持和对超过 140 种语言的预训练支持。 打造具备高级文本和视觉推理能力的AI：轻松构建分析图片、文本、短视频等应用，开启交互智能化新可能1。 使用扩展的上下文窗口处理复杂任务： Gemma 3 提供 128k 令牌上下文窗口，让您的应用程序处理和理解大量信息。 使用函数调用创建 AI 驱动的工作流程： Gemma 3 支持函数调用和结构化输出，以帮助您自动执行任务并构建代理体验。 通过量化模型更快地实现高性能： Gemma 3 引入了官方量化版本，减少了模型大小和计算要求，同时保持了高精度。\n本地安装，单显卡可以选择1b，4b，12b，27b，推荐选择27b，因为Gemma 3 27B 处于帕累托最佳点.\n本地部署Gemma 3开源大模型：\r1、下载官方 Ollama 【 点击前往 】 ，并通过下方的安装命令执行下载：\n普通用户建议选择4b和12b，显卡好的可以上27b\nollama run gemma3:1b ollama run gemma3:4b ollama run gemma3:12b ollama run gemma3:27b 2、通过Cherry Studio,添加本地大模型后使用 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/git/git-submodule/",
    "title": "Git submodule",
    
    "content": " title: \u0026ldquo;Git submodule\u0026rdquo;\ncategories: [\u0026ldquo;技术\u0026rdquo;, \u0026ldquo;git\u0026rdquo;, \u0026ldquo;hugo\u0026rdquo;]\ndate: 2025-03-20T12:59:32+08:00\ndraft: false\ntags: [\u0026ldquo;submodule\u0026rdquo;, \u0026ldquo;Git\u0026rdquo;, \u0026ldquo;教程\u0026rdquo;]\rGit submodule添加子项目_库 Git归并策略 添加 删除 输入“/”快速插入内容\n添加图标\n添加封面\n展示文档信息\nGit submodule添加子项目_库\n开发过程中，经常会有一些通用的部分希望抽取出来做成一个公共库来提供给别的工程来使用，而公共代码库的版本管理是个麻烦的事情。git submodule命令就可以解决这个问题。\nGit归并策略\nGit归并有两种策略：递归，章鱼。\n1.递归策略：当分支数只有两个的时候。\n2.章鱼策略：当分支数大于两个的时候。\nGit会自动选择归并的方法。\n3.子树策略：是Git另一种归并方法。（submodule）\n它可以把另一个子项目，嵌入到当前项目。而且会非常聪明的合并这些子项目。\n添加\n为当前工程添加submodule，命令如下：\ngit submodule add 仓库地址 路径\n其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。\n注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）\n示例:\ngit submodule add -f http://git.cs/Cmblife_iOS_Internal/modulesLib.git\n-f 是强制的意思，一般不需要加\n命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。\n删除\nsubmodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。\n下载的工程带有submodule\n当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：\ngit submodule update –init –recursive\n即可将子模块内容下载下来后工程才不会缺少相应的文件。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/git/gitlab%E9%85%8D%E7%BD%AEcicd%E5%B7%A5%E4%BD%9C%E6%B5%81/",
    "title": "gitlab配置cicd工作流",
    
    "content": "\rGitLab CI/CD 简介\rGitLab CI/CD 是 GitLab 内置的持续集成/持续部署工具，它允许开发者在代码提交后自动执行一系列任务，如构建、测试和部署。通过配置 CI/CD 流程，可以大大提高开发效率，减少人为错误，并确保代码质量。\nCI/CD 核心概念\r持续集成 (CI): 开发人员频繁地将代码集成到主分支，每次集成都通过自动化构建和测试来验证，从而尽早发现问题。 持续交付 (CD): 确保代码随时可以部署到生产环境，通常包括自动化测试和部署流程。 持续部署 (CD): 将持续交付更进一步，自动将通过测试的代码部署到生产环境。 .gitlab-ci.yml 配置文件\rGitLab CI/CD 的核心是 .gitlab-ci.yml 文件，它定义了 CI/CD 流水线的结构和行为。该文件需要放在项目的根目录下。\n基本结构\r# 定义阶段 stages: - build - test - deploy # 定义作业 build_job: stage: build script: - echo \u0026#34;Building the app\u0026#34; - make build test_job: stage: test script: - echo \u0026#34;Running tests\u0026#34; - make test deploy_job: stage: deploy script: - echo \u0026#34;Deploying the app\u0026#34; - make deploy only: - master 关键组件\rstages: 定义流水线的阶段，按顺序执行。 jobs: 定义在特定阶段执行的任务。 script: 在作业中执行的命令。 only/except: 控制作业何时运行（例如，只在特定分支上运行）。 GitLab Runner\rGitLab Runner 是执行 CI/CD 作业的代理，它可以安装在不同的环境中，如 Linux、Windows、macOS 等。\n安装 GitLab Runner\r# 在 Linux 上安装 curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash sudo apt-get install gitlab-runner # 在 macOS 上安装 brew install gitlab-runner 注册 Runner\rsudo gitlab-runner register 注册过程中，需要提供 GitLab 实例的 URL 和注册令牌，以及 Runner 的标签和执行器类型。\n高级配置\r环境变量\rvariables: DATABASE_URL: \u0026#34;postgres://postgres:postgres@postgres:5432/my_database\u0026#34; job_name: variables: DATABASE_URL: \u0026#34;postgres://postgres:postgres@postgres:5432/my_test_database\u0026#34; script: - echo $DATABASE_URL 缓存和构件\rcache: paths: - node_modules/ job_name: artifacts: paths: - dist/ expire_in: 1 week 依赖关系\rjob_name: stage: deploy dependencies: - build_job script: - echo \u0026#34;Deploying the app\u0026#34; 实际应用示例\rNode.js 项目\rimage: node:14 stages: - build - test - deploy cache: paths: - node_modules/ build: stage: build script: - npm install - npm run build artifacts: paths: - dist/ test: stage: test script: - npm run test deploy_staging: stage: deploy script: - npm install -g firebase-tools - firebase use staging - firebase deploy --token $FIREBASE_TOKEN only: - develop deploy_production: stage: deploy script: - npm install -g firebase-tools - firebase use production - firebase deploy --token $FIREBASE_TOKEN only: - master when: manual Python 项目\rimage: python:3.9 stages: - test - deploy before_script: - pip install -r requirements.txt test: stage: test script: - pytest deploy: stage: deploy script: - pip install awscli - aws s3 sync ./dist s3://my-bucket/ only: - master CI/CD 最佳实践\r保持流水线简单：只包含必要的步骤，避免过度复杂化。 使用缓存：缓存依赖项可以显著提高构建速度。 并行执行：将独立的任务并行执行以节省时间。 环境变量管理：使用 GitLab 的变量功能安全地存储敏感信息。 分支策略：为不同的分支配置不同的 CI/CD 行为。 故障排除\r常见问题\rRunner 无法连接：检查网络设置和 Runner 注册信息。 构建失败：查看日志以确定失败原因，可能是依赖项问题或脚本错误。 权限问题：确保 Runner 有足够的权限执行所需操作。 调试技巧\rjob_name: script: - set -x # 启用调试模式 - env # 打印环境变量 - ls -la # 列出文件 结论\rGitLab CI/CD 是一个强大的工具，可以自动化软件开发的各个阶段。通过正确配置 .gitlab-ci.yml 文件，可以实现代码的自动构建、测试和部署，提高开发效率和代码质量。随着对 CI/CD 实践的深入理解，可以进一步优化流水线，使其更加高效和可靠。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/git/git%E6%93%8D%E4%BD%9C/",
    "title": "git操作",
    
    "content": "\r回滚到指定提交\rgit reset \u0026ndash;hard c1ac53850b0314a20e97f669bafc8bb67a3a1124 git push 放弃变更强制提交\rgit reset \u0026ndash;hard ; git pull \u0026ndash;force 子模块的使用\r",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/git/git%E6%B7%BB%E5%8A%A0%E5%AD%90%E9%A1%B9%E7%9B%AE/",
    "title": "git添加子项目",
    
    "content": " 项目中添加子项目 1、git clone 父项目url 2、cd 父项目对应目录下：git submodule add \u0026lt;子项目地址\u0026gt; 3、git commit ;git push 4、此时子项目下的子项目是空的，需要cd到父目录cmd执行： git submodule update \u0026ndash;init \u0026ndash;recursive 或者执行：git submodule init 然后执行cd clone含嵌套项目的项目 git clone 父项目url \u0026ndash;recurse-submodules 不加\u0026ndash;recurse-submodules，克隆的子项目是空的 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80--%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E9%85%8D/",
    "title": "Go语言--安装和环境搭配",
    
    "content": "\r一.Go简介\rGo 语言（又称 Golang）是由 Google 开发的一种开源编程语言，于 2009 年正式对外发布。下面从多个方面为你介绍它：\n设计目标\rGo 语言的设计初衷是为了解决大规模软件开发中的一些问题，比如编译速度慢、并发编程复杂、代码可维护性差等。所以它结合了静态语言的性能优势和动态语言的开发效率。\n特点\r高效的编译和执行：Go 语言拥有快速的编译速度，这使得开发过程更加流畅。同时，它的执行效率也很高，能充分利用现代多核处理器的性能。 内置并发支持：Go 语言原生支持并发编程，通过goroutine和channel可以很方便地实现高并发程序。goroutine是一种轻量级的线程，占用资源少，创建和销毁的开销小；channel则用于goroutine之间的通信和同步。 垃圾回收机制：它具备自动垃圾回收功能，开发者无需手动管理内存，减少了内存泄漏的风险，提高了开发效率。 丰富的标准库：标准库涵盖了网络编程、文件操作、加密解密等多个领域，为开发者提供了便利，减少了对第三方库的依赖。 跨平台支持：可以在不同的操作系统和硬件平台上编译和运行，方便开发跨平台的应用程序。 应用场景\r云计算与容器编排：像 Docker 和 Kubernetes 这类知名项目，就是用 Go 语言开发的。 网络编程：由于其出色的并发性能和网络库，Go 语言非常适合开发网络服务器、代理服务器等。 分布式系统：在分布式系统中，Go 语言的并发模型和网络编程能力使其能够高效地处理大量的并发请求。 二、Go语言安装与配置\rGo语言支持以下系统：Linux、Mac、Windows。\n安装包下载地址：The Go Programming Language\nwindows\r直接安装系统下载安装即可！\nLinux\r将下载的二进制包解压至/usr/local目录\rtar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz AI写代码 将 /usr/local/go/bin 目录添加至 PATH 环境变量：\r可以编辑 /etc/profile，并将以下命令添加该文件的末尾，这样就可以永久生效：\nexport PATH=$PATH:/usr/local/go/bin AI写代码 然后执行\nsource /etc/profileAI写代码 三.编写基本测试用例\rpackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;)}AI写代码 go build 文件名+ 运行程序=go run文件名AI写代码 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E6%95%99%E7%A8%8B/hugo%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/",
    "title": "Hugo静态网站生成器入门指南",
    
    "content": "\r什么是Hugo？\rHugo是一个用Go语言编写的快速、现代的静态网站生成器。它可以将Markdown文件转换为HTML页面，非常适合构建文档网站、博客等。\nHugo的主要特点\r极快的构建速度 丰富的主题支持 简单的Markdown内容管理 强大的模板系统 内置的短代码功能 安装Hugo\r在Windows上安装Hugo的步骤：\n下载Hugo的Windows版本 解压到指定目录 将Hugo的可执行文件路径添加到系统环境变量 创建新站点\r使用以下命令创建一个新的Hugo站点：\nhugo new site mydocs 下载插件\r添加内容\r在content目录下创建Markdown文件来添加内容：\nhugo new blog/my-first-post.md 运行开发服务器\r使用以下命令启动开发服务器：\nhugo server -D --environment development #如果未设置环境变量则不需要指定环境。 部署网站\r使用以下命令生成静态文件：\nhugo 然后将public目录下的文件部署到Web服务器即可，注意每次推送前运行hugo更新public文件夹 若有更新域名，请删除public后，再运行hugo重新生成public，否则会出现路由错误的情况。 为了方便新建.sh脚本文件，命名为.command.sh # 判断是否已初始化Git仓库 if [ ! -d \u0026#34;.git\u0026#34; ]; then echo \u0026#34;未检测到Git仓库，正在初始化...\u0026#34; git init else echo \u0026#34;Git仓库已初始化\u0026#34; fi # 创建.gitignore文件，排除不需要版本控制的文件 cat \u0026gt; .gitignore \u0026lt;\u0026lt; EOF resources/ .DS_Store node_modules/ .hugo_build.lock EOF # 添加所有文件 git add . # 提交更改 git commit -m \u0026#34;更新博客\u0026#34; # 检查是否已关联远程仓库 REMOTE_URL=$(git remote get-url origin 2\u0026gt;/dev/null) if [ -z \u0026#34;$REMOTE_URL\u0026#34; ]; then echo \u0026#34;未检测到远程仓库，正在添加...\u0026#34; git remote add origin https://github.com/bluespace3/bluespace3.github.io else echo \u0026#34;已关联远程仓库：$REMOTE_URL\u0026#34; fi # 推送到GitHub git push -u origin main --force 终端运行 ..command.sh 更新维护\r后期维护有许多要留意的地方否则容易踩坑。\n新增文章，在项目根目录终端运行，hugo new content/post/文章名称 不同主题博客目录不一致，这里需要留意你下载主题的说明。\n生成的文章会自带字段，其中draft默认true需要维护成false或者删掉，否则视为草稿。如下：\ntitle: \u0026#34;测试平台教程\u0026#34; date: 2025-03-20T12:59:32+08:00 draft: false tags: [\u0026#34;测试平台\u0026#34;, \u0026#34;静态网站\u0026#34;, \u0026#34;教程\u0026#34;] 3.若只有一台电脑更新博客，可以只把public托管到github，若要多个终端更新。需要满足以下条件。\n终端的hugo版本和主题保持需要保持一致，建议把主题配置在hugo.toml文件里面。否则本地有多个主题时在运行时要指定主题。\nhugo -t hugo-theme-reimu\n需要把整个项目推到github，并且指定githubPage为存放public的分支。需要建立工作流，脚本如下。\nname: Deploy Hugo site on: push: branches: - main # 或者你的默认分支名 jobs: deploy: runs-on: ubuntu-latest permissions: contents: write # Ensure GITHUB_TOKEN has write access to contents steps: - uses: actions/checkout@v3 with: submodules: false # 确保自动拉取子模块 fetch-depth: 0 # 获取所有历史记录和标签 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: gh-pages # 部署到gh-pages分支 总结\rHugo是一个功能强大且易于使用的静态网站生成器，非常适合构建个人博客、文档网站等。\n优点是能快速构建，丰富的模板生态，方便的托管到github，后期维护成本低。\n缺点：只支持md格式，不支持在线编辑，因为只支持通过代码push到远程仓库更新，所以在切换终端时简直是噩梦，笔者在此处踩坑无数，特别需要注意这里。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/linux%E5%AE%89%E8%A3%85python/",
    "title": "linux安装python",
    
    "content": " title: \u0026ldquo;linux安装python\u0026rdquo;\ncategories: [\u0026ldquo;技术\u0026rdquo;, \u0026ldquo;linux\u0026rdquo;, \u0026ldquo;python\u0026rdquo;] date: 2025-03-20T12:59:32+08:00\ndraft: false\ntags: [\u0026ldquo;linux\u0026rdquo;, \u0026ldquo;python\u0026rdquo;, \u0026ldquo;教程\u0026rdquo;]\r#依赖包\nyum -y groupinstall \u0026ldquo;Development tools\u0026rdquo;\nyum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n#下载 Python3\nwget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz\n#创建文件夹\nmkdir /usr/local/python3\n#解压编译安装\ntar -xvJf Python-3.6.2.tar.xz\ncd Python-3.6.2\n./configure \u0026ndash;prefix=/usr/local/python3\nmake \u0026amp;\u0026amp; make install\n#给个软链\nln -sf /usr/local/python3/bin/python3 /usr/bin/python3\nln -sf /usr/local/python3/bin/pip3 /usr/bin/pip3\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
    "title": "linux常用命令",
    
    "content": " title: \u0026amp;ldquo;linux常用命令\u0026amp;rdquo; categories: [\u0026amp;ldquo;技术\u0026amp;rdquo;, \u0026amp;ldquo;linux\u0026amp;rdquo;] date: 2025-03-20T12:59:32+08:00\ndraft: false\ntags: [\u0026amp;ldquo;linux常用命令\u0026amp;rdquo;]\r文章目录\r一、目录操作 1、批量操作 二、文件操作 三、文件内容操作（查看日志，更改配置文件） 1、grep(检索文件内容) 2、awk(数据统计) 3、sed(替换文件内容) 4、管道操作符 | 四、系统日志位置 五、创建与删除软连接 六、压缩和解压缩 七、Linux下文件的详细信息 八、常用的docker容器的命令： 九、运维常用命令 1、查看服务器端口号是否可用 十、yum常用命令 十一、其他命令 1、xargs 2、curl语法 十二、Linux内核优化 十三、用户权限操作 1、用户操作 2、添加组 3、sudo用户权限操作 4、更换文件所有者 十四、TOP 1、统计信息区 2、进程信息区 十五、文件安装 1、文件下载(lrzsz) 十六、文章PDF版本 Linux 系统目录\n├── bin -\u0026amp;gt; usr/bin # 用于存放二进制命令 ├── boot # 内核及引导系统程序所在的目录 ├── dev # 所有设备文件的目录（如磁盘、光驱等） ├── etc # 配置文件默认路径、服务启动命令存放目录 ├── home # 用户家目录，root用户为/root ├── lib -\u0026amp;gt; usr/lib # 32位库文件存放目录 ├── lib64 -\u0026amp;gt; usr/lib64 # 64位库文件存放目录 ├── media # 媒体文件存放目录 ├── mnt # 临时挂载设备目录 ├── opt # 自定义软件安装存放目录 ├── proc # 进程及内核信息存放目录 ├── root # Root用户家目录 ├── run # 系统运行时产生临时文件，存放目录 ├── sbin -\u0026amp;gt; usr/sbin # 系统管理命令存放目录 ├── srv # 服务启动之后需要访问的数据目录 ├── sys # 系统使用目录 ├── tmp # 临时文件目录 ├── usr # 系统命令和帮助文件目录 └── var # 存放内容易变的 …",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E6%95%99%E7%A8%8B/mac%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E9%80%9F%E8%AE%B0/",
    "title": "mac电脑使用速记",
    
    "content": "在Mac终端中，有几种方法可以连续删除命令：\n使用 Ctrl + W ：删除光标前的一个单词 使用 Ctrl + U ：删除光标前的整行内容 使用 Ctrl + K ：删除光标后的整行内容 使用 Option + Delete ：删除光标前的一个单词（与 Ctrl + W 类似） 这些快捷键可以帮助你快速删除命令内容，提高终端操作效率。 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mcp-intro/",
    "title": "mcp-intro",
    
    "content": "\r什么是MCP？\rMCP（Model Context Protocol）是一种用于扩展和增强开发工具功能的协议。它允许开发者创建和使用MCP服务器，这些服务器可以提供额外的工具和资源，以提高开发效率和灵活性。\nMCP的安装\rMCP的安装通常包括以下步骤：\n安装MCP客户端：根据使用的开发工具，安装相应的MCP客户端插件或扩展。 创建MCP服务器：使用提供的工具或模板创建一个新的MCP服务器项目。 配置MCP服务器：在MCP服务器项目中添加所需的工具和资源，并进行相应的配置。 运行MCP服务器：启动MCP服务器，使其与MCP客户端进行通信。 使用示例\r以下是一个简单的MCP服务器使用示例：\n#!/usr/bin/env node import { Server } from \u0026#39;@modelcontextprotocol/sdk/server/index.js\u0026#39;; import { StdioServerTransport } from \u0026#39;@modelcontextprotocol/sdk/server/stdio.js\u0026#39;; const server = new Server( { name: \u0026#39;example-mcp-server\u0026#39;, version: \u0026#39;0.1.0\u0026#39;, }, { capabilities: { tools: { exampleTool: { description: \u0026#39;这是一个示例工具\u0026#39;, inputSchema: { type: \u0026#39;object\u0026#39;, properties: { message: { type: \u0026#39;string\u0026#39;, description: \u0026#39;要显示的消息\u0026#39;, }, }, required: [\u0026#39;message\u0026#39;], }, }, }, }, } ); server.setRequestHandler(\u0026#39;exampleTool\u0026#39;, async (request) =\u0026gt; { const message = request.params.message; return { content: [ { type: \u0026#39;text\u0026#39;, text: `您输入的消息是：${message}`, }, ], }; }); const transport = new StdioServerTransport(); await server.connect(transport); console.error(\u0026#39;MCP服务器正在运行\u0026#39;); 热门MCP工具推荐\r以下是一些目前热门的MCP工具：\n代码生成工具：根据项目需求自动生成代码模板和结构，提高开发效率。 API文档生成工具：自动从代码中提取API信息并生成详细的文档，方便团队成员查阅。 代码质量检查工具：对代码进行静态分析，检查潜在的错误和问题，提高代码质量。 自动化测试工具：自动生成和执行测试用例，确保代码的正确性和稳定性。 通过使用这些热门MCP工具，开发者可以大大提高开发效率和代码质量，更好地完成项目开发任务。\n总结\rMCP是一种强大的开发工具扩展协议，可以帮助开发者创建和使用各种工具和资源。通过本指南，您已经了解了MCP的基本使用方法，接下来可以探索更多高级功能和热门工具。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E6%95%99%E7%A8%8B/md%E6%A0%BC%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",
    "title": "md格式笔记使用指南",
    
    "content": "\r一、核心语法精要\r1. 标题与段落\r# 主标题（H1） ## 二级标题（H2） 普通段落直接换行书写，空行分隔段落 2. 列表系统 无序列表项 [x] 已完成任务 [ ] 待办事项 有序列表 第二项 3. 代码展示 ```python def hello_hugo(): print(\u0026#34;Welcome to Hugo Blog!\u0026#34;) 二、Hugo增强特性\n短代码应用 {{\u0026lt; highlight python \u0026ldquo;linenos=table\u0026rdquo; /\u0026gt;}} def hugo_shortcode(): return \u0026ldquo;Hugo特色功能\u0026rdquo; {{\u0026lt;/ /highlight \u0026gt;}} 响应式图片 {{\u0026lt; image src=\u0026quot;/images/md-example.png\u0026quot; alt=\u0026ldquo;Markdown示例\u0026rdquo; caption=\u0026ldquo;图1. 文档结构示意图\u0026rdquo; width=\u0026ldquo;80%\u0026rdquo; }}\n### 1. 基础语法 ```markdown ![替代文字](图片路径) 示例： ![技术架构图](/images/tech-arch.png) 三、可视化元素 流程图示例\ngraph TD\rA[开始] --\u003e B{判断}\rB --\u003e|条件1| C[操作1]\rB --\u003e|条件2| D[操作2]\r数据表格\n功能 语法示例 效果 脚注 内容说明^1 底部注解 定义列表 术语: 解释说明 层级关系 启动本地预览服务命令：\nhugo server -D 访问 http://localhost:1313 查看实时效果。请确保： 文件保存路径为 content/post/Markdown文档编写指南.md 已准备好示例图片 /images/md-example.png Hugo版本 ≥ 0.89.0（支持最新短代码语法） ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/mysql----%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/",
    "title": "MySQL -- 复合查询",
    
    "content": " 数据库的查询是数据库使用中比较重要的环节，前面的基础查询比较简单，不做介绍，可自行查阅。本文主要介绍复合查询，并结合用例进行讲解。\n本文的用例依据Soctt模式的经典测试表，可以自行下载，也可以自己创建\n链接：点这里跳转\n自行创建步骤如下：\n0、预备工作\r0.1 建表\r-- 创建 dept 表（部门表） CREATE TABLE dept ( deptno INT PRIMARY KEY, -- 部门编号 dname VARCHAR(14), -- 部门名称 loc VARCHAR(13) -- 部门位置 ); -- 创建 emp 表（员工表） CREATE TABLE emp ( empno INT PRIMARY KEY, -- 员工编号 ename VARCHAR(10), -- 员工姓名 job VARCHAR(9), -- 职位 mgr INT, -- 上级经理编号 hiredate DATE, -- 入职日期 sal DECIMAL(7,2), -- 工资 comm DECIMAL(7,2), -- 奖金 deptno INT, -- 部门编号 FOREIGN KEY (deptno) REFERENCES dept(deptno) ); -- 创建 salgrade 表（工资等级表） CREATE TABLE salgrade ( grade INT PRIMARY KEY, -- 工资等级 losal DECIMAL(7,2), -- 最低工资 hisal DECIMAL(7,2) -- 最高工资 ); 1234567891011121314151617181920212223242526AI写代码 0.2 插入测试数据\r-- 插入 dept 表数据 INSERT INTO dept (deptno, dname, loc) VALUES (10, \u0026#39;ACCOUNTING\u0026#39;, \u0026#39;NEW YORK\u0026#39;), (20, \u0026#39;RESEARCH\u0026#39;, \u0026#39;DALLAS\u0026#39;), (30, \u0026#39;SALES\u0026#39;, \u0026#39;CHICAGO\u0026#39;), (40, \u0026#39;OPERATIONS\u0026#39;, \u0026#39;BOSTON\u0026#39;); -- 插入 emp 表数据 INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES (7369, \u0026#39;SMITH\u0026#39;, \u0026#39;CLERK\u0026#39;, 7902, \u0026#39;1980-12-17\u0026#39;, 800.00, NULL, 20), (7499, \u0026#39;ALLEN\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-02-20\u0026#39;, 1600.00, 300.00, 30), (7521, \u0026#39;WARD\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-02-22\u0026#39;, 1250.00, 500.00, 30), (7566, \u0026#39;JONES\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-04-02\u0026#39;, 2975.00, NULL, 20), (7654, \u0026#39;MARTIN\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-09-28\u0026#39;, 1250.00, 1400.00, 30), (7698, \u0026#39;BLAKE\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-05-01\u0026#39;, 2850.00, NULL, 30), (7782, \u0026#39;CLARK\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-06-09\u0026#39;, 2450.00, NULL, 10), (7788, \u0026#39;SCOTT\u0026#39;, \u0026#39;ANALYST\u0026#39;, 7566, \u0026#39;1982-12-09\u0026#39;, 3000.00, NULL, 20), (7839, \u0026#39;KING\u0026#39;, \u0026#39;PRESIDENT\u0026#39;, NULL, \u0026#39;1981-11-17\u0026#39;, 5000.00, NULL, 10), (7844, \u0026#39;TURNER\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-09-08\u0026#39;, 1500.00, 0.00, 30), (7876, \u0026#39;ADAMS\u0026#39;, \u0026#39;CLERK\u0026#39;, 7788, \u0026#39;1983-01-12\u0026#39;, 1100.00, NULL, 20), (7900, \u0026#39;JAMES\u0026#39;, \u0026#39;CLERK\u0026#39;, 7698, \u0026#39;1981-12-03\u0026#39;, 950.00, NULL, 30), (7902, \u0026#39;FORD\u0026#39;, \u0026#39;ANALYST\u0026#39;, 7566, \u0026#39;1981-12-03\u0026#39;, 3000.00, NULL, 20), (7934, \u0026#39;MILLER\u0026#39;, \u0026#39;CLERK\u0026#39;, 7782, \u0026#39;1982-01-23\u0026#39;, 1300.00, NULL, 10); -- 插入 salgrade 表数据 INSERT INTO salgrade (grade, losal, hisal) VALUES (1, 700, 1200), (2, 1201, 1400), (3, 1401, 2000), (4, 2001, 3000), (5, 3001, 9999); 12345678910111213141516171819202122232425262728293031AI写代码 创建好以后，如果表的内容和下图一样，那基本就没问题了\n1、复合表的查询\r1.查询工资高于500 或 岗位为MANAGER 的雇员，同时还要满足他们的姓名首字母为大写的J\n根据上述的要求，我们可以发现，要查询的表总共两个条件，工资高于500 或 岗位为MANAGER， 首字母为J。 根据上述的两个条件，我们可以写出对应的sql查询语句： select name, job , sal from emp where (sal \u0026gt;= 500 or job = 'MANAGER') and enum like 'J%'; 这两个条件可以看成是并列条条件\n2.按照部门号升序而雇员工资降序的顺序对表的内容排序\n先观察一下这里的需求，首先就是要部门号升序，然后就是雇员的工资降序，所以这个案例的需求非常简单。根据这个要求我们可以写出sql查询语句：select deptno , sal from emp order by deptno asc , sal desc;\n3. 使用年薪进行降序排序\n这里我们需要特别注意的一个点就是年薪这个概念，年薪在这里是包括了12个月的月薪加上奖金，而这里奖金就是comm，但是奖金这一列很多都是NULL，而NULL是不参与计算的，所以这里就需要用ifnull(expression ，values)**(如果expression为null，返回的值为values否则返回expression)**利用这个函数的特点，我们就可以算出年薪 = 12 x sal + ifnull(comm,0)； 根据这个要求我们可以写出sql查询语句：select sal * 12 + ifnull(comm,0) 年薪 from emp order by 年薪 desc;\n4.显示工资最高的员工名字和工作岗位\n这条语句的要求非常简单，我们可以直接写出对应sql查询语句： select ename , job from emp where sal = (select max(sal) from emp);这里select是可以嵌套使用的，执行顺序就和C语言的中函数一样。当然，这里我们也可以分两步走，先把最高工资打印出来，再让第二条语句中 sal = 最高工资，结果是一样的。\n5. 显示工资高与平均工资的员工信息\n这个例子的要求和上面一个例子相差无几，做法也都差不多，先求出平均工资，再作比较即可。我们可以直接写出对应sql查询语句：select * from emp where sal \u0026gt;= (select avg(sal) from emp);\n6.显示每个部门的平均工资与最高工资\n这里也是只有两个条件，我们将平均工资和最高工资列出即可。我们可以直接写出对应sql查询语句：select deptno ,avg(sal),max(sal) from emp group by deptno;这里是先分组，然后再对内中内容进行筛查。\n7.显示平均工资低于两千的部门号和它的平均工资\n这个例子就需要和上面的例子一样，先对部门进行分组，分完组后就可以计算平均工资，然后再比对工资低于两千的部门。根据上述的条件，我们可以直接写出对应sql查询语句：select deptno ,avg(sal) 平均工资 from emp group by deptno having 平均工资 \u0026lt; 2000;这里的having是最后执行的，所以可以使用平均工资这个别名。\n8.显示每种岗位的雇员总数，平均工资\n这个例子和上面几个例子大差不差，这里不再赘述，直接把对应的语句写出：select deptno ,count(job) 人数,avg(sal) 平均工资 from emp group by job;\n2、多表复合查询\r前面我们介绍了单张表下的复合查询，但在日常生活中还存在非常的多表查询的情况。\n1、显示每一个雇员名，雇员工资和部门名称\n这个例子中和上面不同就是我们需要去查询部门名称，部门名称是在dept这张表中，而雇员名称以及工资在emp这张表中。这就需要我们将两张表的内容合并成一张表，也就是对第一张表的每一行内容与第二张表整张表进行组合，这种穷举的方式也叫作笛卡尔积。当然这种方式会生成很多没有啥意义的组合(部门号不对应)。这里我们就可以使用where进行筛查，select * from emp, dept where emp.deptno = dept.deptno结果如下图\n![\u0026gt;\n经过上述sql语句的筛查基本已经把要求给完成了，我们这里稍微完善一下即可：select ename,sal,dname from emp, dept where emp.deptno = dept.deptno\n3、自链接\r前面我们了解了不同表之间的进行链接查询，下面介绍一下同一张表之间链接。以下面这个例子为例：**a.显示员工FORD的上级领导的编号和姓名（mgr是员工领导的编号–empno）。**这个例子中，我们需要将在FORD的领导编号查出，然后在从当前这张表中查领导的相关信息。由此我们可以写出对应的sql语句：select empno,ename from emp where emp.empno=(select mgr from emp where ename=‘FORD’); 4、子查询\r**概念：子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询。**前面已有描述，这里就不再赘述\n4.1、单行子查询\r单行子查询表示的就是返回结果只有一行的子查询，以下面这一个通过下面这个例子帮助了解：\n显示SMITH同一部门的员工\n这个案例比较简单，我们只需先对SMITH先做子查询即可：select * from emp where deptno = (select deptno from emp where ename=‘smith’); 4.3、多行子查询\r这种子查询返回结果有很多行，但是原本子查询返回结果只有一行，所以这里我们需要将引入一些关键字，才能使其达到多行子查询的效果。\nin关键字 all关键字 any关键字 首先我们可以通过一个例子了解一下in关键字：a.查询和10号部门的工作岗位相同的雇员的名字，岗位，工资，部门号，但是不包含10自己.\n在这个例子中，我们要先查询10号部门的工作岗位相同的雇员，然后才是其它的相关信息，最后剔除十号部门。\n第一步：select distinct job from emp where deptno=10;\n第二步：select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10);这里的in在where中作为一种条件判断，表示判断job否在子查询中的表中。\n第三步：select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10) and deptno\u0026lt;\u0026gt;10;\n然后，我们通过另外一个例子来增加对all的理解：**显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号.**这里的all关键字其实和上面的in关键字一样，也是where中作为一种条件判断，代表子查询的所有结果。我们可以直接写出对应的sql语句：select ename, sal, deptno from emp where sal \u0026gt; all(select sal from emp where deptno=30); 最后一个any，作用和上面两个关键字大同小异，表示子查询的任意一个结果，用一个例子帮助理解：显示工资比部门30的任意员工的工资高的员工的姓名、工资和部门号（包含自己部门的员工）.，对应的sql语句：select ename, sal, deptno from emp where sal \u0026gt; any(select sal from emp where deptno=30); 4.4、多列子查询\r单行子查询是指子查询只返回单列，单行数据；多行子查询是指返回单列多行数据，都是针对单列而言的，而多列子查询则是指查询返回多个列数据的子查询语句。以下面例子为例：查询和SMITH的部门和岗位完全相同的所有雇员，不含SMITH本人这里第一步就是筛出SMITH部门和岗位相同的雇员，然后剔除SMITH，我们可以用括号的方式来对子查询各列的数据进行查询比对，具体方式如下： select ename from emp where (deptno, job)=(select deptno, job from emp where ename=‘SMITH’) and ename \u0026lt;\u0026gt; ‘SMITH’;\n4.5、from字句中使用子查询\r通过对前面的相关知识的了解，我们可以知道，子查询本质其实就是一张新的临时表，所以本质上我们查表都是在查一张表，就是将临时表和原表进行处理后的一张新表。既然上面 where 后面能够使用子查询，那from后面也必然是可以使用子查询的。from后面使用子查询就是将子查询生成的临时表与另外的表做笛卡尔积生成新的表，在从新的表中对数据进行筛查。下面用一个例子来帮助理解：显示每个高于自己部门平均工资的员工的姓名、部门、工资、平均工资\n对应的sql语句：//获取各个部门的平均工资，将其看作临时表 select ename, deptno, sal, format(asal,2) from emp, (select avg(sal) asal, deptno dt from emp group by deptno) tmp where emp.sal \u0026gt; tmp.asal and emp.deptno=tmp.dt;需要 需要注意的时from中子查询形成的临时表要有临时的名称。\n5、合并查询\r由于这个合并查询并不多见，使用率也较低，所以这里简单介绍即可。\nunion操作符：该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中的重复行。例子：将工资大于2500或职位是MANAGER的人找出来。 sql语句：select ename, sal, job from emp where sal\u0026gt;2500 union select ename, sal, job fromemp where job='MANAGER';\nunion all操作符：该操作符用于取得两个结果集的并集。当使用该操作符时，不会去掉结果集中的重复行。例子：将工资大于25000或职位是MANAGER的人找出来。sql语句：select ename, sal, job from emp where sal\u0026gt;2500 union all select ename, sal, job from emp where job='MANAGER';\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/playwright%E7%9A%84python%E6%96%87%E6%A1%A3/",
    "title": "playwright的python文档",
    
    "content": "\r安装\r引言\rPlaywright 是专门为满足端到端测试的需求而创建的。Playwright 支持包括 Chromium、WebKit 和 Firefox 在内的所有现代渲染引擎。在 Windows、Linux 和 macOS 上进行测试，无论是本地还是在 CI 上，无论是无头模式还是有头模式，都可以使用原生移动设备仿真。\nPlaywright 库可以用作通用的浏览器自动化工具，为同步和异步 Python 提供了一套强大的 API 来自动化 Web 应用程序。\n本介绍描述了 Playwright Pytest 插件，这是编写端到端测试的推荐方式。\n你将学到\n如何安装 Playwright Pytest 如何运行示例测试 安装 Playwright Pytest\rPlaywright 建议使用官方的 Playwright Pytest 插件来编写端到端测试。它提供了上下文隔离，并开箱即用地在多个浏览器配置上运行。\n首先，通过安装 Playwright 并运行示例测试来开始，亲眼看看它是如何工作的。\nPyPI Anaconda 安装所需的浏览器：\n添加示例测试\r在当前工作目录或遵循 test_ 前缀约定的子目录中创建一个文件，例如 test_example.py，并在其中包含以下代码。确保你的测试名称也遵循 test_ 前缀约定。\ntest_example.py\nimport re from playwright.sync_api import Page, expect def test_has_title(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 期望标题“包含”一个子字符串。 expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) def test_get_started_link(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 点击“开始”链接。 page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() # 期望页面有一个名为“安装”的标题。 expect(page.get_by_role(\u0026#34;heading\u0026#34;, name=\u0026#34;Installation\u0026#34;)).to_be_visible() 运行示例测试\r默认情况下，测试将在 Chromium 上运行。这可以通过 CLI 选项进行配置。测试以无头模式运行，这意味着在运行测试时不会打开浏览器 UI。测试结果和测试日志将在终端中显示。\n更新 Playwright\r要将 Playwright 更新到最新版本，请运行以下命令：\npip install pytest-playwright playwright -U 系统要求\rPython 3.8 或更高版本。 Windows 10+、Windows Server 2016+ 或 Windows Subsystem for Linux (WSL)。 MacOS 12 Monterey、MacOS 13 Ventura 或 MacOS 14 Sonoma。 Debian 11、Debian 12、Ubuntu 20.04 或 Ubuntu 22.04。 接下来是什么\r使用 Web 优先断言、页面夹具和定位器编写测试 运行单个测试、多个测试、有头模式 使用 Codegen 生成测试 查看测试的跟踪 编写测试用例\r引言\rPlaywright 测试很简单，它们\n执行操作 ， 断言状态与预期相符。 在执行操作之前没有必要等待任何东西：Playwright 在执行每个操作之前会自动等待一系列可操作性检查通过。\n也没有必要在执行检查时处理竞态条件 - Playwright 断言的设计方式是它们描述了最终需要满足的预期。\n就是这样！这些设计选择允许 Playwright 用户完全忘记他们测试中的不稳定超时和竞态检查。\n你将学到\n如何编写第一个测试 如何执行操作 如何使用断言 测试如何独立运行 如何使用测试钩子 第一个测试\r查看以下示例，了解如何编写测试。注意文件名遵循 test_ 前缀约定，以及每个测试名称。\ntest_example.py\nimport re from playwright.sync_api import Page, expect def test_has_title(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 期望标题“包含”一个子字符串。 expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) def test_get_started_link(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 点击“开始”链接。 page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() # 期望页面有一个名为“安装”的标题。 expect(page.get_by_role(\u0026#34;heading\u0026#34;, name=\u0026#34;Installation\u0026#34;)).to_be_visible() 操作\r导航\r大多数测试将从导航到 URL 的页面开始。之后，测试将能够与页面元素进行交互。\npage.goto(\u0026#34;https://playwright.dev/\u0026#34;) Playwright 会等待页面达到加载状态，然后再继续。了解更多关于 page.goto() 选项的信息。\n交互\r执行操作从定位元素开始。Playwright 使用 Locators API 进行此操作。定位器代表了在任何时刻在页面上查找元素（或元素组）的方式，了解更多关于可用的不同类型定位器的信息。Playwright 会在执行操作之前等待元素可操作，因此没有必要等待其变为可用。\n# 创建一个定位器。 get_started = page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;) # 点击它。 get_started.click() 在大多数情况下，它会写成一行：\npage.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() 基本操作\r这是最受欢迎的 Playwright 操作列表。请注意，还有更多操作，请确保查看定位器 API 部分以了解更多信息。\n操作 描述 locator.check() 检查输入复选框 locator.click() 点击元素 locator.uncheck() 取消检查输入复选框 locator.hover() 鼠标悬停在元素上 locator.fill() 填写表单字段，输入文本 locator.focus() 使元素获得焦点 locator.press() 按下单个键 locator.set_input_files() 选择上传的文件 locator.select_option() 在下拉菜单中选择选项 断言\rPlaywright 包括断言，这些断言会等待直到满足预期条件。使用这些断言可以使测试不脆弱且具有弹性。例如，这段代码会等待页面获得包含“Playwright”的标题：\nimport re from playwright.sync_api import expect expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) 这是最受欢迎的异步断言列表。请注意，还有更多断言需要熟悉：\n断言 描述 expect(locator).to_be_checked() 复选框被选中 expect(locator).to_be_enabled() 控件被启用 expect(locator).to_be_visible() 元素可见 expect(locator).to_contain_text() 元素包含文本 expect(locator).to_have_attribute() 元素具有属性 expect(locator).to_have_count() 元素列表具有给定长度 expect(locator).to_have_text() 元素匹配文本`` expect(locator).to_have_value() 输入元素具有值`` expect(page).to_have_title() 页面具有标题`` expect(page).to_have_url() 页面具有 URL 测试隔离\rPlaywright Pytest 插件基于测试夹具的概念，例如内置的页面夹具，它被传递到你的测试中。由于浏览器上下文，页面在测试之间是隔离的，这相当于一个全新的浏览器配置文件，每个测试都获得一个新鲜环境，即使多个测试在单个浏览器中运行。\ntest_example.py\nfrom playwright.sync_api import Page def test_example_test(page: Page): pass # “page”属于一个独立的 BrowserContext，为这个特定测试创建。 def test_another_test(page: Page): pass # 这个第二个测试中的“page”与第一个测试完全隔离。 使用夹具\r你可以使用各种夹具在测试之前或之后执行代码并共享对象。一个 function 作用域的夹具，例如带有 autouse 的，表现得像 beforeEach/afterEach。一个 module 作用域的夹具带有 autouse 表现得像 beforeAll/afterAll，它在所有测试之前和之后运行。\ntest_example.py\nimport pytest from playwright.sync_api import Page, expect @pytest.fixture(scope=\u0026#34;function\u0026#34;, autouse=True) def before_each_after_each(page: Page): print(\u0026#34;before the test runs\u0026#34;) # 在每个测试之前转到起始 URL。 page.goto(\u0026#34;https://playwright.dev/\u0026#34;) yield print(\u0026#34;after the test runs\u0026#34;) def test_main_navigation(page: Page): # 断言使用 expect API。 expect(page).to_have_url(\u0026#34;https://playwright.dev/\u0026#34;) 接下来是什么\r运行单个测试，多个测试，有头模式 使用 Codegen 生成测试 查看测试的跟踪 在 CI 上运行测试与 GitHub Actions 生成测试\r引言\rPlaywright 提供了开箱即用的测试生成能力，是快速开始测试的绝佳方式。它将打开两个窗口，一个浏览器窗口，您可以在其中与您想要测试的网站进行交互；另一个是 Playwright 检查器窗口，您可以在其中录制测试、复制测试、清除测试以及更改测试的语言。\n您将学到\n如何录制测试 如何生成定位器 运行 Codegen\r使用 codegen 命令运行测试生成器，然后是您想要为其生成测试的网站的 URL。URL 是可选的，您也可以在不指定 URL 的情况下运行命令，然后在浏览器窗口中直接添加 URL。\nplaywright codegen demo.playwright.dev/todomvc 录制测试\r运行 codegen 并在浏览器中执行操作。Playwright 将为用户交互生成代码。Codegen 将查看渲染后的页面并找出推荐的定位器，优先考虑角色、文本和测试 ID 定位器。如果生成器识别出多个元素与定位器匹配，它将改进定位器，使其更具弹性并唯一地识别目标元素，从而消除和减少由于定位器导致的测试失败和不稳定。\n使用测试生成器，您可以录制：\n通过简单地与页面交互，执行点击或填充等操作 通过点击工具栏上的一个图标，然后点击页面上的元素进行断言。您可以选择： 'assert visibility' 断言元素可见 'assert text' 断言元素包含特定文本 'assert value' 断言元素具有特定值 当您完成与页面的交互后，按下 'record' 按钮停止录制，并使用 'copy' 按钮将生成的代码复制到您的编辑器中。\n使用 'clear' 按钮清除代码以开始重新录制。完成后，关闭 Playwright 检查器窗口或停止终端命令。\n要了解更多关于生成测试的信息，请查看我们关于 Codegen 的详细指南。\n生成定位器\r您可以使用测试生成器生成定位器。\n按下 'Record' 按钮停止录制，\u0026lsquo;Pick Locator\u0026rsquo;` 按钮将会出现。 点击 'Pick Locator' 按钮，然后将鼠标悬停在浏览器窗口的元素上，以查看定位器在每个元素下方突出显示。 要选择一个定位器，单击您想要定位的元素，该定位器的代码将出现在 Pick Locator 按钮旁边的定位器游乐场中。 然后您可以在定位器游乐场中编辑定位器以微调它，并看到匹配的元素在浏览器窗口中突出显示。 使用复制按钮复制定位器并将其粘贴到您的代码中。 仿真\r您还可以使用仿真生成测试，以便为特定的视口、设备、颜色方案生成测试，以及模拟地理位置、语言或时区。测试生成器还可以在保持认证状态的同时生成测试。查看测试生成器指南以了解更多信息。\n接下来做什么\r查看您的测试跟踪 运行和调试\r引言\r您可以运行单个测试、一组测试或所有测试。使用 --browser 标志，可以在一个浏览器或多个浏览器上运行测试。默认情况下，测试以无头模式运行，这意味着在运行测试时不会打开浏览器窗口，结果将在终端中显示。如果您愿意，可以通过使用 --headed CLI 参数以有头模式运行您的测试。\n您将学到\n如何从命令行运行测试 如何调试测试 运行测试\r命令行\r要运行您的测试，请使用 pytest 命令。这将默认在 Chromium 浏览器上运行您的测试。默认情况下，测试以无头模式运行，这意味着在运行测试时不会打开浏览器窗口，结果将在终端中显示。\n在有头模式下运行测试\r要以有头模式运行您的测试，请使用 --headed 标志。这将在运行测试时打开浏览器窗口，并在完成后关闭浏览器窗口。\n在不同的浏览器上运行测试\r要指定您想要运行测试的浏览器，请使用 --browser 标志，后跟浏览器的名称。\n要指定要在多个浏览器上运行测试，请多次使用 --browser 标志，后跟每个浏览器的名称。\npytest --browser webkit --browser firefox 运行特定测试\r要运行单个测试文件，请传入您想要运行的测试文件的名称。\n要运行一组测试文件，请传入您想要运行的测试文件的名称。\npytest tests/test_todo_page.py tests/test_landing_page.py 要运行特定测试，请传入您想要运行的测试的函数名称。\npytest -k test_add_a_todo_item 并行运行测试\r要并行运行您的测试，请使用 --numprocesses 标志，后跟您想要运行测试的进程数量。我们建议使用逻辑 CPU 核心数的一半。\n（这假设已安装了 pytest-xdist。有关更多信息，请参见此处。）\n有关更多信息，请参见 Playwright Pytest 使用情况或 Pytest 文档以了解一般 CLI 使用情况。\n调试测试\r由于 Playwright 在 Python 中运行，您可以使用您选择的调试器进行调试，例如使用 Visual Studio Code 中的 Python 扩展。Playwright 带有 Playwright 检查器，允许您逐步执行 Playwright API 调用，查看它们的调试日志并探索定位器。\n要调试所有测试，请运行以下命令。\nBash PowerShell Batch 要调试一个测试文件，请在命令后运行您想要调试的测试文件的名称。\nBash PowerShell Batch PWDEBUG=1 pytest -s test_example.py 要调试特定测试，请添加 -k 后跟您想要调试的测试的名称。\nBash PowerShell Batch PWDEBUG=1 pytest -s -k test_get_started_link 此命令将打开浏览器窗口以及 Playwright 检查器。您可以使用检查器顶部的步过按钮逐步执行您的测试。或者按下播放按钮从开始到结束运行您的测试。一旦测试完成，浏览器窗口将关闭。\n在调试时，您可以使用选择定位器按钮来选择页面上的元素，并查看 Playwright 用于查找该元素的定位器。您还可以编辑定位器并实时在浏览器窗口中看到它被高亮显示。使用复制定位器按钮将定位器复制到剪贴板，然后将其粘贴到您的测试中。\n查看我们的调试指南，以了解更多关于 Playwright 检查器以及使用浏览器开发工具进行调试的信息。\n接下来做什么\r使用 Codegen 生成测试 查看您的测试跟踪 在 CI 上使用 GitHub Actions 运行您的测试 跟踪查看器\r介绍\rPlaywright Trace Viewer 是一个图形用户界面（GUI）工具，允许您探索录制的 Playwright 测试跟踪，这意味着您可以前后浏览测试的每个动作，并直观地看到每个动作期间发生了什么。\n您将学到\n如何录制跟踪 如何打开 HTML 报告 如何打开跟踪查看器 录制跟踪\r可以通过使用 --tracing 标志运行测试来录制跟踪。\n跟踪的选项有：\non: 为每个测试录制跟踪 off: 不录制跟踪。（默认） retain-on-failure: 为每个测试录制跟踪，但删除成功测试运行的所有跟踪。 这将录制跟踪并将其放入 test-results 目录中名为 trace.zip 的文件中。\n如果您没有使用 Pytest，请点击这里了解如何录制跟踪。\n同步 异步 browser = chromium.launch() context = browser.new_context() # 在创建/导航页面之前开始跟踪。 context.tracing.start(screenshots=True, snapshots=True, sources=True) page = context.new_page() page.goto(\u0026#34;https://playwright.dev\u0026#34;) # 停止跟踪并将其导出到 zip 归档中。 context.tracing.stop(path=\u0026#34;trace.zip\u0026#34;) 打开跟踪\r您可以使用 Playwright CLI 或在 trace.playwright.dev 上的浏览器中打开保存的跟踪。确保添加您的 trace.zip 文件所在的完整路径。这应该包括 test-results 目录，然后是测试名称，最后是 trace.zip。\nplaywright show-trace trace.zip 查看跟踪\r通过点击每个动作或使用时间线悬停来查看测试的跟踪，并查看动作前后页面的状态。在测试的每个步骤期间检查日志、源代码和网络。跟踪查看器创建了一个 DOM 快照，因此您可以完全与之交互，打开开发工具等。\n要了解更多信息，请查看我们关于跟踪查看器的详细指南。\n接下来是什么\r在 GitHub Actions 上运行 CI 测试 了解更多关于跟踪查看器的信息 Pytest 插件来编写端到端测试\r引言\rPlaywright 提供了一个 Pytest 插件来编写端到端测试。要开始使用它，请参考入门指南。\n使用方法\r要运行测试，请使用 Pytest 命令行界面。\npytest --browser webkit --headed 如果你想自动添加命令行参数而不需要明确指定它们，你可以使用 pytest.ini 文件：\n# pytest.ini 文件的内容 [pytest] # 使用 UI 运行 firefox addopts = --headed --browser firefox 命令行参数\r请注意，命令行参数仅应用于默认的 browser、context 和 page 固定装置。如果你使用 API 调用如 browser.new_context() 创建浏览器、上下文或页面，命令行参数将不会应用。\n--headed：以有头模式运行测试（默认：无头）。 --browser：在不同的浏览器中运行测试 chromium、firefox 或 webkit。可以多次指定（默认：chromium）。 --browser-channel：要使用的浏览器渠道。 --slowmo：通过指定的毫秒数减慢 Playwright 操作。这样你可以看清楚发生了什么（默认：0）。 --device：要模拟的设备。 --output：由测试产生的工件目录（默认：test-results）。 --tracing：是否为每个测试记录跟踪。on、off 或 retain-on-failure（默认：off）。 --video：是否为每个测试录制视频。on、off 或 retain-on-failure（默认：off）。 --screenshot：是否在每个测试后自动捕获屏幕截图。on、off 或 only-on-failure（默认：off）。 --full-page-screenshot：在失败时是否拍摄整个页面的屏幕截图。默认情况下，只捕获视口。需要启用 --screenshot（默认：off）。 固定装置\r这个插件为 pytest 配置了 Playwright 特定的固定装置。要使用这些固定装置，将固定装置名称作为参数传递给测试函数。\ndef test_my_app_is_working(fixture_name): pass # 使用 fixture_name 进行测试 # ... 函数范围 ：当在测试函数中请求时，这些固定装置被创建，并在测试结束时销毁。\ncontext：测试的新浏览器上下文。 page：测试的新浏览器页面。 new_context：允许为测试创建不同的浏览器上下文。适用于多用户场景。接受与 browser.new_context() 相同的参数。 会话范围 ：当在测试函数中请求时，这些固定装置被创建，并在所有测试结束时销毁。\nplaywright：Playwright 实例。 browser_type：当前浏览器的 BrowserType 实例。 browser：由 Playwright 启动的浏览器实例。 browser_name：浏览器名称字符串。 browser_channel：浏览器渠道字符串。 is_chromium、is_webkit、is_firefox：相应浏览器类型的布尔值。 自定义固定装置选项 ：对于 browser 和 context 固定装置，使用以下固定装置定义自定义启动选项。\nbrowser_type_launch_args：覆盖 browser_type.launch() 的启动参数。它应该返回一个字典。 browser_context_args：覆盖 browser.new_context() 的选项。它应该返回一个字典。 也可以通过使用 browser_context_args 标记来覆盖单个测试的上下文选项（browser.new_context()）：\nimport pytest @pytest.mark.browser_context_args(timezone_id=\u0026#34;Europe/Berlin\u0026#34;, locale=\u0026#34;en-GB\u0026#34;) def test_browser_context_args(page): assert page.evaluate(\u0026#34;window.navigator.userAgent\u0026#34;) == \u0026#34;Europe/Berlin\u0026#34; assert page.evaluate(\u0026#34;window.navigator.languages\u0026#34;) == [\u0026#34;de-DE\u0026#34;] 并行性：同时运行多个测试\r如果你的测试在拥有大量 CPU 的机器上运行，你可以通过使用 pytest-xdist 同时运行多个测试来加快测试套件的整体执行时间：\n# 安装依赖 pip install pytest-xdist # 使用 --numprocesses 标志 pytest --numprocesses auto 根据硬件和测试的性质，你可以将 numprocesses 设置为从 2 到机器上的 CPU 数量。如果设置得太高，你可能会注意到意外的行为。\n有关 pytest 选项的一般信息，请参见运行测试。\n示例\r为自动补全配置 Mypy 类型\rtest_my_application.py\nfrom playwright.sync_api import Page def test_visit_admin_dashboard(page: Page): page.goto(\u0026#34;/admin\u0026#34;) # ... 配置慢动作\r使用 --slowmo 参数运行测试。\n将 Playwright 操作减慢 100 毫秒。\n按浏览器跳过测试\rtest_my_application.py\nimport pytest @pytest.mark.skip_browser(\u0026#34;firefox\u0026#34;) def test_visit_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) # ... 在特定浏览器上运行\rconftest.py\nimport pytest @pytest.mark.only_browser(\u0026#34;chromium\u0026#34;) def test_visit_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) # ... 使用自定义浏览器渠道，如 Google Chrome 或 Microsoft Edge\rpytest --browser-channel chrome test_my_application.py\ndef test_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) 配置基础 URL\r使用 base-url 参数启动 Pytest。pytest-base-url 插件用于此目的，它允许你从配置、命令行参数或固定装置中设置基础 URL。\npytest --base-url http://localhost:8080 test_my_application.py\ndef test_visit_example(page): page.goto(\u0026#34;/admin\u0026#34;) # -\u0026gt; 将导致 http://localhost:8080/admin 忽略 HTTPS 错误\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args): return { **browser_context_args, \u0026#34;ignore_https_errors\u0026#34;: True } 使用自定义视口大小\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args): return { **browser_context_args, \u0026#34;viewport\u0026#34;: { \u0026#34;width\u0026#34;: 1920, \u0026#34;height\u0026#34;: 1080, } } 设备模拟\rconftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args, playwright): iphone_11 = playwright.devices[\u0026#39;iPhone 11 Pro\u0026#39;] return { **browser_context_args, **iphone_11, } 或通过命令行 --device=\u0026quot;iPhone 11 Pro\u0026quot;。\n与 unittest.TestCase 一起使用\r查看以下示例，了解如何将其与 unittest.TestCase 一起使用。这有一个限制，即只能指定单个浏览器，并且在指定多个浏览器时不会生成多个浏览器的矩阵。\nimport pytest import unittest from playwright.sync_api import Page class MyTest(unittest.TestCase): @pytest.fixture(autouse=True) def setup(self, page: Page): self.page = page def test_foobar(self): self.page.goto(\u0026#34;https://microsoft.com\u0026#34;) self.page.locator(\u0026#34;#foobar\u0026#34;).click() assert self.page.evaluate(\u0026#34;1 + 1\u0026#34;) == 2 调试\r与 pdb 一起使用\r在你的测试代码中使用 breakpoint() 语句来暂停执行并获得 pdb REPL。\ndef test_bing_is_working(page): page.goto(\u0026#34;https://bing.com\u0026#34;) breakpoint() # ... 部署到 CI\r请参阅 CI 提供商的指南，了解如何将你的测试部署到 CI/CD。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/pytest-intro/",
    "title": "pytest-intro",
    
    "content": "\r什么是pytest？\rpytest是一个功能强大且易于使用的Python测试框架。它可以帮助开发者编写简洁、可读性强的测试代码，并提供丰富的插件支持。\npytest的主要特点\r简洁的测试用例编写方式 自动发现测试用例 支持参数化测试 强大的断言功能 丰富的插件生态系统 安装pytest\r使用以下命令安装pytest：\npip install pytest 编写测试用例\r一个简单的pytest测试用例如下：\ndef test_addition(): assert 1 + 1 == 2 def test_subtraction(): assert 2 - 1 == 1 运行测试\r使用以下命令运行pytest测试：\npytest 参数化测试\rpytest支持参数化测试，可以使用@pytest.mark.parametrize装饰器：\nimport pytest @pytest.mark.parametrize(\u0026#34;test_input,expected\u0026#34;, [ (\u0026#34;3+5\u0026#34;, 8), (\u0026#34;2+4\u0026#34;, 6), (\u0026#34;6*9\u0026#34;, 42), ]) def test_eval(test_input, expected): assert eval(test_input) == expected 总结\rpytest是一个功能强大且易于使用的Python测试框架，可以帮助开发者编写简洁、可读性强的测试代码。通过本指南，您已经了解了pytest的基本使用方法，接下来可以探索更多高级功能。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/pytest%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88/",
    "title": "pytest接口自动化测试方案",
    
    "content": "\r背景\r当前业务核心聚焦于 POCT 领域，设备购买和设备使用等关键功能，已成为测试工作的重点保障对象，但随着系统复杂度的提升,手工的回归测试工作很难全面覆盖。为了确保关键业务功能的质量稳定性，有必要引入自动化测试，增加测试覆盖范围，降低已有功能漏测的风险，提前发现问题。\n目标\r短期目标：接入自动化测试（截至3月底）\n前期准备工作 预研不同的自动化测试框架，结合中长期目标与现实情况及各个框架的优缺点选择一套合适的自动化框架 对比几款常见接口测试框架 初步选定：pytest + Requests 语法简洁容易上手-接入成本低 灵活，社区支持好，插件丰富-适合复杂测试场景 制定初步的方案 自动化项目方案 项目框架搭建 确定实施方案 测试人员小范围接入自动化项目（跑通流程） 三月底能够将三款新设备正向检测流程转化为自动化测试脚本 **将慢病设备下单-上传检测结果流程；快速检测单流程接入接口自动化测试（正向检测流程） **将免疫、血球设备下单-上传检测结果（正向检测流程） 中期目标 ：自动化项目应用到测试工作流程（截至6月底）\n覆盖三款新设备装机到检测使用的全部场景\n覆盖设备装机到检测过程中的各项操作步骤和关键节点，从设备初始化到实际检测，确保各环节功能正常，数据交互准确，为用户提供稳定可靠的设备使用体验（包括异常流程）。 将自动化流程应用到测试工作流程。\n能有效增加测试覆盖率，减少漏测风险。 脚本的维护流程\n在接口变更，需求功能更改后如何维护 运行失败用例如何维护 长期目标：不断完善接口自动化，有效应用到研发测试工作流程（截至12月底）\n完善涉及用户相关的功能的自动化测试覆盖 对从商城购买到设备装机、检测、报告生成打印及检测后的慢病管理，全流程自动化测试，保障用户使用系统过程中的顺畅性，避免因流程问题导致的交易失败或用户体验不佳情况。 将自动化测试无缝应用到现有的研发测试工作流程中。 替代大部分回归测试，提高测试效率，进一步减少漏测风险。 自动化测试成为常态化测试手段,能提前发现问题,有效提升整体工作效率。 自动化测试工具选型\r自动化测试框架-pytest + Requests 几款常见接口测试框架对比详情：\npytest + Requests\n语法简洁容易上手-接入成本低 灵活，社区支持好，插件丰富-适合复杂测试场景 已有相关基础 选型依据 兼容性、适合复杂流程交互（设备交互）、丰富的社区支持、接入成本\n测试管理工具（飞书或tapd） 自动化用例管理接口自动化测试用例 CI/CD工具 GitLab CI uvicorn+fastapi 部署+接口 自动化测试用例设计\r用例分层设计 基础类（/api） 根据接口文档生成 测试用例（/tests） 基础功能用例（原子级-单个接口测试） 定义 ：针对单个接口的独立测试，关注接口的输入输出正确性、异常处理能力及边界条件验证。例如，用户登录接口的独立测试需覆盖正常登录、密码错误、账号不存在等场景 特点 ： 原子性 ：每个用例仅验证一个接口的单一功能，不依赖其他接口或业务流程。 高复用性 ：可作为其他复杂用例的构建单元，例如登录接口的测试结果可被后续业务流程用例复用 技术实现 ：通常结合数据驱动设计（如参数化测试数据），通过多组输入数据覆盖等价类和边界值 业务流程用例（端到端、涉及多个接口和流程的测试） 定义 ：模拟真实用户操作路径，串联多个接口验证端到端业务逻辑。例如“创建商品→创建优惠券→创建活动→下单支付”的全流程测试 特点 ： 场景化 ：基于用户使用的功能场景设计，关注接口间的数据传递与状态流转。 风险覆盖 ：重点验证流程中的关键节点（如订单状态变更、库存扣减）和异常分支（如支付超时回滚） 依赖管理 ：通过关键字驱动设计（如“获取Token”“查询订单状态”）复用基础功能用例，降低冗余代码 测试数据（/data） 存放测试数据 提供测试数据的脚本 工具(/utils) 工具类集合 数据驱动设计 参数化测试数据（Excel、csv、数据库）\n关键字驱动设计 可复用的关键字库（如获取token、查询）\n测试执行策略\r触发条件 开发人员提交代码触发\n手动触发\n优先级划分(暂不考虑) 高（核心功能）、中（高频场景）\n失败重试机制 自动重试与日志记录\n** 持续集成（CI/CD）**\r集成流程 代码提交 → 静态检查 → 单元测试 → 自动化测试 → 报告生成 流水线配置 GitLab CI YAML配置 结果通知 企业微信群通知 风险管理\r潜在风险 环境不稳定 脚本维护成本 需求功能变更 应对措施 设计时需要提前考虑脚本稳定性 定期维护脚本 运行前保证环境正常可用 相关交付物\r测试报告 HTML报告 自动化脚本 代码仓库https://gitlab.guangpuyun.cn/clinic-diag/test/poct_api_test\n项目结构\n文档 初始化文档快速编写Pytest接口测试 自动化用例设计文档接口自动化测试用例 维护与优化\r脚本维护人员 一般情况下谁写的谁维护 脚本维护方法 接口变更的处理 用例执行/定时/手动触发脚本爬取接口文档，并与最新接口文档对比\n运行main.py 执行用例时，会在warnning日志提醒相关变更 检查变更是否涉及已经编写的用例（快捷键ctrl+shift+f搜索关键词即可） 如：PoctCreateOrderInModel存在差异，对应json文档中找到对应 operationId（文件名），在用例文档中搜索createOrder2UsingPOST_1 ，发现涉及已有用例。\n若有涉及用例，则维护成最新接口信息。\n当用例运行报错/不通过进行定位 bug-\u0026gt;记录并通知开发修复； 数据问题-\u0026gt;使用自动化专用的数据，避免污染； 脚本本身不稳定导致的运行失败，维护脚本能稳定运行，若维护成功过高可直接先注释脚本，并在对应用例做好备注“待维护”。 脚本维护代办事项 接口自动化代办事项 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E9%9D%9E%E5%90%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E8%B0%83%E7%94%A8%E6%8A%A5%E9%94%99/",
    "title": "python非同级目录调用报错",
    
    "content": "\r项目结构：\r问题：\r执行文件调用dir1，间接调用dir2。执行时报错：“ModuleNotFoundError: No module named \u0026lsquo;dir1.dir2\u0026rsquo;;”\n解决方法：\rdir1文件导包时做处理。\n主函数加入这四行，将项目的根目录(webapp)的路径加入到系统PATH中； import os,sys\nfrom pathlib import Path\nsys.path[0] = str(Path(sys.path[0]).parent.parent)\nsys.path.append(os.getcwd())\n且导包从项目执行入口文件同级开始写\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E4%B8%AD%E7%9A%84os%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/",
    "title": "python中的os函数用法",
    
    "content": " title: \u0026ldquo;python的os模块使用\u0026rdquo;\ncategories: [\u0026ldquo;技术\u0026rdquo;, \u0026ldquo;编程\u0026rdquo;, \u0026ldquo;python\u0026rdquo;] date: 2025-03-20T12:59:32+08:00\ndraft: false\ntags: [\u0026ldquo;os\u0026rdquo;, \u0026ldquo;python\u0026rdquo;, \u0026ldquo;教程\u0026rdquo;]\ros.listdir(path) 获取文件夹下全部文件，的列表 os.path.join(path1,path2) 将路径path1和路径path2拼接成新的路径，path1//path2 base_dir = os.path.dirname(os.path.abspath(file)) 获取当前文件的绝对路径 input_file = os.path.join(base_dir, \u0026quot;../resource/swaggerApi/clinic-ysb-app_OpenAPI.json\u0026quot;) ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/scrapy%E7%88%AC%E6%9F%9A%E5%AD%90%E7%BD%91%E7%A4%BA%E4%BE%8B/",
    "title": "scrapy爬柚子网示例",
    
    "content": "柚子网https://www.uu-zz.com/\n爬取页码\n遍历页面内对应的视频集的链接\n遍历视频内子视频链接\n!\nhttps://www.uu-zz.com/+子视频链接，发送get请求\n!\n获得m3u8文件，储存在数据库\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/scripts-readme/",
    "title": "scripts-readme",
    
    "content": "\r笔记管理自动化工具\r本目录包含多个自动化脚本，用于简化笔记仓库的管理和同步。\n📋 脚本列表\r1. sync-notes-pull.sh\r功能：从独立笔记仓库同步到主项目 用法：\n./sync-notes-pull.sh 说明：\n必须在 Hugo 项目根目录运行 自动执行 git subtree pull 操作 将笔记仓库的最新更改拉取到主项目的 content/post 目录 2. sync-notes-push.sh\r功能：将主项目笔记更改推送到独立仓库 用法：\n./sync-notes-push.sh 说明：\n必须在 Hugo 项目根目录运行 自动执行 git subtree push 操作 将主项目中 content/post 的更改推送到独立笔记仓库 运行前会检查是否有未提交的更改 3. add-hugo-frontmatter.sh\r功能：为 Markdown 文件自动添加 Hugo Front Matter 用法：\n# 处理单个文件 ./add-hugo-frontmatter.sh path/to/file.md # 处理整个目录 ./add-hugo-frontmatter.sh path/to/directory # 处理当前目录下所有 .md 文件 ./add-hugo-frontmatter.sh 说明：\n自动检测文件是否已有 Hugo 头 提取文件第一行作为标题（去除 # 符号） 如果第一行为空，使用文件名作为标题 自动设置当前时间为 date 和 lastmod 默认分类为 [\u0026quot;技术\u0026quot;] 4. push-to-github.sh\r功能：将笔记仓库推送到 GitHub 用法：\n./push-to-github.sh \u0026lt;repository-url\u0026gt; 示例：\n./push-to-github.sh git@github.com:yourname/knowledge-bases.git 说明：\n自动添加远程源 origin 自动提交未提交的更改 推送到 GitHub 并设置上游分支 🚀 完整工作流程\r1. 首次设置\r# 创建 GitHub 仓库后 ./push-to-github.sh git@github.com:yourname/knowledge-bases.git 2. 日常使用\r在笔记仓库中编辑：\ncd C:/Users/tian4/knowledge_bases # 编辑文件 git add . git commit -m \u0026#34;更新笔记\u0026#34; 同步到主项目：\ncd E:/code/golang/hugo/bluespace3.github.io ./sync-notes-pull.sh 从主项目推送更改：\n./sync-notes-push.sh 3. 为新文件添加 Hugo 头\r# 在笔记仓库中 cd C:/Users/tian4/knowledge_bases ./add-hugo-frontmatter.sh # 处理所有文件 ./add-hugo-frontmatter.sh 新文件.md # 处理单个文件 ⚠️ 注意事项\r运行环境：所有脚本都需要在 Git Bash 或支持 bash 的环境中运行 权限问题：确保脚本有执行权限（chmod +x script.sh） 路径问题：Windows 路径使用正斜杠 / 而非反斜杠 \\ Git 配置：确保已配置 Git 用户名和邮箱 🐛 故障排除\r错误：请在 Hugo 项目根目录运行此脚本\r确保在包含 hugo.toml 文件的目录中运行脚本。\n错误：笔记仓库目录不存在\r检查路径是否正确：C:/Users/tian4/knowledge_bases\n错误：检测到未提交的更改\r在运行 sync-notes-push.sh 前，先提交所有更改：\ngit add . git commit -m \u0026#34;提交更改\u0026#34; 错误：权限被拒绝\r确保脚本有执行权限：\nchmod +x script.sh 🎯 最佳实践\r定期同步：建议定期运行 ./sync-notes-pull.sh 保持主项目更新 Hugo 头规范：新添加的笔记文件记得运行 ./add-hugo-frontmatter.sh GitHub 备份：定期运行 git push origin master 备份到 GitHub 分支管理：对于重大更改，建议创建功能分支而非直接在 master 上操作 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/quant_trading/strategy/",
    "title": "strategy",
    
    "content": "\r量化交易策略知识库\r核心策略\r本系统采用多因子综合评分策略，结合技术面、基本面和消息面分析。\n技术面分析指标\rMACD指标：判断趋势转折点 RSI指标：判断超买超卖状态 KDJ指标：判断股价趋势 布林带：判断价格波动区间 成交量分析：确认价格变动的有效性 基本面分析要素\r财务指标分析：盈利能力、偿债能力、运营能力 行业地位评估：市场份额、竞争优势 盈利能力评估：营收增长、利润增长 消息面分析方法\r新闻情感分析：判断市场情绪 政策影响评估：分析政策对行业的影响 市场情绪监控：跟踪市场热点和资金流向 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/quant_trading/system_design/",
    "title": "SYSTEM_DESIGN",
    
    "content": "\r系统设计与开发者文档\r本文档为量化交易系统的核心开发者提供全面的技术参考，涵盖了系统架构、核心模块、API接口、部署运维以及未来的发展规划。\n1. 系统架构\r本系统采用模块化设计，主要由数据层、分析层、策略层和应用层组成。\n1.1. 核心模块\rmain.py: 自选股分析流程的入口。 recommendation_system.py: AI智能推荐流程的入口。 health_check.py: Flask应用的入口，提供 /health 和 /run API端点。 src/: 包含所有核心逻辑的目录。 config.py: 集中管理所有配置。 data_loader.py (DataLoader): 负责从akshare获取数据并存入数据库。 db.py (DatabaseManager): 管理SQLite数据库。 analysis_engine.py (AnalysisEngine): 负责计算技术指标。 gemini_analyzer.py (GeminiAnalyzer): 与Gemini API交互，进行AI分析。 strategy_engine.py (StrategyEngine): 核心策略模块，汇总分析并生成信号。 market_regime.py (MarketRegime): 判断市场宏观状态（牛/熊/震荡）。 logger.py: 提供统一的日志服务。 send_email.py: 生成HTML邮件报告并发送。 1.2. 数据流\r数据获取: DataLoader 从 akshare 获取数据。 数据存储: DatabaseManager 将数据存入SQLite数据库 (data/stock_data.db)。 市场状态判断: MarketRegime 分析市场指数，确定宏观环境。 技术分析: AnalysisEngine 基于历史数据计算技术指标。 AI分析: GeminiAnalyzer 调用Gemini API获取基本面和消息面分析。 策略决策: StrategyEngine 结合所有分析结果，并根据市场状态动态调整权重，生成最终决策。 结果输出: 通过日志、邮件 (send_email.py) 和API (health_check.py) 输出。 2. 策略、评分与决策体系 (V3)\r本量化交易系统的核心决策逻辑，通过对技术面、基本面和AI市场情绪面三个维度进行独立的量化评分，并结合市场状态动态加权，最终生成交易信号。\n2.0. A股总分计算逻辑\r对于A股，系统采用动态加权模型计算总分，取代了旧版的简单分数相加。\n分数归一化: 将技术面（满分50）、基本面（满分35）、情绪面（满分25）的原始得分，分别归一化到 [-1, 1] 的区间内。 应用动态权重: 根据当前市场状态（波动率、成交量）计算出动态权重（例如，趋势行情下技术面权重更高），然后对归一化后的分数进行加权求和。 映射回百分制: 将加权后的分数重新映射回 [-100, 100] 的范围，作为最终总分。 动态权重调整\r系统会根据市场的微观状态（通过ATR判断的波动率和通过均量线判断的成交量）对基础权重进行动态微调：\n高波动 \u0026amp; 放量 (趋势行情): 提升技术面权重，降低基本面和情绪面权重。 低波动 \u0026amp; 缩量 (盘整行情): 降低技术面权重，提升基本面权重。 最终决策阈值\r坚定买入: 总分 \u0026gt;= 40 推荐买入: 总分 \u0026gt;= 30 维持仓位: 总分 \u0026gt;= 20 谨慎持有: 总分 \u0026gt; -5 推荐卖出: 总分 \u0026gt; -20 坚定卖出: 总分 \u0026lt;= -20 2.1. ETF评分体系（指数基金/ETF专用）\r技术面：50分（均线、成交量、波动率等为主，弱化KDJ等短线指标） AI消息面：50分（重点关注资金流向、申购赎回、行业轮动、指数调整等） 基本面：恒为0分（ETF不参与基本面打分） 总分 = 技术面得分（归一化到50分） + AI消息面得分（归一化到50分）\n归一化方法：技术面满分已更新为50分，因此不再需要额外乘区。AI消息面原始得分(满分10) / 10 * 50。 ETF决策流程与A股一致，但分数分布和信号解释更侧重资金流和行业轮动。 2.2. 技术面分析 (V3, 总分: 50分)\r技术面分析旨在捕捉市场的短期趋势和动量。它由五个核心指标构成，各自有独立的评分和权重。\n指标 权重 触发条件 (优先级由上到下) 得分 MACD趋势 15分 看涨金叉 (DIF上穿DEA，且DIF\u0026gt;0) +15 看跌死叉 (DIF下穿DEA，且DIF\u0026lt;0) -15 多头排列 (DIF\u0026gt;DEA) +8 空头排列 (DIF\u0026lt;DEA) -8 RSI动量 10分 RSI上穿50中轴 (强动量信号) +10 RSI下穿50中轴 (强动量信号) -10 RSI \u0026lt; 30 (超卖区) +8 RSI \u0026gt; 70 (超买区) -8 RSI \u0026lt; 40 (偏弱) +4 RSI \u0026gt; 60 (偏强) -4 布林带 8分 价格触及下轨 +8 价格触及上轨 -8 价格在中轨下方 +3 价格在中轨上方 -3 KDJ指标 7分 KDJ超卖 (K\u0026lt;20, D\u0026lt;20) +7 KDJ超买 (K\u0026gt;80, D\u0026gt;80) -7 KDJ金叉 (K\u0026gt;D) +3 KDJ死叉 (K\u0026lt;D) -3 成交量 10分 趋势显著放量 (MA5 \u0026gt; MA20*1.2) +5 趋势温和放量 (MA5 \u0026gt; MA20) +2 趋势显著缩量 (MA5 \u0026lt; MA20*0.8) -5 当日巨量 (Vol \u0026gt; MA20*2.0) +5 当日放量 (Vol \u0026gt; MA20*1.5) +2 最终报告形式: 技术面得分: [总分] | 原因: [综合原因] (MACD: [得分], RSI: [得分], 布林带: [得分], KDJ: [得分], 成交量: [得分])\n2.3. 基本面分析 (总权重: 35分)\r基本面分析旨在评估资产的内在价值。它由三个核心估值指标构成，以适应不同类型的投资标的。\n1. 市盈率 (PE) - (权重: 15分)\r数据来源: Akshare实时接口。对于ETF，则自动获取其跟踪指数的PE。 评分标准: PE \u0026lt; 15: +15分 (估值低) 15 \u0026lt;= PE \u0026lt; 30: +8分 (估值合理) 30 \u0026lt;= PE \u0026lt; 50: -8分 (估值偏高) PE \u0026gt;= 50: -15分 (估值过高) 2. 市净率 (PB) - (权重: 12分)\r数据来源: Akshare实时接口。对于ETF，则自动获取其跟踪指数的PB。 评分标准: PB \u0026lt; 1.5: +12分 (估值低) 1.5 \u0026lt;= PB \u0026lt; 3: +6分 (估值合理) 3 \u0026lt;= PB \u0026lt; 5: -6分 (估值偏高) PB \u0026gt;= 5: -12分 (估值过高) 3. 股息率 (Dividend Yield) - (权重: 8分)\r数据来源: Akshare实时接口。 评分标准: 股息率 \u0026gt; 4%: +8分 (高股息) 2% \u0026lt; 股息率 \u0026lt;= 4%: +4分 (股息尚可) 股息率 \u0026lt;= 2%: -8分 (股息较低) 评分平衡性: 正向分数总和 = 负向分数总和 = 35分\n正向: 15 + 12 + 8 = 35分 负向: (-15) + (-12) + (-8) = -35分 最终报告形式: 基本面得分: [总分] | 原因: [综合原因] (PE: [得分], PB: [得分], DY: [得分])\n2.4. AI市场情绪面分析 (总权重: 25分)\r本部分利用Gemini的联网搜索和分析能力，对最新的市场新闻和公告进行情绪量化。\n执行方式: 向Gemini API发送一个包含股票名称和代码的Prompt。\n返回格式: 要求Gemini返回一个包含以下字段的JSON对象：\nsentiment_score: 一个从 -10 (极度利空) 到 +10 (极度利好) 的量化分数。 sentiment_reason: 一句话总结的核心判断原因。 key_factors: 1-3个影响判断的关键事件列表。 data_date: 关键信息的最新日期。 分数换算: Gemini返回的 sentiment_score将乘以 2.5，以匹配本项 25分 的总权重。\n最终报告形式: AI消息面得分: [总分] | 原因: [AI总结的原因] (数据更新至: [日期]) 关键因素: [AI识别的关键事件]\n2.7. 实现状态与验证\r状态: 已完成 (As of 2025-08-17)\n技术面评分 (V3, 2.2节): strategy_engine.py 中的逻辑已通过 _calculate_technical_score 函数完全实现，并通过 tests/test_scoring_logic.py 中的 test_technical_scoring_detailed 单元测试验证。V3版更新了RSI趋势判断和成交量评分体系。 动态权重与总分计算: A股的动态加权和总分计算逻辑已在 _get_dynamic_weights 和 _calculate_score 中实现，并通过 test_dynamic_weight_adjustment 和 test_calculate_score_with_dynamic_weights 验证。 基本面评分 (2.3节): strategy_engine.py 中的逻辑已通过 _calculate_fundamental_score 函数完全实现，并通过 tests/test_fundamental_scoring.py 单元测试验证。 核心评分逻辑已实现模块化，与本文档描述的设计完全对齐。\n2.5. 新增技术指标\r系统现已支持更多A股常用的技术指标：\n1. 布林带 (Bollinger Bands)\r计算方式: 20日移动平均线 ± 2倍标准差 应用: 判断价格波动区间和超买超卖状态 2. KDJ指标\r计算方式: 基于9日RSV的随机指标 应用: 判断超买超卖和买卖时机 3. 成交量指标\r计算方式: 5日和10日成交量移动平均 应用: 分析量价关系和资金流向 4. ATR (平均真实波幅)\r计算方式: 14日真实波幅移动平均 应用: 衡量市场波动性和设置止损位 5. 威廉指标 (Williams %R)\r计算方式: 基于14日最高最低价的动量指标 应用: 判断超买超卖状态 2.6. 最终决策报告与日志\r系统在完成对所有股票的分析后，会生成一份聚合的决策报告表格，清晰地展示所有目标的分析结果。\n1. 单只股票分析过程输出\r在分析过程中，系统会为每只股票打印一行简要的完成信息，如下所示：\n--- 正在分析股票: 贵州茅台 (600519.SH) --- 分析完成: 贵州茅台 (600519.SH) - 总分: 65 | 最终信号: 【买入】 ---------------------------------------- 2. 最终聚合报告\r所有股票分析完成后，系统会打印一个统一的表格，汇总所有决策报告，方便横向对比。\n聚合报告表示例:\n股票名称 | 代码 | 技术面得分 | 基本面得分 | AI消息面得分 | 总分 | 最终决策 | 类型 ------------------------------------------------------------------------------------------------------------------ 贵州茅台 | 600519.SH | -5 | 17 | -8 | 4 | 【谨慎持有】 | A股 平安银行 | 000001.SZ | 25 | 15 | 12 | 52 | 【买入】 | A股 沪深300ETF | 510300.SH | 32 | 0 | 30 | 62 | 【买入】 | ETF 3. 决策等级说明\r重仓买入 (紫色): 总分 \u0026gt;= 80，强烈推荐买入信号 买入 (绿色): 总分 \u0026gt;= 60，推荐买入信号 持有 (黄色): 总分 \u0026gt;= 20，建议持有观望 谨慎持有 (青色): 总分 \u0026gt;= -10，建议谨慎持有或减仓 卖出 (红色): 总分 \u0026lt; -10，建议卖出信号 ETF决策等级说明\r重仓买入：总分 ≥ 80 买入：总分 ≥ 50 持有：总分 ≥ 30 谨慎持有：总分 ≥ 10 卖出：总分 \u0026lt; 10 注：ETF波动性低，建议结合资金流向和行业轮动信号综合判断。\n4. 日志文件\r对于有明确 买入/重仓买入 或 卖出 信号的股票，详细的决策依据会被记录在 logs/trade_signals_YYYY-MM-DD.log 文件中，供后续复盘。\n日志格式示例:\nSignal for 贵州茅台 (600519.SH) on 2025-01-13: 【买入】 - Tech: 15 (MACD看涨金叉, RSI(45.2)偏弱) (MACD: 15, RSI: 5, 布林带: 3, KDJ: -3) - Fundamentals: 17 (PE: PE=25.30, 估值合理, PB: PB=8.50, 估值过高, 股息率: 股息率=1.20%, 股息较低) (PE: 8, PB: -8, DY: 0) - AI Sentiment: -8 (市场情绪偏谨慎) (Data until: 2025-01-13) 关键因素: 白酒行业政策调整, 消费需求变化 - TOTAL SCORE: 24 ETF决策报告示例\r--- 正在分析ETF: 沪深300ETF (510300.SH) --- 分析完成: 沪深300ETF (510300.SH) - 总分: 62 | 最终信号: 【买入】 - 技术面: 32（均线多头排列，成交量放大） - 基本面: 0（ETF不参与基本面打分） - AI消息面: 30（资金净流入，行业轮动利好） ---------------------------------------- 3. API接口说明\r服务启动后，可以通过HTTP请求与系统交互。\n3.1. 健康检查\rEndpoint: GET /health 功能: 检查服务是否正常运行。 返回: {\u0026quot;status\u0026quot;: \u0026quot;ok\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;service is healthy\u0026quot;} 3.2. 触发分析任务\rEndpoint: GET /run 功能: 触发一次完整的分析流程。 查询参数: codes (可选, string): 指定一个或多个股票代码（用逗号分隔），仅分析这些股票。如果未提供，则执行“自选股+AI推荐”的完整流程。 请求示例: 触发完整流程: curl \u0026quot;http://127.0.0.1:5000/run\u0026quot; 分析指定股票: curl \u0026quot;http://127.0.0.1:5000/run?codes=600519.SH,000001.SZ\u0026quot; 返回: 成功时返回分析结果的JSON。 失败时返回 {\u0026quot;status\u0026quot;: \u0026quot;fail\u0026quot;, \u0026quot;msg\u0026quot;: \u0026quot;错误信息\u0026quot;}。 4. 配置说明\r所有配置项均位于 src/config.py，并支持通过环境变量覆盖。\n核心配置: GEMINI_API_KEY: Gemini的API密钥。 STOCK_POOL: 自选股股票池。 ETF_TO_INDEX_MAP: ETF与对应指数的映射。 邮件配置: ENABLE_EMAIL_SENDING: 邮件发送总开关。 SMTP_SERVER, EMAIL_ADDRESS, EMAIL_PASSWORD, RECIPIENT_EMAIL: 邮箱参数。 评分权重: TECHNICAL_WEIGHTS, FUNDAMENTAL_WEIGHTS, SENTIMENT_WEIGHT: 各维度权重。 MARKET_REGIME_WEIGHTS: 不同市场状态下的权重动态调整配置。 决策阈值: DECISION_THRESHOLDS: 定义买入、卖出、持有等决策的分数线。 5. 部署与运维\r5.1. Docker部署 (推荐)\r创建 .env 文件: 在项目根目录创建 .env 文件，并填入环境变量（如 GEMINI_API_KEY）。 构建镜像: docker build -t quant-trading . 运行容器: docker run -d -p 5000:5000 --env-file .env quant-trading 5.2. 本地直接运行\r安装依赖: pip install -r requirements.txt 配置环境变量 或直接修改 src/config.py。 启动服务: python health_check.py 5.3. 自动化任务\rLinux: 使用 crontab 定时调用 /run 接口。 Windows: 使用“任务计划程序”定时执行curl命令或Python脚本。 6. 项目路线图 (Roadmap)\r本文档规划了系统未来的主要开发方向，旨在将其从一个选股分析工具，演进为一个功能完备的综合性量化平台。\n第一阶段：技术架构优化 (已完成)\r性能优化: 引入并发处理，并行获取和分析股票。 成本与效率优化: 增加基于缓存的AI分析结果复用。 架构优化: 改造API为异步模式，提供任务状态查询接口。 数据管理优化: 实现股票数据的增量更新和数据库索引。 第二阶段：功能与策略优化 (已完成)\r功能完备性增强: 引入回测框架 (BacktestingEngine)。 引入投资组合与风险管理 (PortfolioManager)。 量化策略深度优化: 引入市场状态机 (MarketRegime)，实现权重动态调整。 深化AI模型应用（情绪时序分析、AI因子挖掘、因果推断）。 第三阶段：平台化与智能化 (规划中)\r实盘交易集成: 对接主流券商（如华泰、同花顺）的实盘交易API，实现从信号生成到自动下单的交易闭环。 策略市场与回测平台: 开发一个可视化的策略回测界面。 允许用户通过Web界面创建、修改和回测自己的量化策略。 交互式Web仪表盘: 使用Streamlit或Dash/Plotly创建一个丰富的Web界面。 展示持仓分析、收益曲线、风险指标、市场状态等。 深度学习模型引入: 探索使用LSTM、Transformer等模型进行股价短期趋势预测。 将预测结果作为一个新的评分因子整合进StrategyEngine。 事件驱动策略: 监控新闻、公告、财报发布等事件。 开发基于特定事件（如业绩预增、高管增持）的交易策略。 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%8C%AB%E5%92%AA/test_knowledge_base/",
    "title": "test_knowledge_base",
    
    "content": "\r这是一个测试知识库文件\r这是一个关于人工智能的段落。人工智能是计算机科学的一个分支，旨在创建能够像人类一样思考和学习的智能机器。\n另一个关于机器学习的段落。机器学习是人工智能的一个子集，它使系统能够从数据中学习，而无需明确编程。山咪爱黏人。山咪名字的来源是为了纪念他的两个主人是登上认识的。山咪完成了两针疫苗，还没有绝育。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/transformer%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/",
    "title": "Transformer的工作原理",
    
    "content": "Transformer的工作原理\n拿到句子：从前有个国王，他有个女儿\n1.Token化：分词为得到token:从前|有个|国王|，|他|有个|女儿\n2.词嵌入、词向量：将每个token进行向量化（该token和其他对象的关联关系打分）-\u0026gt;转换成一堆数字,例如国王[0.9（权力）,0.8（城堡），0.7（严肃）\u0026hellip;.]，女儿[\u0026hellip;.]\n3.注意力机制：\n​\t编码器处理：分析问题用注意力划重点（如国王和女儿关系等）\n​\t解码器处理：边编故事边查表，用注意力确保连贯，生成内容。\n整体：进入计算-\u0026gt;注意力机制-\u0026gt;计算token与上下文的关系 ，据概率得到新词\n4.不断生成：再将新词进行上述计算，得到下一个新词。像玩文字无限接龙，每次参考所有历史信息，用注意力决定下一步重点。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/unnitest%E7%AC%94%E8%AE%B0/",
    "title": "unnitest笔记",
    
    "content": " 一、引入 1.导包，import unnitest 2.编写测试类，继承unnitest 二、运行 1.unnitest.main(),运行全部用例\n2.测试套：testsuite\n创建：suite=unnitest.Testsuite()\n测试套添加用例：suite.addtTest（类（方法））\n运行：runner=unnitest.TextTestRunner()\n运行：runner.run(suite) *运行必须在命令行运行否则是运行全部用例\n三、生成报告\n1.将HTMLTestRunner.py文件放到项目文件夹下 2.导包：如左图 3.创建测试套，参考上方 4.创建测试报告文件，且以测试套运行（参考左图） 与pytest的异同 pytest以mark方式组织用例（而非套件） 面试相关 pycharm关闭pytest测试模式 ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%88%86%E4%BA%AB/",
    "title": "测试平台分享",
    
    "content": " title: \u0026ldquo;测试平台教程\u0026rdquo;\ncategories: [\u0026ldquo;技术\u0026rdquo;, \u0026ldquo;编程\u0026rdquo;, \u0026ldquo;git\u0026rdquo;]\nauthor: \u0026ldquo;tian\u0026rdquo;\ndate: 2025-03-21T12:59:32+08:00\ndraft: false\ntags: [\u0026ldquo;测试平台\u0026rdquo;, \u0026ldquo;静态网站\u0026rdquo;, \u0026ldquo;教程\u0026rdquo;]\r一、基本介绍：（） 桌面端工具（一年左右），使用python的wxpython框架编写，使用pyinstaller打包为桌面exe文件；缺点：体积大，不便于分享；\nweb端应用（10月初至今）：flask+vue实现；优点，通过脚本实现热更新；链接形式便于分享。\n二、功能介绍：\n三、技术实现\n测试平台采用前后端分离的方式实现:\n后端由flask框架实现； （1）flask项目结构 （2）在项目入口文件中构建接口 Flask：用于创建一个flask应用,app = Flask(name) CORS:解决跨域问题，cors = CORS(app) request:接受请求的参数，request.args.get()；phone = request.json[] jsonify:以json格式返回结果：jsonify({\u0026ldquo;data\u0026rdquo;: res}) 接口的基本组成：\n构建一个接口的基本步骤： 导包：Flask、CORS、request、jsonify 在app.route()装饰器中定义接口的请求类型、url路径 写一个接口函数 获取入参（可选） get请求 request.args.get() post请求 request.json[] 对得到的参数进行基本校验：如参数类型校验、字段长度、是否空、鉴权等。 根据传参进行逻辑处理，调用对应功能，得到结果 构建响应头（可选，返回类型是文件时必须） 构建结果，使用jsonify将返回结果构建成一个js （可选） return结果 启动flask app.run(ip,port,debug=True),其中debug=True代表以调试模式启动，代码改动后自动重启；debug默认为False。 包的管理 requirements.txt 代码中引入了的包，需要填写在该文件中，格式：“ 包名==版本号”\n（3）采用gunnicorn+gevent部署flask项目 介绍： 一个HTTP 服务器，可以增加项目的并发，通常和gevent一起使用。 安装gunicorn和gevent： pip install gunicorn -i https://pypi.tuna.tsinghua.edu.cn/simple pip install gevent-i https://pypi.tuna.tsinghua.edu.cn/simple 配置文件 gunicorn.conf.py workers = 10 定义同时开启的处理请求的进程数量，根据网站流量适当调整 worker_class = \u0026ldquo;gevent\u0026rdquo; 采用gevent库，支持异步处理请求，提高吞吐量 bind = \u0026ldquo;0.0.0.0:80\u0026rdquo; 监听IP放宽，以便于Docker之间、Docker和宿主机之间的通信,docker部署固定 采用启动服务： gunicorn flask_index:app -c ./gunicorn.conf.py 注意：Gunicorn只能运行在Linux环境中，不支持windows平台，因此在windows调试的时候不要用这个方式启动flask； 2. 前端：vue 、node.js（前端的包管理工具，类似python的pip包管理工具）、vue-cli（vue项目的脚手架）、element-ui、echats提供页面交互;\n（1）项目结构\n(2) 配置环境 安装node.js，前端包管理工具，直接下载安装即可 全局安装cnpm： npm install cnpm -g，解决npm速度慢的问题 cnpm install vue-cli -g 全局安装脚手架vue-cli 通过脚手架创建项目： vue init webpack my-project 启动项目：npm run serve 打包：npm run build (3)配置本地环境和正式环境：\n手动切换：url决定正式环境还是本地测试环境 （4）通过nginx部署：\n部署：docker（ ）+WebHooks（ ）+脚本的方式实现，合并代码后自动化部署。 构建Dockerfile： flask： Vue:\n打包docker（自动化形式）：\n以demo的方式演示实现一个工具： 后端：用flask分别写一个接口demo，实现：根据传参生成新诊所，并绑定到指定账号 安装flask、flask_cors (pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple) 新建一个flask项目 导包 简单实现一个get类型接口： 写一个post类型接口，调用已有函数： 启动flask\n前端：一个单页面的vue+elementui的demo： 准备文件（要引入的插件），将以下文件下载到项目的目录下\n、\n引入文件，在html的head标签中引入以上文件\n（需要先了解下html\\css\\js） 创建vue应用骨架 html部分 js部分 vue部分只需重点关注：模板语法、事件处理、以及常用指令 在页面中使用element-ui组件，以按钮为例，并给按钮添加事件处理： 使用axios发送请求 js\n写一个按钮用于触发POST接口请求、一个文本框用于显示接收的结果。 html部分：\njs部分\n四、后续方向 继续加入能提升效率的工具、加强提供测试数据的能力 自动化测试项目的可视化、测试用例少代码化\nPython from flask import Flask,request,jsonify from opened_new_clinic import opened_new_clinic from flask_cors import CORS @app.route(\u0026rsquo;/demo\u0026rsquo;, methods=[\u0026lsquo;POST\u0026rsquo;, \u0026lsquo;GET\u0026rsquo;]) def get_msg(): msg=request.args.get(\u0026ldquo;message\u0026rdquo;) print(f\u0026rsquo;message, {msg}\u0026rsquo;) return {\u0026ldquo;data\u0026rdquo;:f\u0026quot;来自服务端的回复{msg}\u0026quot;} @app.route(\u0026rsquo;/create_clinic\u0026rsquo;, methods=[\u0026lsquo;POST\u0026rsquo;, \u0026lsquo;GET\u0026rsquo;]) def create_clinic(): phone = request.json[\u0026lsquo;phone\u0026rsquo;] storeid = request.json[\u0026lsquo;storeid\u0026rsquo;] if phone != \u0026rsquo;\u0026rsquo; and storeid != \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(phone, storeid) elif phone != \u0026rsquo;\u0026rsquo; and storeid == \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(phone=phone) elif phone == \u0026rsquo;\u0026rsquo; and storeid != \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(clinic_id=storeid) else: res = opened_new_clinic() return jsonify({\u0026ldquo;data\u0026rdquo;: res}) Bash\nnew Vue（{\rel: \"#app\",\rdata:{},\rmethods:{}\r}）\rBash\r{{name}}\rBash\rcreate_clinic(){\rvar _this = this;\raxios\r.post('http://localhost:5000/create_clinic' , {\rstoreid:_this.form.store_id,\rphone:_this.form.phone\r})\r.then(\rfunction(response) {\r_this.form.res = response.data.data\rconsole.log(info)\r})\r.catch(function (error) {\r// 请求失败处理\rconsole.log(error);\r});\r}\rBash\n点击创建诊所\r结果：\nJSON\r",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E7%AC%94%E8%AE%B0/",
    "title": "大模型概述笔记",
    
    "content": "大模型概述笔记\nAGI:通用人工智能，能模拟人类抽象推理，因果理解等能力，解决未知环境的复杂问题，是人工智能的终极目标之一。大模型是AI发展的里程碑，也是实现AGI的重要步骤。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E6%9E%84%E5%BB%BAfastapi+vue%E9%A1%B9%E7%9B%AEdockerfile/",
    "title": "构建fastapi+vue项目dockerfile",
    
    "content": "\r构建fastapi步骤\r1.在fast_api项目下，创建文件gunicorn.conf.py 其内容如下： workers = 5 # 定义同时开启的处理请求的进程数量，根据网站流量适当调整 worker_class = \u0026#34;gevent\u0026#34; # 采用gevent库，支持异步处理请求，提高吞吐量 bind = \u0026#34;0.0.0.0:80\u0026#34; # 监听IP放宽，以便于Docker之间、Docker和宿主机之间的通信 2.python依赖存于项目requirements.txt文件内 3.fast_api项目下，构建Dockerfile，其内容如下： FROM python:3.7 WORKDIR /usr/src/app COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple COPY . . CMD [\u0026#34;gunicorn\u0026#34;, \u0026#34;fast_api:app\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;./gunicorn.conf.py\u0026#34;] 4.fast_api项目根目录终端，执行： docker build -t tools_flask .打包为镜像 #此处的fast_api为后端项目文件名称含fastapi的实现逻辑，注意文件名不要用“api.py”与已有模块冲突，运行不起来。 5.运行docker run -dit -p 5000:80 --name tools-flask tools_flask 启动为容器 dockerfile内容\rFROM python:3.9.2 WORKDIR /usr/src/app/tools/tools_flask ENV TZ Asia/Shanghai RUN ln -fs /usr/share/zoneinfo/${TZ} /etc/localtime \\ \u0026amp;\u0026amp; echo ${TZ} \u0026gt; /etc/timezone COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple COPY . . CMD [\u0026#34;uvicorn\u0026#34;, \u0026#34;fastapi_index:app\u0026#34;, \u0026#34;--host\u0026#34;, \u0026#34;0.0.0.0\u0026#34;, \u0026#34;--port\u0026#34;, \u0026#34;80\u0026#34;] 构建vue的步骤\r1.在项目tools_vue根目录，创建nginx夹，该文件夹下新建文件 default.conf。 default.conf内容如下： server { listen 80; server_name localhost; #charset koi8-r; access_log /var/log/nginx/host.access.log main; error_log /var/log/nginx/error.log error; location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 2.tools_vue项目根目录终端，执行npm run build，打包生成dist文件夹 3.在项目tools_vue根目录构建Dockerfile文件 FROM nginx COPY dist/ /usr/share/nginx/html/efctools COPY nginx/default.conf /etc/nginx/conf.d/default.conf 4.tools_vue项目根目录终端，执行： docker build -t tools_vue2 .打包为镜像 5.运行docker run -p 3002:80 -d --name tools-vue-v2 tools_vue2 启动为容器 dockerfile内容\rFROM nginx COPY dist/ /usr/share/nginx/html/ COPY nginx/default.conf /etc/nginx/conf.d/default.conf ",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/",
    "title": "机器学习",
    
    "content": "机器学习\n步骤：\n准备历史数据-\u0026gt;创建模型并训练历史数据-\u0026gt;新数据输入预测结果\n机器学习的分类：\n监督学习：数据带结果/标签\n无监督学习：一大堆没有标签结果，让机器自行分类检测。\n自监督学习：无需人工标注，通过数据本身结果生成伪标签或辅助任务(通常办法)\n强化学习：不断尝试和环境互动得到的反馈改变行为做出最有决策AIRgo。\n模型训练的3大阶段\n1.预训练-\u0026gt;海量无标注的文本，进行自监督学习。\n2.SFT监督微调。-\u0026gt;使用有标注的数据对基座模型进行微调，让模型能够适用特定任务，最终得到一个有偏好的模型。\n3.RLHF强化学习，-\u0026gt;基于人类反馈的期望进行学习(奖励模型)。\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bpytest%E9%A1%B9%E7%9B%AE/",
    "title": "快速上手pytest项目",
    
    "content": "\rtags: [\u0026ldquo;pytest\u0026rdquo;, \u0026ldquo;python\u0026rdquo;]\r快速上手Pytest接口测试\r背景\r以前有分享过httprunner+pytest相关的使用方法，并且一直使用httprunner编写用自动化脚本，以前的经验可以快速帮我们上手pytest框架。为了快速上手pytest，HttpRunner 与Pytest 在编写自动化脚本异同点对比：\n对比维度HttpRunnerPytest用例编写方式支持YAML/JSON（低代码）和 pytest代码138纯 Python代码编写，支持函数式执行框架基于pytest（3.x版本后）18原生pytest框架，支持更灵活的参数化通过parameters在YAML/JSON中实现，或在 pytest代码中使用参数化装饰器16原生支持 @pytest.mark.parametr 高，支持动态生成数据断言机制基于validate关键字，支持jmespath 表达式18使用Python原生assert或第三方 pytest-assume 多断言)测试报告支持Allure（3.x版本后不再自带HTML报告）18依赖插件（如pytest-html、allure- 定制性强59扩展性通过debugtalk.py自定义函数，但框架耦合度高18原生支持插件开发，可通过conf fixture，扩展性极强5用例分层明确分层（APl/TestSuite/TestCase），适合原子接 口与流程组合18无强制分层，但可通过模块化 page_object模式）实现类学习曲线低代码门槛，适合快速上手15需 Python基础，但灵活性更高，道\r项目初始化\r克隆项目◦ git clone git@gitlab.guangpuyun.cn:clinic-diag/test/poct_api_test.git 了解项目结构\n安装依赖\r◦ 项目根目录下打开终端，执行pip install -r requirements.txt\n测试用例格式\r用例文件以test_开头或_test结尾◦ 建议以场景命名-如四合一的快速检测：test_zk_quicktest.py 用例集合——类，以Test开头（可以无）◦ 包含1个或多个测试用例函数 测试用例函数以test_开头◦ 一个函数代表一条用例- $_-\u0026gt;$ 一个明确的测试点 用例转换\r1、运行脚本utils/swaager.py——爬取swagger文档资源,存放于/api/swaggerApi目录 2、运行脚本api/generateTestCases.py，生成基础用例，存放于/api目录 3、基础用例结构\n此时只是生成了接口的对象，还需要编写实现逻辑和传参进一步实现该对象，完成测试用例编写（见用例编写）\n用例编写\r在/test对应的目录下新建用例文件，命名以test_开头，表明测试场景 导入必要的包和基础用例，如： from utils.logger import loggerfrom api.poctMina.addcartusingPosT import YsbMallCartController\n3. 编写测试用例\rfrom utils.logger import logger fron api.poctMina.addCartUsinqPosT import YsbMallCartController def test_addCartUsing(getTokenBySecret,pytestconfig): 用例名称-体现在报告上 addCartUsing $\\mathbf{\\sigma}=\\mathbf{\\sigma}$ YsbHallCartController ( addcartUsing.base_url $\\mathbf{\\sigma}=\\mathbf{\\sigma}$ pytestconfig.getini(\u0026lsquo;poct-host\u0026rsquo;) 构造url addCartUsinq.data[\u0026lsquo;addNum\u0026rsquo;]=1 addCartUsing.data[\u0026lsquo;packageId\u0026rsquo;] $=2\\dot{0}\\dot{\\Theta}$ addCartUsing.data[*token\u0026rsquo;]=getTokenBySecret(store=3o15659) 构造传参 response_data=addcartUsing.addcart() .json() 获取返回值 logger.info(response_data) assert response_data[\u0026lsquo;code\u0026rsquo;] $\\scriptstyle==$ \u0026lsquo;40001\u0026rsquo; 断言\n用例参数化\r1. 直接传参给函数 （小数据量）\r@pytest.mark.parametrize(x,y,[（x1，y1），（x2\u0026rsquo;，y2\u0026rsquo;）],indirect=True)\n2. 当需要对参数进行处理时\r@pytest.fixture(scope=\u0026lsquo;class\u0026rsquo;,autouse $\\risingdotseq$ True, params $\\c=$ order_id,ids $\\c=$ ids)scope作用域-可以是function，class,module，session;配合@pytest.mark.parametrize(x,[1,2],indirect $\\varXi^{-}$ True)传参使用， #indirect $\\varXi^{-}$ True代表使用fixture函数处理数据。 request.param 在 fixture 中获取原始参数值。\n1 import pytest 2 3 @pytest.fixture 4 def number(request): 5 return request.param $\\star$ 2 6 7 @pytest.mark.parametrize(\u0026ldquo;number\u0026rdquo;, [1, 2, 3], indirect=True) 8 def test_number(number): 9 assert number in [2, 4, 6]\n3. 参数化从文件读取数据\r从外部文件（如 CSV、JSON、YAML）读取测试数据，适用于数据量较大或需要动态生成数据的场景。\n1 import pytest 2 import json 3 4 def load_test_data(file_path): 5 with open(file_path, $\u0026ldquo;r\u0026rdquo;$ ) as f: 6 return json.load(f) 7 8 @pytest.mark.parametrize(\u0026ldquo;test_case\u0026rdquo;, load_test_data(\u0026rsquo;test_data.json\u0026rsquo;)) 9 def test_from_file(test_case): 10 assert test_case[\u0026lsquo;input\u0026rsquo;] $^+$ test_case[\u0026lsquo;addend\u0026rsquo;] $\\scriptstyle==$ test_case[\u0026rsquo;expected\u0026rsquo;]\npytest_generate_tests 钩子函数来自定义参数化。\r在测试收集阶段动态生成参数。 适用于需要在多个测试函数中共享参数化逻辑的情况。\n1 def pytest_generate_tests(metafunc): 2 if \u0026ldquo;num\u0026rdquo; in metafunc.fixturenames: 3 numbers $\\mathbf{\\Psi}=\\mathbf{\\Psi}$ [1, 2, 3] 4 metafunc.parametrize(\u0026ldquo;num\u0026rdquo;, numbers) 5 def test_number(num): 6 assert num in [1, 2, 3]\n5. 用例参数化 Fixture\r参数化 fixture，使其在不同的测试中提供不同的数据。\n1 import pytest 2 @pytest.fixture(params $\\c=$ [1, 2, 3]) 3 def number(request): 4 return request.param 5 def test_number(number): 6 assert isinstance(number, int)\n用例封装\r1. fixture关键字驱动\r方法：\n通过@pytest.fixture装饰器封装一些常用的工具函数放到conftest.py作用：\na. 用例中可实现不用导包直接使用。b. 可实现用例之间的参数传递c. 可作用于全局，也可灵活定义作用域\n例如：conftest.py中定义fixture函数获取token\n在用例中直接使用getTokenBySecret函数获取token：\r2. 公用模块的封装\r存放一些封装好的可复用的公共模块，如连接数据库，reques请求，日志模块等\n用例断言\ra. 判断是否为真： assert xxb. 判断不为真： assert not xxc. 判断a是否包含b： assert a in bd. 判断a不包含b： assert a not in be. 判断两值相等： assert b $\\mathtt{\\Gamma}==\\mathtt{a}$ f. 判断两值不相等： assert a != b\n运行\r1. 终端\r◦ pytest -q/-s 静默运行/运行时显示打印 ◦ 运行结果生成报告 pytest \u0026ndash;html=report.html ◦ 运行指定用例 pytest test_se.py::TestClassone::test_one ◦ 多进程数（NUM）运行 pytest test_se.py -n NUM ◦ 运行失败重试（NUM）次：pytest test_se.py \u0026ndash;reruns NUM ◦ 跳过用例运行@pytest.mark.skip ◦ 重试@pytest.mark.flaky(reruns $^{:=3}$ , reruns_delay $^{\\prime=2}$ ) #失败时重试3次，每次间隔2秒\n2. 代码运行\r直接运行main.py（提交代码前必须运行通过）\n测试报告\r浏览器打开pytest_report.html\r光谱接口自动化测试报告\rReport generated on 12-Mar-2025 at 16:13:25 by pytest-html v4.1.1\nEnvironment\rPython3.10.4执行时间2025-03-12 16:12:14项目名称POCT系统测试报告\rsummary\r17 tests took 00:01:11\n(Un)check the boxes to filter the results\nResultTest 用例路径TestName 用例名称执行时间Passedtests/test_poct_mal/test_addCart.py::test_addCartUsing加购物功能测试00:00:05Passedtests/test_poct_mall/test_getUsefulPoctProductsV2.py:test_getUsefulPoctProducts测试用例1：MachineSampleController查询所有有效的产品信息00:00:03Passedtests/test_poct_mal/test_getUsefulPoctProductsV2.pytest_getUsefulPoctProducts1测试用例2：PoctMinaMachineSampleController查询所有有效的产品信息00:00:01Passedtests/test_poct_mal/test_getUsefulPoctProductsV2.py:test_getUsefulPoctProducts2测试用例3：YsbMachineSampleController查询所有有效的产品信息00:00:01Passedtests/test_poct_mall/test_getUsefulPoctProductsV2.py:test_getUsefulPoctProducts3测试用例4：查询YtjMachineSampleController所有有效的产品信息933 msPassedtests/test_poct_mal/test_listAccount_2.py::TestPoctMinaOrderReportControllr:test_listAccount不分页查询下单账号00:00:01Passedtests/test_poct_mina/test_createOrder.py::TestMinaOrder:test_createOrder创建单项目订单，成功生成订单00:00:06Passedtests/test_poct_mina/test_createOrder.py.:TestMinaOrder::test_createOrder2创建多项目订单，成功生成订单00:00:04Passedtests/test_process_cases/test_zk_archivestest.py::TestArchivesTest:test_getArchives建档患者信息-信息同步00:00:01Passedtests/test_process_cases/test_zk_archivestest.py::TestArchivesTest:test_uploudArchives上传建档患者检测结果-患者信息正确00:00:05Passedtests/test_process_cases/test_zk_minaOrder.py::TestMinaOrder:test_get_orderld小程序下单后-订单同步到设备00:00:05Passedtests/test_process_cases/test_zk_minaOrder.py:TestMinaOrder:test_order_state小程序下单-设备上传检测结果-订单状态变为已完成00:00:05Passedtests/test_process_cases/test_zk_minaOrder.py::TestMinaOrder:test_product_state小程序下单-设备上传订单部分检测结果-检测项目状态变为已完成且无结果项目取消00:00:07Passedtests/test_process_cases/test_zk_minaOrder.py::TestMinaOrder:test_product_state_change小程序下单-设备细项加样上传细项检测结果日志-检测项目状态变为检测中00:00:15Passedtests/test_process_cases/test_zk_quicktest.py::Testquicktets::test_uploud_single_results测试上传单条检测结果创建订单-生成订单00:00:03Passedtests/test_process_cases/test_zk_quicktest.py::Testquicktets:test_upload_duplicate测试上传上传四个联检项目检测结果，创建订单且项目正确00:00:05Passedtests/test_process_cases/test_zk_quicktest.py::Testquicktets:test_upload_twice重复上传多次相同machine_id的同一条结果，只生成一个订单00:00:03\r",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/git/%E4%BD%BF%E7%94%A8gihub%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/",
    "title": "使用GiHub作为图床",
    
    "content": "\r使用 GitHub 作为免费图床的文档\r最近就想找一款免费的图床来放置自己的图片，逛了一圈下来发现GitHub可以白嫖，于是乎，就有了这篇文章。\nGitHub 是一个非常流行的代码托管平台，除了代码存储外，你还可以使用 GitHub 来托管静态资源，比如图片。通过将图片上传到 GitHub 的仓库，你可以轻松获取图片的 URL，从而在网页或文档中嵌入这些图片。以下是如何使用 GitHub 作为免费图床的详细步骤。\n步骤 1: 创建 GitHub 仓库\r登录到 GitHub。\n点击右上角的 \u0026ldquo;+\u0026rdquo; 按钮，然后选择 \u0026ldquo;New repository\u0026rdquo;。\n填写仓库的名称（例如：my-image-hosting），并设置为公开（Public）。\n点击 \u0026ldquo;Create repository\u0026rdquo; 创建仓库。\n步骤 2: GitHub获取个人的Token\r访问：settings-tokens ，点击Generate new token 2.设置 token 属性 ，Expiration：永不过期，Select scopes：repo 一定要全选，其他的无所谓 ，点击最下方创建\n就会获得一个token字符串， ⚠️ 注意：一定要收藏好 token，因为只会显示一次！，关掉这个页面就再也看不见了。 [!IMPORTANT] 后续会继续使用这个token!!!!\n步骤 3: 下载PicGo\r在PicGo最新页面上下载它的安装包。PicGo下载页面 安装PicGo。无需赘述\n配置GitHub\n​\nPicGo 上传区配置选中你的配置 ​ 选择完成配置之后就可以拖拉拽上传文件了。\n步骤 4: Typora中使用\r打开Typora，在文件选项中选中偏好设置。 在图像选项中勾选你的安装路径 使用方式： 在Typora粘贴一张图片，右击图片上传，图片会上传并自动转换成链接\n++++\n使用 GitHub 图床大功告成！\r恭喜你完成了 GitHub 图床的配置！ 通过本文的引导，你已经学会了如何：\n创建 GitHub 仓库并上传图片； 获取并配置个人 Token； 使用 PicGo 工具进行图片上传； 在 Typora 中无缝集成并自动生成图片链接。 通过这个流程，你可以快速搭建自己的高效图床，结合 GitHub 和 JsDelivr CDN，免费、稳定且速度快！无论是博客写作还是前端项目开发，这都将是一个非常棒的工具！\n详情请参考我的博文: 使用GiHub作为图床 | 变量人生\n希望这篇教程对你有所帮助！祝你工作愉快，写作顺利！\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
  , 
  {
    "objectID": "1761227921",
    "permalink": "/post/aigc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/",
    "title": "提示词技巧",
    
    "content": "提示词技巧 总结：\n官方提示词库： https://api-docs.deepseek.com/zh-cn/prompt-library\n",
    
    "date": "2025-10-23 13:58:41",
    "updated": "2025-10-23 13:58:41"
  }
  
]