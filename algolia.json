[{"objectID":"d5e9900ee3ff0b00ef379d767fd4a834","permalink":"https://bluespace3.github.io/post/pytest%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88/","title":"pytest接口自动化测试方案","content":" 背景 当前业务核心聚焦于 POCT 领域，设备购买和设备使用等关键功能，已成为测试工作的重点保障对象，但随着系统复杂度的提升,手工的回归测试工作很难全面覆盖。为了确保关键业务功能的质量稳定性，有必要引入自动化测试，增加测试覆盖范围，降低已有功能漏测的风险，提前发现问题。\n目标 短期目标：接入自动化测试（截至3月底）\n前期准备工作 预研不同的自动化测试框架，结合中长期目标与现实情况及各个框架的优缺点选择一套合适的自动化框架 对比几款常见接口测试框架 初步选定：pytest + Requests 语法简洁容易上手-接入成本低 灵活，社区支持好，插件丰富-适合复杂测试场景 制定初步的方案 自动化项目方案 项目框架搭建 确定实施方案 测试人员小范围接入自动化项目（跑通流程） 三月底能够将三款新设备正向检测流程转化为自动化测试脚本 **将慢病设备下单-上传检测结果流程；快速检测单流程接入接口自动化测试（正向检测流程） **将免疫、血球设备下单-上传检测结果（正向检测流程） 中期目标 ：自动化项目应用到测试工作流程（截至6月底）\n覆盖三款新设备装机到检测使用的全部场景\n覆盖设备装机到检测过程中的各项操作步骤和关键节点，从设备初始化到实际检测，确保各环节功能正常，数据交互准确，为用户提供稳定可靠的设备使用体验（包括异常流程）。 将自动化流程应用到测试工作流程。\n能有效增加测试覆盖率，减少漏测风险。 脚本的维护流程\n在接口变更，需求功能更改后如何维护 运行失败用例如何维护 长期目标：不断完善接口自动化，有效应用到研发测试工作流程（截至12月底）\n完善涉及用户相关的功能的自动化测试覆盖 对从商城购买到设备装机、检测、报告生成打印及检测后的慢病管理，全流程自动化测试，保障用户使用系统过程中的顺畅性，避免因流程问题导致的交易失败或用户体验不佳情况。 将自动化测试无缝应用到现有的研发测试工作流程中。 替代大部分回归测试，提高测试效率，进一步减少漏测风险。 自动化测试成为常态化测试手段,能提前发现问题,有效提升整体工作效率。 自动化测试工具选型 自动化测试框架-pytest + Requests 几款常见接口测试框架对比详情：\npytest + Requests\n语法简洁容易上手-接入成本低 灵活，社区支持好，插件丰富-适合复杂测试场景 已有相关基础 选型依据 兼容性、适合复杂流程交互（设备交互）、丰富的社区支持、接入成本\n测试管理工具（飞书或tapd） 自动化用例管理接口自动化测试用例 CI/CD工具 GitLab CI uvicorn+fastapi 部署+接口 自动化测试用例设计 用例分层设计 基础类（/api） 根据接口文档生成 测试用例（/tests） 基础功能用例（原子级-单个接口测试） 定义 ：针对单个接口的独立测试，关注接口的输入输出正确性、异常处理能力及边界条件验证。例如，用户登录接口的独立测试需覆盖正常登录、密码错误、账号不存在等场景 特点 ： 原子性 ：每个用例仅验证一个接口的单一功能，不依赖其他接口或业务流程。 高复用性 ：可作为其他复杂用例的构建单元，例如登录接口的测试结果可被后续业务流程用例复用 技术实现 ：通常结合数据驱动设计（如参数化测试数据），通过多组输入数据覆盖等价类和边界值 业务流程用例（端到端、涉及多个接口和流程的测试） 定义 ：模拟真实用户操作路径，串联多个接口验证端到端业务逻辑。例如“创建商品→创建优惠券→创建活动→下单支付”的全流程测试 特点 ： 场景化 ：基于用户使用的功能场景设计，关注接口间的数据传递与状态流转。 风险覆盖 ：重点验证流程中的关键节点（如订单状态变更、库存扣减）和异常分支（如支付超时回滚） 依赖管理 ：通过关键字驱动设计（如“获取Token”“查询订单状态”）复用基础功能用例，降低冗余代码 测试数据（/data） 存放测试数据 提供测试数据的脚本 工具(/utils) 工具类集合 数据驱动设计 参数化测试数据（Excel、csv、数据库）\n关键字驱动设计 可复用的关键字库（如获取token、查询）\n测试执行策略 触发条件 开发人员提交代码触发\n手动触发\n优先级划分(暂不考虑) 高（核心功能）、中（高频场景）\n失败重试机制 自动重试与日志记录\n** 持续集成（CI/CD）** 集成流程 代码提交 → 静态检查 → 单元测试 → 自动化测试 → 报告生成 流水线配置 GitLab CI YAML配置 结果通知 企业微信群通知 风险管理 潜在风险 环境不稳定 脚本维护成本 需求功能变更 应对措施 设计时需要提前考虑脚本稳定性 定期维护脚本 运行前保证环境正常可用 相关交付物 测试报告 HTML报告 自动化脚本 代码仓库https://gitlab.guangpuyun.cn/clinic-diag/test/poct_api_test\n项目结构\n文档 初始化文档快速编写Pytest接口测试 自动化用例设计文档接口自动化测试用例 维护与优化 脚本维护人员 一般情况下谁写的谁维护 脚本维护方法 接口变更的处理 用例执行/定时/手动触发脚本爬取接口文档，并与最新接口文档对比\n运行main.py 执行用例时，会在warnning日志提醒相关变更 检查变更是否涉及已经编写的用例（快捷键ctrl+shift+f搜索关键词即可） 如：PoctCreateOrderInModel存在差异，对应json文档中找到对应 operationId（文件名），在用例文档中搜索createOrder2UsingPOST_1 ，发现涉及已有用例。\n若有涉及用例，则维护成最新接口信息。\n当用例运行报错/不通过进行定位 bug-\u0026gt;记录并通知开发修复； 数据问题-\u0026gt;使用自动化专用的数据，避免污染； 脚本本身不稳定导致的运行失败，维护脚本能稳定运行，若维护成功过高可直接先注释脚本，并在对应用例做好备注“待维护”。 脚本维护代办事项 接口自动化代办事项 ","date":"2025-03-28 22:43:32","updated":"2025-03-28 22:43:32"},{"objectID":"75854c0696a5a16ae376d24f963c7789","permalink":"https://bluespace3.github.io/post/gitlab%E9%85%8D%E7%BD%AEcicd%E5%B7%A5%E4%BD%9C%E6%B5%81/","title":"gitlab配置cicd工作流","content":" GitLab CI/CD 简介 GitLab CI/CD 是 GitLab 内置的持续集成/持续部署工具，它允许开发者在代码提交后自动执行一系列任务，如构建、测试和部署。通过配置 CI/CD 流程，可以大大提高开发效率，减少人为错误，并确保代码质量。\nCI/CD 核心概念 持续集成 (CI): 开发人员频繁地将代码集成到主分支，每次集成都通过自动化构建和测试来验证，从而尽早发现问题。 持续交付 (CD): 确保代码随时可以部署到生产环境，通常包括自动化测试和部署流程。 持续部署 (CD): 将持续交付更进一步，自动将通过测试的代码部署到生产环境。 .gitlab-ci.yml 配置文件 GitLab CI/CD 的核心是 .gitlab-ci.yml 文件，它定义了 CI/CD 流水线的结构和行为。该文件需要放在项目的根目录下。\n基本结构 # 定义阶段 stages: - build - test - deploy # 定义作业 build_job: stage: build script: - echo \u0026#34;Building the app\u0026#34; - make build test_job: stage: test script: - echo \u0026#34;Running tests\u0026#34; - make test deploy_job: stage: deploy script: - echo \u0026#34;Deploying the app\u0026#34; - make deploy only: - master 关键组件 stages: 定义流水线的阶段，按顺序执行。 jobs: 定义在特定阶段执行的任务。 script: 在作业中执行的命令。 only/except: 控制作业何时运行（例如，只在特定分支上运行）。 GitLab Runner GitLab Runner 是执行 CI/CD 作业的代理，它可以安装在不同的环境中，如 Linux、Windows、macOS 等。\n安装 GitLab Runner # 在 Linux 上安装 curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash sudo apt-get install gitlab-runner # 在 macOS 上安装 brew install gitlab-runner 注册 Runner sudo gitlab-runner register 注册过程中，需要提供 GitLab 实例的 URL 和注册令牌，以及 Runner 的标签和执行器类型。\n高级配置 环境变量 variables: DATABASE_URL: \u0026#34;postgres://postgres:postgres@postgres:5432/my_database\u0026#34; job_name: variables: DATABASE_URL: \u0026#34;postgres://postgres:postgres@postgres:5432/my_test_database\u0026#34; script: - echo $DATABASE_URL 缓存和构件 cache: paths: - node_modules/ job_name: artifacts: paths: - dist/ expire_in: 1 week 依赖关系 job_name: stage: deploy dependencies: - build_job script: - echo \u0026#34;Deploying the app\u0026#34; 实际应用示例 Node.js 项目 image: node:14 stages: - build - test - deploy cache: paths: - node_modules/ build: stage: build script: - npm install - npm run build artifacts: paths: - dist/ test: stage: test script: - npm run test deploy_staging: stage: deploy script: - npm install -g firebase-tools - firebase use staging - firebase deploy --token $FIREBASE_TOKEN only: - develop deploy_production: stage: deploy script: - npm install -g firebase-tools - firebase use production - firebase deploy --token $FIREBASE_TOKEN only: - master when: manual Python 项目 image: python:3.9 stages: - test - deploy before_script: - pip install -r requirements.txt test: stage: test script: - pytest deploy: stage: deploy script: - pip install awscli - aws s3 sync ./dist s3://my-bucket/ only: - master CI/CD 最佳实践 保持流水线简单：只包含必要的步骤，避免过度复杂化。 使用缓存：缓存依赖项可以显著提高构建速度。 并行执行：将独立的任务并行执行以节省时间。 环境变量管理：使用 GitLab 的变量功能安全地存储敏感信息。 分支策略：为不同的分支配置不同的 CI/CD 行为。 故障排除 常见问题 Runner 无法连接：检查网络设置和 Runner 注册信息。 构建失败：查看日志以确定失败原因，可能是依赖项问题或脚本错误。 权限问题：确保 Runner 有足够的权限执行所需操作。 调试技巧 job_name: script: - set -x # 启用调试模式 - env # 打印环境变量 - ls -la # 列出文件 结论 GitLab CI/CD 是一个强大的工具，可以自动化软件开发的各个阶段。通过正确配置 .gitlab-ci.yml 文件，可以实现代码的自动构建、测试和部署，提高开发效率和代码质量。随着对 CI/CD 实践的深入理解，可以进一步优化流水线，使其更加高效和可靠。\n","date":"2025-03-25 12:00:00","updated":"2025-03-25 12:00:00"},{"objectID":"01f1c377bbd9fc1c60d1fce36c560b28","permalink":"https://bluespace3.github.io/post/git%E6%93%8D%E4%BD%9C/","title":"git操作","content":" git回滚操作 回滚到上一个版本 git reset --hard HEAD^ 回滚到指定版本 git reset --hard \u0026lt;commit_id\u0026gt; ","date":"2025-03-25 12:00:00","updated":"2025-03-25 12:00:00"},{"objectID":"a9403a1c7a7112f1dc8f8d7066fc131b","permalink":"https://bluespace3.github.io/post/encrypted-example/","title":"加密文章示例","content":" 这是一篇加密的文章 只有输入正确的密码才能查看这篇文章的内容。\n如何设置文章加密 在文章的前置参数中添加以下内容：\nencrypted: true password: \u0026#34;你的密码\u0026#34; 这样就可以为文章添加密码保护了。\n密码保护的工作原理 当用户访问加密文章时，会显示密码输入框 用户输入正确的密码后，文章内容才会显示 密码验证在浏览器端进行，不需要服务器支持 使用sessionStorage保存解锁状态，避免刷新页面后需要重新输入密码 注意事项 这种加密方式只是前端加密，不能防止真正的黑客攻击 适合用于简单的内容保护，不适合保护高度敏感的信息 密码直接保存在文章的前置参数中，所以不要使用您在其他地方使用的重要密码 ","date":"2025-03-25 12:00:00","updated":"2025-03-25 12:00:00"},{"objectID":"97b6d4f7a7771e76e9e79bd01c18081f","permalink":"https://bluespace3.github.io/post/%E4%BD%BF%E7%94%A8gihub%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/","title":"将github变为免费图床","content":" 使用 GitHub 作为免费图床的文档 最近就想找一款免费的图床来放置自己的图片，逛了一圈下来发现GitHub可以白嫖，于是乎，就有了这篇文章。\nGitHub 是一个非常流行的代码托管平台，除了代码存储外，你还可以使用 GitHub 来托管静态资源，比如图片。通过将图片上传到 GitHub 的仓库，你可以轻松获取图片的 URL，从而在网页或文档中嵌入这些图片。以下是如何使用 GitHub 作为免费图床的详细步骤。\n步骤 1: 创建 GitHub 仓库 登录到 GitHub。\n点击右上角的 \u0026ldquo;+\u0026rdquo; 按钮，然后选择 \u0026ldquo;New repository\u0026rdquo;。\n填写仓库的名称（例如：my-image-hosting），并设置为公开（Public）。\n点击 \u0026ldquo;Create repository\u0026rdquo; 创建仓库。\n步骤 2: GitHub获取个人的Token 访问：settings-tokens ，点击Generate new token 2.设置 token 属性 ，Expiration：永不过期，Select scopes：repo 一定要全选，其他的无所谓 ，点击最下方创建\n就会获得一个token字符串， ⚠️ 注意：一定要收藏好 token，因为只会显示一次！，关掉这个页面就再也看不见了。 [!IMPORTANT] 后续会继续使用这个token!!!!\n步骤 3: 下载PicGo 在PicGo最新页面上下载它的安装包。PicGo下载页面 安装PicGo。无需赘述\n配置GitHub\n​\nPicGo 上传区配置选中你的配置 ​ 选择完成配置之后就可以拖拉拽上传文件了。\n步骤 4: Typora中使用 打开Typora，在文件选项中选中偏好设置。 在图像选项中勾选你的安装路径 使用方式： 在Typora粘贴一张图片，右击图片上传，图片会上传并自动转换成链接\n++++\n使用 GitHub 图床大功告成！ 恭喜你完成了 GitHub 图床的配置！ 通过本文的引导，你已经学会了如何：\n创建 GitHub 仓库并上传图片； 获取并配置个人 Token； 使用 PicGo 工具进行图片上传； 在 Typora 中无缝集成并自动生成图片链接。 通过这个流程，你可以快速搭建自己的高效图床，结合 GitHub 和 JsDelivr CDN，免费、稳定且速度快！无论是博客写作还是前端项目开发，这都将是一个非常棒的工具！\n详情请参考我的博文: 使用GiHub作为图床 | 变量人生\n希望这篇教程对你有所帮助！祝你工作愉快，写作顺利！\n","date":"2025-03-21 23:00:32","updated":"2025-03-21 23:00:32"},{"objectID":"60f0259fd089cf2ab4a55813878d1f28","permalink":"https://bluespace3.github.io/post/%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%88%86%E4%BA%AB/","title":"测试平台教程","content":"一、基本介绍：（） 桌面端工具（一年左右），使用python的wxpython框架编写，使用pyinstaller打包为桌面exe文件；缺点：体积大，不便于分享；\nweb端应用（10月初至今）：flask+vue实现；优点，通过脚本实现热更新；链接形式便于分享。\n二、功能介绍：\n三、技术实现\n测试平台采用前后端分离的方式实现:\n后端由flask框架实现； （1）flask项目结构 （2）在项目入口文件中构建接口 Flask：用于创建一个flask应用,app = Flask(name) CORS:解决跨域问题，cors = CORS(app) request:接受请求的参数，request.args.get()；phone = request.json[] jsonify:以json格式返回结果：jsonify({\u0026ldquo;data\u0026rdquo;: res}) 接口的基本组成：\n构建一个接口的基本步骤： 导包：Flask、CORS、request、jsonify 在app.route()装饰器中定义接口的请求类型、url路径 写一个接口函数 获取入参（可选） get请求 request.args.get() post请求 request.json[] 对得到的参数进行基本校验：如参数类型校验、字段长度、是否空、鉴权等。 根据传参进行逻辑处理，调用对应功能，得到结果 构建响应头（可选，返回类型是文件时必须） 构建结果，使用jsonify将返回结果构建成一个js （可选） return结果 启动flask app.run(ip,port,debug=True),其中debug=True代表以调试模式启动，代码改动后自动重启；debug默认为False。 包的管理 requirements.txt 代码中引入了的包，需要填写在该文件中，格式：“ 包名==版本号”\n（3）采用gunnicorn+gevent部署flask项目 介绍： 一个HTTP 服务器，可以增加项目的并发，通常和gevent一起使用。 安装gunicorn和gevent： pip install gunicorn -i https://pypi.tuna.tsinghua.edu.cn/simple pip install gevent-i https://pypi.tuna.tsinghua.edu.cn/simple 配置文件 gunicorn.conf.py workers = 10 定义同时开启的处理请求的进程数量，根据网站流量适当调整 worker_class = \u0026ldquo;gevent\u0026rdquo; 采用gevent库，支持异步处理请求，提高吞吐量 bind = \u0026ldquo;0.0.0.0:80\u0026rdquo; 监听IP放宽，以便于Docker之间、Docker和宿主机之间的通信,docker部署固定 采用启动服务： gunicorn flask_index:app -c ./gunicorn.conf.py 注意：Gunicorn只能运行在Linux环境中，不支持windows平台，因此在windows调试的时候不要用这个方式启动flask； 2. 前端：vue 、node.js（前端的包管理工具，类似python的pip包管理工具）、vue-cli（vue项目的脚手架）、element-ui、echats提供页面交互;\n（1）项目结构\n(2) 配置环境 安装node.js，前端包管理工具，直接下载安装即可 全局安装cnpm： npm install cnpm -g，解决npm速度慢的问题 cnpm install vue-cli -g 全局安装脚手架vue-cli 通过脚手架创建项目： vue init webpack my-project 启动项目：npm run serve 打包：npm run build (3)配置本地环境和正式环境：\n手动切换：url决定正式环境还是本地测试环境 （4）通过nginx部署：\n部署：docker（ ）+WebHooks（ ）+脚本的方式实现，合并代码后自动化部署。 构建Dockerfile： flask： Vue:\n打包docker（自动化形式）：\n以demo的方式演示实现一个工具： 后端：用flask分别写一个接口demo，实现：根据传参生成新诊所，并绑定到指定账号 安装flask、flask_cors (pip install flask -i https://pypi.tuna.tsinghua.edu.cn/simple) 新建一个flask项目 导包 简单实现一个get类型接口： 写一个post类型接口，调用已有函数： 启动flask\n前端：一个单页面的vue+elementui的demo： 准备文件（要引入的插件），将以下文件下载到项目的目录下\n、\n引入文件，在html的head标签中引入以上文件\n（需要先了解下html\\css\\js） 创建vue应用骨架 html部分 js部分 vue部分只需重点关注：模板语法、事件处理、以及常用指令 在页面中使用element-ui组件，以按钮为例，并给按钮添加事件处理： 使用axios发送请求 js\n写一个按钮用于触发POST接口请求、一个文本框用于显示接收的结果。 html部分：\njs部分\n四、后续方向 继续加入能提升效率的工具、加强提供测试数据的能力 自动化测试项目的可视化、测试用例少代码化\nPython from flask import Flask,request,jsonify from opened_new_clinic import opened_new_clinic from flask_cors import CORS @app.route(\u0026rsquo;/demo\u0026rsquo;, methods=[\u0026lsquo;POST\u0026rsquo;, \u0026lsquo;GET\u0026rsquo;]) def get_msg(): msg=request.args.get(\u0026ldquo;message\u0026rdquo;) print(f\u0026rsquo;message, {msg}\u0026rsquo;) return {\u0026ldquo;data\u0026rdquo;:f\u0026quot;来自服务端的回复{msg}\u0026quot;} @app.route(\u0026rsquo;/create_clinic\u0026rsquo;, methods=[\u0026lsquo;POST\u0026rsquo;, \u0026lsquo;GET\u0026rsquo;]) def create_clinic(): phone = request.json[\u0026lsquo;phone\u0026rsquo;] storeid = request.json[\u0026lsquo;storeid\u0026rsquo;] if phone != \u0026rsquo;\u0026rsquo; and storeid != \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(phone, storeid) elif phone != \u0026rsquo;\u0026rsquo; and storeid == \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(phone=phone) elif phone == \u0026rsquo;\u0026rsquo; and storeid != \u0026lsquo;\u0026rsquo;: res = opened_new_clinic(clinic_id=storeid) else: res = opened_new_clinic() return jsonify({\u0026ldquo;data\u0026rdquo;: res}) Bash\n}) .catch(function (error) { // 请求失败处理 console.log(error); }); } Bash\nmethods: { send(){ var _this = this; axios .get('http://localhost:5000/demo?message=test') .then( function(response) { _this.info = response.data.data console.log(info) }) .catch(function (error) { // 请求失败处理 console.log(error); }); }, create_clinic(){ var _this = this; axios .post('http://localhost:5000/create_clinic' , { storeid:_this.form.store_id, phone:_this.form.phone }) .then( function(response) { _this.form.res = response.data.data console.log(info) }) .catch(function (error) { // 请求失败处理 console.log(error); }); } }, })\u0026lt;/script\u0026gt;\n","date":"2025-03-21 12:59:32","updated":"2025-03-21 12:59:32"},{"objectID":"8370eec5bf5b07f572ad579cfd449281","permalink":"https://bluespace3.github.io/post/mcp-intro/","title":"MCP入门指南","content":" 什么是MCP？ MCP（Model Context Protocol）是一种用于扩展和增强开发工具功能的协议。它允许开发者创建和使用MCP服务器，这些服务器可以提供额外的工具和资源，以提高开发效率和灵活性。\nMCP的安装 MCP的安装通常包括以下步骤：\n安装MCP客户端：根据使用的开发工具，安装相应的MCP客户端插件或扩展。 创建MCP服务器：使用提供的工具或模板创建一个新的MCP服务器项目。 配置MCP服务器：在MCP服务器项目中添加所需的工具和资源，并进行相应的配置。 运行MCP服务器：启动MCP服务器，使其与MCP客户端进行通信。 使用示例 以下是一个简单的MCP服务器使用示例：\n#!/usr/bin/env node import { Server } from \u0026#39;@modelcontextprotocol/sdk/server/index.js\u0026#39;; import { StdioServerTransport } from \u0026#39;@modelcontextprotocol/sdk/server/stdio.js\u0026#39;; const server = new Server( { name: \u0026#39;example-mcp-server\u0026#39;, version: \u0026#39;0.1.0\u0026#39;, }, { capabilities: { tools: { exampleTool: { description: \u0026#39;这是一个示例工具\u0026#39;, inputSchema: { type: \u0026#39;object\u0026#39;, properties: { message: { type: \u0026#39;string\u0026#39;, description: \u0026#39;要显示的消息\u0026#39;, }, }, required: [\u0026#39;message\u0026#39;], }, }, }, }, } ); server.setRequestHandler(\u0026#39;exampleTool\u0026#39;, async (request) =\u0026gt; { const message = request.params.message; return { content: [ { type: \u0026#39;text\u0026#39;, text: `您输入的消息是：${message}`, }, ], }; }); const transport = new StdioServerTransport(); await server.connect(transport); console.error(\u0026#39;MCP服务器正在运行\u0026#39;); 热门MCP工具推荐 以下是一些目前热门的MCP工具：\n代码生成工具：根据项目需求自动生成代码模板和结构，提高开发效率。 API文档生成工具：自动从代码中提取API信息并生成详细的文档，方便团队成员查阅。 代码质量检查工具：对代码进行静态分析，检查潜在的错误和问题，提高代码质量。 自动化测试工具：自动生成和执行测试用例，确保代码的正确性和稳定性。 通过使用这些热门MCP工具，开发者可以大大提高开发效率和代码质量，更好地完成项目开发任务。\n总结 MCP是一种强大的开发工具扩展协议，可以帮助开发者创建和使用各种工具和资源。通过本指南，您已经了解了MCP的基本使用方法，接下来可以探索更多高级功能和热门工具。\n","date":"2025-03-20 13:48:29","updated":"2025-03-20 13:48:29"},{"objectID":"fc795d63f2bd3cc3eff8b09603f588dd","permalink":"https://bluespace3.github.io/post/pytest-intro/","title":"pytest入门指南","content":" 什么是pytest？ pytest是一个功能强大且易于使用的Python测试框架。它可以帮助开发者编写简洁、可读性强的测试代码，并提供丰富的插件支持。\npytest的主要特点 简洁的测试用例编写方式 自动发现测试用例 支持参数化测试 强大的断言功能 丰富的插件生态系统 安装pytest 使用以下命令安装pytest：\npip install pytest 编写测试用例 一个简单的pytest测试用例如下：\ndef test_addition(): assert 1 + 1 == 2 def test_subtraction(): assert 2 - 1 == 1 运行测试 使用以下命令运行pytest测试：\npytest 参数化测试 pytest支持参数化测试，可以使用@pytest.mark.parametrize装饰器：\nimport pytest @pytest.mark.parametrize(\u0026#34;test_input,expected\u0026#34;, [ (\u0026#34;3+5\u0026#34;, 8), (\u0026#34;2+4\u0026#34;, 6), (\u0026#34;6*9\u0026#34;, 42), ]) def test_eval(test_input, expected): assert eval(test_input) == expected 总结 pytest是一个功能强大且易于使用的Python测试框架，可以帮助开发者编写简洁、可读性强的测试代码。通过本指南，您已经了解了pytest的基本使用方法，接下来可以探索更多高级功能。\n","date":"2025-03-20 13:42:48","updated":"2025-03-20 13:42:48"},{"objectID":"38bcd9a7db46baa1f01a8379f9ee8798","permalink":"https://bluespace3.github.io/post/docker%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","title":"docker常用命令","content":"docker pull ubuntu 载入ubuntu 镜像\ndocker pull training/webapp # 载入镜像\ndocker pull python:3.7 安装python镜像\ndocker pull nginx 安装nginx镜像\ndocker run -it python:3.7 /bin/bash 进入python镜像\n连接不上时，终端输入：\n1.cd \u0026ldquo;C:\\Program Files\\Docker\\Docker\u0026rdquo;\n2.DockerCli.exe -SwitchDaemon\ndocker run -it ubuntu /bin/bash 启用进入容器\nexit退出容器\ndocker run -d -P training/webapp python app.py 后台启用容器并随机映射到本机端口\ndocker run -d -p 5000:5000 training/webapp python app.py后台启用容器并指定映射到\ndocker logs -f id 查看应用日志\ndocker logs -f -t \u0026ndash;tail=100 dockerid 动态查看最新100条日志\ndocker top id 查看容器内部应用进程\ndocker ps -a 查看所有容器(可查容器id)\ndocker ps 查看在运行的容器\ndocker ps -l 查询最后一次创建的容器\ndocker start id 启用对应id的容器\ndocker restart id重启\ndocker stop id 停止\ndocker run -dit -p 5000:80 -v /opt/app/docker_app/tools_flask/tools:/usr/src/app/tools \u0026ndash;name tools-flask tools_flask; 启动容器并持久化docker目录\ndocker run -itd \u0026ndash;name ubuntu-test ubuntu /bin/bash 后台运行容器\ndocker exec -it id bash进入容器\ndocker export id \u0026gt; ubuntu.tar 导出容器\ncat docker/ubuntu.tar | docker import - test/ubuntu:v1 导入容器到镜像\ndocker rm -f id 删除容器\ndocker images 列出镜像列表\n镜像下载： https://hub.docker.com/\ndocker search 关键词搜索镜像\n传输文件\ndocker cp 本地文件的路径 container_id:\u0026lt;docker容器内的路径\u0026gt;\ndocker run -p 3000:80 -d \u0026ndash;name vueApp vuenginxcontainer\nDockerfile 来构建镜像\n1.创建Dockerfile 填写配置内容，参考：E:\\code\\flask_tools\\tools\\Dockerfile\n2.docker build -t flask_tools:v1 . Dockerfile当前目录构建镜像. 是基于当前目录的 。后面的.不能少\n3.docker run -p 5000:80 -d \u0026ndash;name flask2 flask_tools:v1 top bin/bash启用容器\ngunicorn -k gevent -c gunicorn.conf flask_index:app项目名 # 用gunicorn启动项目\n上传到docker hub\n先给要上传的仓库打上标签：\ndocker tag id tianqinghong/python_vue_share\n再push:\ndocker push tianqinghong/python_vue_share\n下载镜像\ndocker pull tianqinghong/python_vue_share\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"cce784bbf56e95887d3b91d2c43b5d2a","permalink":"https://bluespace3.github.io/post/git-submodule/","title":"Git submodule","content":" Git submodule添加子项目_库 Git归并策略 添加 删除 输入“/”快速插入内容\n添加图标\n添加封面\n展示文档信息\nGit submodule添加子项目_库\n开发过程中，经常会有一些通用的部分希望抽取出来做成一个公共库来提供给别的工程来使用，而公共代码库的版本管理是个麻烦的事情。git submodule命令就可以解决这个问题。\nGit归并策略\nGit归并有两种策略：递归，章鱼。\n1.递归策略：当分支数只有两个的时候。\n2.章鱼策略：当分支数大于两个的时候。\nGit会自动选择归并的方法。\n3.子树策略：是Git另一种归并方法。（submodule）\n它可以把另一个子项目，嵌入到当前项目。而且会非常聪明的合并这些子项目。\n添加\n为当前工程添加submodule，命令如下：\ngit submodule add 仓库地址 路径\n其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。\n注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）\n示例:\ngit submodule add -f http://git.cs/Cmblife_iOS_Internal/modulesLib.git\n-f 是强制的意思，一般不需要加\n命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。\n删除\nsubmodule的删除稍微麻烦点：首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。\n下载的工程带有submodule\n当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：\ngit submodule update –init –recursive\n即可将子模块内容下载下来后工程才不会缺少相应的文件。\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"3a042727eee1f3a2e50802c281941aff","permalink":"https://bluespace3.github.io/post/git%E6%B7%BB%E5%8A%A0%E5%AD%90%E9%A1%B9%E7%9B%AE/","title":"git子项目","content":" 项目中添加子项目 1、git clone 父项目url 2、cd 父项目对应目录下：git submodule add \u0026lt;子项目地址\u0026gt; 3、git commit ;git push 4、此时子项目下的子项目是空的，需要cd到父目录cmd执行： git submodule update \u0026ndash;init \u0026ndash;recursive 或者执行：git submodule init 然后执行git submodule update clone含嵌套项目的项目 git clone 父项目url \u0026ndash;recurse-submodules 不加\u0026ndash;recurse-submodules，克隆的子项目是空的 ","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"f22a5e3e399621c84c632acc9cb469d6","permalink":"https://bluespace3.github.io/post/hugo%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","title":"Hugo静态网站生成器入门指南","content":" 什么是Hugo？ Hugo是一个用Go语言编写的快速、现代的静态网站生成器。它可以将Markdown文件转换为HTML页面，非常适合构建文档网站、博客等。\nHugo的主要特点 极快的构建速度 丰富的主题支持 简单的Markdown内容管理 强大的模板系统 内置的短代码功能 安装Hugo 在Windows上安装Hugo的步骤：\n下载Hugo的Windows版本 解压到指定目录 将Hugo的可执行文件路径添加到系统环境变量 创建新站点 使用以下命令创建一个新的Hugo站点：\nhugo new site mydocs 下载插件 添加内容 在content目录下创建Markdown文件来添加内容：\nhugo new blog/my-first-post.md 运行开发服务器 使用以下命令启动开发服务器：\nhugo server -D --environment development #如果未设置环境变量则不需要指定环境。 部署网站 使用以下命令生成静态文件：\nhugo 然后将public目录下的文件部署到Web服务器即可，注意每次推送前运行hugo更新public文件夹 若有更新域名，请删除public后，再运行hugo重新生成public，否则会出现路由错误的情况。 为了方便新建.sh脚本文件，命名为.command.sh # 判断是否已初始化Git仓库 if [ ! -d \u0026#34;.git\u0026#34; ]; then echo \u0026#34;未检测到Git仓库，正在初始化...\u0026#34; git init else echo \u0026#34;Git仓库已初始化\u0026#34; fi # 创建.gitignore文件，排除不需要版本控制的文件 cat \u0026gt; .gitignore \u0026lt;\u0026lt; EOF resources/ .DS_Store node_modules/ .hugo_build.lock EOF # 添加所有文件 git add . # 提交更改 git commit -m \u0026#34;更新博客\u0026#34; # 检查是否已关联远程仓库 REMOTE_URL=$(git remote get-url origin 2\u0026gt;/dev/null) if [ -z \u0026#34;$REMOTE_URL\u0026#34; ]; then echo \u0026#34;未检测到远程仓库，正在添加...\u0026#34; git remote add origin https://github.com/bluespace3/bluespace3.github.io else echo \u0026#34;已关联远程仓库：$REMOTE_URL\u0026#34; fi # 推送到GitHub git push -u origin main --force 终端运行 ..command.sh 更新维护 后期维护有许多要留意的地方否则容易踩坑。\n新增文章，在项目根目录终端运行，hugo new content/post/文章名称 不同主题博客目录不一致，这里需要留意你下载主题的说明。\n生成的文章会自带字段，其中draft默认true需要维护成false或者删掉，否则视为草稿。如下：\ntitle: \u0026#34;测试平台教程\u0026#34; date: 2025-03-20T12:59:32+08:00 draft: false tags: [\u0026#34;测试平台\u0026#34;, \u0026#34;静态网站\u0026#34;, \u0026#34;教程\u0026#34;] 3.若只有一台电脑更新博客，可以只把public托管到github，若要多个终端更新。需要满足以下条件。\n终端的hugo版本和主题保持需要保持一致，建议把主题配置在hugo.toml文件里面。否则本地有多个主题时在运行时要指定主题。\nhugo -t hugo-theme-reimu\n需要把整个项目推到github，并且指定githubPage为存放public的分支。需要建立工作流，脚本如下。\nname: Deploy Hugo site on: push: branches: - main # 或者你的默认分支名 jobs: deploy: runs-on: ubuntu-latest permissions: contents: write # Ensure GITHUB_TOKEN has write access to contents steps: - uses: actions/checkout@v3 with: submodules: false # 确保自动拉取子模块 fetch-depth: 0 # 获取所有历史记录和标签 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: gh-pages # 部署到gh-pages分支 总结 Hugo是一个功能强大且易于使用的静态网站生成器，非常适合构建个人博客、文档网站等。\n优点是能快速构建，丰富的模板生态，方便的托管到github，后期维护成本低。\n缺点：只支持md格式，不支持在线编辑，因为只支持通过代码push到远程仓库更新，所以在切换终端时简直是噩梦，笔者在此处踩坑无数，特别需要注意这里。\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"12db3a910f18c71b8c7e8e4cca8bc24c","permalink":"https://bluespace3.github.io/post/linux%E5%AE%89%E8%A3%85python/","title":"linux安装python","content":"#依赖包\nyum -y groupinstall \u0026ldquo;Development tools\u0026rdquo;\nyum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel\n#下载 Python3\nwget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz\n#创建文件夹\nmkdir /usr/local/python3\n#解压编译安装\ntar -xvJf Python-3.6.2.tar.xz\ncd Python-3.6.2\n./configure \u0026ndash;prefix=/usr/local/python3\nmake \u0026amp;\u0026amp; make install\n#给个软链\nln -sf /usr/local/python3/bin/python3 /usr/bin/python3\nln -sf /usr/local/python3/bin/pip3 /usr/bin/pip3\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"3e571e1da8a6bdeae3e5cab575b2f549","permalink":"https://bluespace3.github.io/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"linux常用命令","content":" 文章目录 一、目录操作 1、批量操作 二、文件操作 三、文件内容操作（查看日志，更改配置文件） 1、grep(检索文件内容) 2、awk(数据统计) 3、sed(替换文件内容) 4、管道操作符 | 四、系统日志位置 五、创建与删除软连接 六、压缩和解压缩 七、Linux下文件的详细信息 八、常用的docker容器的命令： 九、运维常用命令 1、查看服务器端口号是否可用 十、yum常用命令 十一、其他命令 1、xargs 2、curl语法 十二、Linux内核优化 十三、用户权限操作 1、用户操作 2、添加组 3、sudo用户权限操作 4、更换文件所有者 十四、TOP 1、统计信息区 2、进程信息区 十五、文件安装 1、文件下载(lrzsz) 十六、文章PDF版本 Linux 系统目录\n├── bin -\u0026amp;gt; usr/bin # 用于存放二进制命令 ├── boot # 内核及引导系统程序所在的目录 ├── dev # 所有设备文件的目录（如磁盘、光驱等） ├── etc # 配置文件默认路径、服务启动命令存放目录 ├── home # 用户家目录，root用户为/root ├── lib -\u0026amp;gt; usr/lib # 32位库文件存放目录 ├── lib64 -\u0026amp;gt; usr/lib64 # 64位库文件存放目录 ├── media # 媒体文件存放目录 ├── mnt # 临时挂载设备目录 ├── opt # 自定义软件安装存放目录 ├── proc # 进程及内核信息存放目录 ├── root # Root用户家目录 ├── run # 系统运行时产生临时文件，存放目录 ├── sbin -\u0026amp;gt; usr/sbin # 系统管理命令存放目录 ├── srv # 服务启动之后需要访问的数据目录 ├── sys # 系统使用目录 ├── tmp # 临时文件目录 ├── usr # 系统命令和帮助文件目录 └── var # 存放内容易变的文件的目录 12345678910111213141516171819 一、目录操作 pwd 查看当前工作目录 clear 清除屏幕 cd ~ 当前用户目录 cd / 根目录 cd - 上一次访问的目录 cd .. 上一级目录 123456 查看目录内信息\nll 查看当前目录下内容（LL的小写） 1 …","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"7c53986d5cd2115b296310c538b9cfdb","permalink":"https://bluespace3.github.io/post/playwright%E7%9A%84python%E6%96%87%E6%A1%A3/","title":"playwright的python文档","content":" 安装 引言 Playwright 是专门为满足端到端测试的需求而创建的。Playwright 支持包括 Chromium、WebKit 和 Firefox 在内的所有现代渲染引擎。在 Windows、Linux 和 macOS 上进行测试，无论是本地还是在 CI 上，无论是无头模式还是有头模式，都可以使用原生移动设备仿真。\nPlaywright 库可以用作通用的浏览器自动化工具，为同步和异步 Python 提供了一套强大的 API 来自动化 Web 应用程序。\n本介绍描述了 Playwright Pytest 插件，这是编写端到端测试的推荐方式。\n你将学到\n如何安装 Playwright Pytest 如何运行示例测试 安装 Playwright Pytest Playwright 建议使用官方的 Playwright Pytest 插件来编写端到端测试。它提供了上下文隔离，并开箱即用地在多个浏览器配置上运行。\n首先，通过安装 Playwright 并运行示例测试来开始，亲眼看看它是如何工作的。\nPyPI Anaconda 安装所需的浏览器：\n添加示例测试 在当前工作目录或遵循 test_ 前缀约定的子目录中创建一个文件，例如 test_example.py，并在其中包含以下代码。确保你的测试名称也遵循 test_ 前缀约定。\ntest_example.py\nimport re from playwright.sync_api import Page, expect def test_has_title(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 期望标题“包含”一个子字符串。 expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) def test_get_started_link(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 点击“开始”链接。 page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() # 期望页面有一个名为“安装”的标题。 expect(page.get_by_role(\u0026#34;heading\u0026#34;, name=\u0026#34;Installation\u0026#34;)).to_be_visible() 运行示例测试 默认情况下，测试将在 Chromium 上运行。这可以通过 CLI 选项进行配置。测试以无头模式运行，这意味着在运行测试时不会打开浏览器 UI。测试结果和测试日志将在终端中显示。\n更新 Playwright 要将 Playwright 更新到最新版本，请运行以下命令：\npip install pytest-playwright playwright -U 系统要求 Python 3.8 或更高版本。 Windows 10+、Windows Server 2016+ 或 Windows Subsystem for Linux (WSL)。 MacOS 12 Monterey、MacOS 13 Ventura 或 MacOS 14 Sonoma。 Debian 11、Debian 12、Ubuntu 20.04 或 Ubuntu 22.04。 接下来是什么 使用 Web 优先断言、页面夹具和定位器编写测试 运行单个测试、多个测试、有头模式 使用 Codegen 生成测试 查看测试的跟踪 编写测试用例 引言 Playwright 测试很简单，它们\n执行操作 ， 断言状态与预期相符。 在执行操作之前没有必要等待任何东西：Playwright 在执行每个操作之前会自动等待一系列可操作性检查通过。\n也没有必要在执行检查时处理竞态条件 - Playwright 断言的设计方式是它们描述了最终需要满足的预期。\n就是这样！这些设计选择允许 Playwright 用户完全忘记他们测试中的不稳定超时和竞态检查。\n你将学到\n如何编写第一个测试 如何执行操作 如何使用断言 测试如何独立运行 如何使用测试钩子 第一个测试 查看以下示例，了解如何编写测试。注意文件名遵循 test_ 前缀约定，以及每个测试名称。\ntest_example.py\nimport re from playwright.sync_api import Page, expect def test_has_title(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 期望标题“包含”一个子字符串。 expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) def test_get_started_link(page: Page): page.goto(\u0026#34;https://playwright.dev/\u0026#34;) # 点击“开始”链接。 page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() # 期望页面有一个名为“安装”的标题。 expect(page.get_by_role(\u0026#34;heading\u0026#34;, name=\u0026#34;Installation\u0026#34;)).to_be_visible() 操作 导航 大多数测试将从导航到 URL 的页面开始。之后，测试将能够与页面元素进行交互。\npage.goto(\u0026#34;https://playwright.dev/\u0026#34;) Playwright 会等待页面达到加载状态，然后再继续。了解更多关于 page.goto() 选项的信息。\n交互 执行操作从定位元素开始。Playwright 使用 Locators API 进行此操作。定位器代表了在任何时刻在页面上查找元素（或元素组）的方式，了解更多关于可用的不同类型定位器的信息。Playwright 会在执行操作之前等待元素可操作，因此没有必要等待其变为可用。\n# 创建一个定位器。 get_started = page.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;) # 点击它。 get_started.click() 在大多数情况下，它会写成一行：\npage.get_by_role(\u0026#34;link\u0026#34;, name=\u0026#34;Get started\u0026#34;).click() 基本操作 这是最受欢迎的 Playwright 操作列表。请注意，还有更多操作，请确保查看定位器 API 部分以了解更多信息。\n操作 描述 locator.check() 检查输入复选框 locator.click() 点击元素 locator.uncheck() 取消检查输入复选框 locator.hover() 鼠标悬停在元素上 locator.fill() 填写表单字段，输入文本 locator.focus() 使元素获得焦点 locator.press() 按下单个键 locator.set_input_files() 选择上传的文件 locator.select_option() 在下拉菜单中选择选项 断言 Playwright 包括断言，这些断言会等待直到满足预期条件。使用这些断言可以使测试不脆弱且具有弹性。例如，这段代码会等待页面获得包含“Playwright”的标题：\nimport re from playwright.sync_api import expect expect(page).to_have_title(re.compile(\u0026#34;Playwright\u0026#34;)) 这是最受欢迎的异步断言列表。请注意，还有更多断言需要熟悉：\n断言 描述 expect(locator).to_be_checked() 复选框被选中 expect(locator).to_be_enabled() 控件被启用 expect(locator).to_be_visible() 元素可见 expect(locator).to_contain_text() 元素包含文本 expect(locator).to_have_attribute() 元素具有属性 expect(locator).to_have_count() 元素列表具有给定长度 expect(locator).to_have_text() 元素匹配文本`` expect(locator).to_have_value() 输入元素具有值`` expect(page).to_have_title() 页面具有标题`` expect(page).to_have_url() 页面具有 URL 测试隔离 Playwright Pytest 插件基于测试夹具的概念，例如内置的页面夹具，它被传递到你的测试中。由于浏览器上下文，页面在测试之间是隔离的，这相当于一个全新的浏览器配置文件，每个测试都获得一个新鲜环境，即使多个测试在单个浏览器中运行。\ntest_example.py\nfrom playwright.sync_api import Page def test_example_test(page: Page): pass # “page”属于一个独立的 BrowserContext，为这个特定测试创建。 def test_another_test(page: Page): pass # 这个第二个测试中的“page”与第一个测试完全隔离。 使用夹具 你可以使用各种夹具在测试之前或之后执行代码并共享对象。一个 function 作用域的夹具，例如带有 autouse 的，表现得像 beforeEach/afterEach。一个 module 作用域的夹具带有 autouse 表现得像 beforeAll/afterAll，它在所有测试之前和之后运行。\ntest_example.py\nimport pytest from playwright.sync_api import Page, expect @pytest.fixture(scope=\u0026#34;function\u0026#34;, autouse=True) def before_each_after_each(page: Page): print(\u0026#34;before the test runs\u0026#34;) # 在每个测试之前转到起始 URL。 page.goto(\u0026#34;https://playwright.dev/\u0026#34;) yield print(\u0026#34;after the test runs\u0026#34;) def test_main_navigation(page: Page): # 断言使用 expect API。 expect(page).to_have_url(\u0026#34;https://playwright.dev/\u0026#34;) 接下来是什么 运行单个测试，多个测试，有头模式 使用 Codegen 生成测试 查看测试的跟踪 在 CI 上运行测试与 GitHub Actions 生成测试 引言 Playwright 提供了开箱即用的测试生成能力，是快速开始测试的绝佳方式。它将打开两个窗口，一个浏览器窗口，您可以在其中与您想要测试的网站进行交互；另一个是 Playwright 检查器窗口，您可以在其中录制测试、复制测试、清除测试以及更改测试的语言。\n您将学到\n如何录制测试 如何生成定位器 运行 Codegen 使用 codegen 命令运行测试生成器，然后是您想要为其生成测试的网站的 URL。URL 是可选的，您也可以在不指定 URL 的情况下运行命令，然后在浏览器窗口中直接添加 URL。\nplaywright codegen demo.playwright.dev/todomvc 录制测试 运行 codegen 并在浏览器中执行操作。Playwright 将为用户交互生成代码。Codegen 将查看渲染后的页面并找出推荐的定位器，优先考虑角色、文本和测试 ID 定位器。如果生成器识别出多个元素与定位器匹配，它将改进定位器，使其更具弹性并唯一地识别目标元素，从而消除和减少由于定位器导致的测试失败和不稳定。\n使用测试生成器，您可以录制：\n通过简单地与页面交互，执行点击或填充等操作 通过点击工具栏上的一个图标，然后点击页面上的元素进行断言。您可以选择： 'assert visibility' 断言元素可见 'assert text' 断言元素包含特定文本 'assert value' 断言元素具有特定值 当您完成与页面的交互后，按下 'record' 按钮停止录制，并使用 'copy' 按钮将生成的代码复制到您的编辑器中。\n使用 'clear' 按钮清除代码以开始重新录制。完成后，关闭 Playwright 检查器窗口或停止终端命令。\n要了解更多关于生成测试的信息，请查看我们关于 Codegen 的详细指南。\n生成定位器 您可以使用测试生成器生成定位器。\n按下 'Record' 按钮停止录制，\u0026lsquo;Pick Locator\u0026rsquo;` 按钮将会出现。 点击 'Pick Locator' 按钮，然后将鼠标悬停在浏览器窗口的元素上，以查看定位器在每个元素下方突出显示。 要选择一个定位器，单击您想要定位的元素，该定位器的代码将出现在 Pick Locator 按钮旁边的定位器游乐场中。 然后您可以在定位器游乐场中编辑定位器以微调它，并看到匹配的元素在浏览器窗口中突出显示。 使用复制按钮复制定位器并将其粘贴到您的代码中。 仿真 您还可以使用仿真生成测试，以便为特定的视口、设备、颜色方案生成测试，以及模拟地理位置、语言或时区。测试生成器还可以在保持认证状态的同时生成测试。查看测试生成器指南以了解更多信息。\n接下来做什么 查看您的测试跟踪 运行和调试 引言 您可以运行单个测试、一组测试或所有测试。使用 --browser 标志，可以在一个浏览器或多个浏览器上运行测试。默认情况下，测试以无头模式运行，这意味着在运行测试时不会打开浏览器窗口，结果将在终端中显示。如果您愿意，可以通过使用 --headed CLI 参数以有头模式运行您的测试。\n您将学到\n如何从命令行运行测试 如何调试测试 运行测试 命令行 要运行您的测试，请使用 pytest 命令。这将默认在 Chromium 浏览器上运行您的测试。默认情况下，测试以无头模式运行，这意味着在运行测试时不会打开浏览器窗口，结果将在终端中显示。\n在有头模式下运行测试 要以有头模式运行您的测试，请使用 --headed 标志。这将在运行测试时打开浏览器窗口，并在完成后关闭浏览器窗口。\n在不同的浏览器上运行测试 要指定您想要运行测试的浏览器，请使用 --browser 标志，后跟浏览器的名称。\n要指定要在多个浏览器上运行测试，请多次使用 --browser 标志，后跟每个浏览器的名称。\npytest --browser webkit --browser firefox 运行特定测试 要运行单个测试文件，请传入您想要运行的测试文件的名称。\n要运行一组测试文件，请传入您想要运行的测试文件的名称。\npytest tests/test_todo_page.py tests/test_landing_page.py 要运行特定测试，请传入您想要运行的测试的函数名称。\npytest -k test_add_a_todo_item 并行运行测试 要并行运行您的测试，请使用 --numprocesses 标志，后跟您想要运行测试的进程数量。我们建议使用逻辑 CPU 核心数的一半。\n（这假设已安装了 pytest-xdist。有关更多信息，请参见此处。）\n有关更多信息，请参见 Playwright Pytest 使用情况或 Pytest 文档以了解一般 CLI 使用情况。\n调试测试 由于 Playwright 在 Python 中运行，您可以使用您选择的调试器进行调试，例如使用 Visual Studio Code 中的 Python 扩展。Playwright 带有 Playwright 检查器，允许您逐步执行 Playwright API 调用，查看它们的调试日志并探索定位器。\n要调试所有测试，请运行以下命令。\nBash PowerShell Batch 要调试一个测试文件，请在命令后运行您想要调试的测试文件的名称。\nBash PowerShell Batch PWDEBUG=1 pytest -s test_example.py 要调试特定测试，请添加 -k 后跟您想要调试的测试的名称。\nBash PowerShell Batch PWDEBUG=1 pytest -s -k test_get_started_link 此命令将打开浏览器窗口以及 Playwright 检查器。您可以使用检查器顶部的步过按钮逐步执行您的测试。或者按下播放按钮从开始到结束运行您的测试。一旦测试完成，浏览器窗口将关闭。\n在调试时，您可以使用选择定位器按钮来选择页面上的元素，并查看 Playwright 用于查找该元素的定位器。您还可以编辑定位器并实时在浏览器窗口中看到它被高亮显示。使用复制定位器按钮将定位器复制到剪贴板，然后将其粘贴到您的测试中。\n查看我们的调试指南，以了解更多关于 Playwright 检查器以及使用浏览器开发工具进行调试的信息。\n接下来做什么 使用 Codegen 生成测试 查看您的测试跟踪 在 CI 上使用 GitHub Actions 运行您的测试 跟踪查看器 介绍 Playwright Trace Viewer 是一个图形用户界面（GUI）工具，允许您探索录制的 Playwright 测试跟踪，这意味着您可以前后浏览测试的每个动作，并直观地看到每个动作期间发生了什么。\n您将学到\n如何录制跟踪 如何打开 HTML 报告 如何打开跟踪查看器 录制跟踪 可以通过使用 --tracing 标志运行测试来录制跟踪。\n跟踪的选项有：\non: 为每个测试录制跟踪 off: 不录制跟踪。（默认） retain-on-failure: 为每个测试录制跟踪，但删除成功测试运行的所有跟踪。 这将录制跟踪并将其放入 test-results 目录中名为 trace.zip 的文件中。\n如果您没有使用 Pytest，请点击这里了解如何录制跟踪。\n同步 异步 browser = chromium.launch() context = browser.new_context() # 在创建/导航页面之前开始跟踪。 context.tracing.start(screenshots=True, snapshots=True, sources=True) page = context.new_page() page.goto(\u0026#34;https://playwright.dev\u0026#34;) # 停止跟踪并将其导出到 zip 归档中。 context.tracing.stop(path=\u0026#34;trace.zip\u0026#34;) 打开跟踪 您可以使用 Playwright CLI 或在 trace.playwright.dev 上的浏览器中打开保存的跟踪。确保添加您的 trace.zip 文件所在的完整路径。这应该包括 test-results 目录，然后是测试名称，最后是 trace.zip。\nplaywright show-trace trace.zip 查看跟踪 通过点击每个动作或使用时间线悬停来查看测试的跟踪，并查看动作前后页面的状态。在测试的每个步骤期间检查日志、源代码和网络。跟踪查看器创建了一个 DOM 快照，因此您可以完全与之交互，打开开发工具等。\n要了解更多信息，请查看我们关于跟踪查看器的详细指南。\n接下来是什么 在 GitHub Actions 上运行 CI 测试 了解更多关于跟踪查看器的信息 Pytest 插件来编写端到端测试 引言 Playwright 提供了一个 Pytest 插件来编写端到端测试。要开始使用它，请参考入门指南。\n使用方法 要运行测试，请使用 Pytest 命令行界面。\npytest --browser webkit --headed 如果你想自动添加命令行参数而不需要明确指定它们，你可以使用 pytest.ini 文件：\n# pytest.ini 文件的内容 [pytest] # 使用 UI 运行 firefox addopts = --headed --browser firefox 命令行参数 请注意，命令行参数仅应用于默认的 browser、context 和 page 固定装置。如果你使用 API 调用如 browser.new_context() 创建浏览器、上下文或页面，命令行参数将不会应用。\n--headed：以有头模式运行测试（默认：无头）。 --browser：在不同的浏览器中运行测试 chromium、firefox 或 webkit。可以多次指定（默认：chromium）。 --browser-channel：要使用的浏览器渠道。 --slowmo：通过指定的毫秒数减慢 Playwright 操作。这样你可以看清楚发生了什么（默认：0）。 --device：要模拟的设备。 --output：由测试产生的工件目录（默认：test-results）。 --tracing：是否为每个测试记录跟踪。on、off 或 retain-on-failure（默认：off）。 --video：是否为每个测试录制视频。on、off 或 retain-on-failure（默认：off）。 --screenshot：是否在每个测试后自动捕获屏幕截图。on、off 或 only-on-failure（默认：off）。 --full-page-screenshot：在失败时是否拍摄整个页面的屏幕截图。默认情况下，只捕获视口。需要启用 --screenshot（默认：off）。 固定装置 这个插件为 pytest 配置了 Playwright 特定的固定装置。要使用这些固定装置，将固定装置名称作为参数传递给测试函数。\ndef test_my_app_is_working(fixture_name): pass # 使用 fixture_name 进行测试 # ... 函数范围 ：当在测试函数中请求时，这些固定装置被创建，并在测试结束时销毁。\ncontext：测试的新浏览器上下文。 page：测试的新浏览器页面。 new_context：允许为测试创建不同的浏览器上下文。适用于多用户场景。接受与 browser.new_context() 相同的参数。 会话范围 ：当在测试函数中请求时，这些固定装置被创建，并在所有测试结束时销毁。\nplaywright：Playwright 实例。 browser_type：当前浏览器的 BrowserType 实例。 browser：由 Playwright 启动的浏览器实例。 browser_name：浏览器名称字符串。 browser_channel：浏览器渠道字符串。 is_chromium、is_webkit、is_firefox：相应浏览器类型的布尔值。 自定义固定装置选项 ：对于 browser 和 context 固定装置，使用以下固定装置定义自定义启动选项。\nbrowser_type_launch_args：覆盖 browser_type.launch() 的启动参数。它应该返回一个字典。 browser_context_args：覆盖 browser.new_context() 的选项。它应该返回一个字典。 也可以通过使用 browser_context_args 标记来覆盖单个测试的上下文选项（browser.new_context()）：\nimport pytest @pytest.mark.browser_context_args(timezone_id=\u0026#34;Europe/Berlin\u0026#34;, locale=\u0026#34;en-GB\u0026#34;) def test_browser_context_args(page): assert page.evaluate(\u0026#34;window.navigator.userAgent\u0026#34;) == \u0026#34;Europe/Berlin\u0026#34; assert page.evaluate(\u0026#34;window.navigator.languages\u0026#34;) == [\u0026#34;de-DE\u0026#34;] 并行性：同时运行多个测试 如果你的测试在拥有大量 CPU 的机器上运行，你可以通过使用 pytest-xdist 同时运行多个测试来加快测试套件的整体执行时间：\n# 安装依赖 pip install pytest-xdist # 使用 --numprocesses 标志 pytest --numprocesses auto 根据硬件和测试的性质，你可以将 numprocesses 设置为从 2 到机器上的 CPU 数量。如果设置得太高，你可能会注意到意外的行为。\n有关 pytest 选项的一般信息，请参见运行测试。\n示例 为自动补全配置 Mypy 类型 test_my_application.py\nfrom playwright.sync_api import Page def test_visit_admin_dashboard(page: Page): page.goto(\u0026#34;/admin\u0026#34;) # ... 配置慢动作 使用 --slowmo 参数运行测试。\n将 Playwright 操作减慢 100 毫秒。\n按浏览器跳过测试 test_my_application.py\nimport pytest @pytest.mark.skip_browser(\u0026#34;firefox\u0026#34;) def test_visit_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) # ... 在特定浏览器上运行 conftest.py\nimport pytest @pytest.mark.only_browser(\u0026#34;chromium\u0026#34;) def test_visit_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) # ... 使用自定义浏览器渠道，如 Google Chrome 或 Microsoft Edge pytest --browser-channel chrome test_my_application.py\ndef test_example(page): page.goto(\u0026#34;https://example.com\u0026#34;) 配置基础 URL 使用 base-url 参数启动 Pytest。pytest-base-url 插件用于此目的，它允许你从配置、命令行参数或固定装置中设置基础 URL。\npytest --base-url http://localhost:8080 test_my_application.py\ndef test_visit_example(page): page.goto(\u0026#34;/admin\u0026#34;) # -\u0026gt; 将导致 http://localhost:8080/admin 忽略 HTTPS 错误 conftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args): return { **browser_context_args, \u0026#34;ignore_https_errors\u0026#34;: True } 使用自定义视口大小 conftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args): return { **browser_context_args, \u0026#34;viewport\u0026#34;: { \u0026#34;width\u0026#34;: 1920, \u0026#34;height\u0026#34;: 1080, } } 设备模拟 conftest.py\nimport pytest @pytest.fixture(scope=\u0026#34;session\u0026#34;) def browser_context_args(browser_context_args, playwright): iphone_11 = playwright.devices[\u0026#39;iPhone 11 Pro\u0026#39;] return { **browser_context_args, **iphone_11, } 或通过命令行 --device=\u0026quot;iPhone 11 Pro\u0026quot;。\n与 unittest.TestCase 一起使用 查看以下示例，了解如何将其与 unittest.TestCase 一起使用。这有一个限制，即只能指定单个浏览器，并且在指定多个浏览器时不会生成多个浏览器的矩阵。\nimport pytest import unittest from playwright.sync_api import Page class MyTest(unittest.TestCase): @pytest.fixture(autouse=True) def setup(self, page: Page): self.page = page def test_foobar(self): self.page.goto(\u0026#34;https://microsoft.com\u0026#34;) self.page.locator(\u0026#34;#foobar\u0026#34;).click() assert self.page.evaluate(\u0026#34;1 + 1\u0026#34;) == 2 调试 与 pdb 一起使用 在你的测试代码中使用 breakpoint() 语句来暂停执行并获得 pdb REPL。\ndef test_bing_is_working(page): page.goto(\u0026#34;https://bing.com\u0026#34;) breakpoint() # ... 部署到 CI 请参阅 CI 提供商的指南，了解如何将你的测试部署到 CI/CD。\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"4a1b928e3c63fd8923914d2ab435b23f","permalink":"https://bluespace3.github.io/post/python%E9%9D%9E%E5%90%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%E8%B0%83%E7%94%A8%E6%8A%A5%E9%94%99/","title":"python常见踩坑记录","content":" 项目结构： 问题： 执行文件调用dir1，间接调用dir2。执行时报错：“ModuleNotFoundError: No module named \u0026lsquo;dir1.dir2\u0026rsquo;;”\n解决方法： dir1文件导包时做处理。\n主函数加入这四行，将项目的根目录(webapp)的路径加入到系统PATH中； import os,sys\nfrom pathlib import Path\nsys.path[0] = str(Path(sys.path[0]).parent.parent)\nsys.path.append(os.getcwd())\n且导包从项目执行入口文件同级开始写\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"45ba9db719e75034427b613b50aa9f42","permalink":"https://bluespace3.github.io/post/python%E4%B8%AD%E7%9A%84os%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/","title":"python的os模块使用","content":" os.listdir(path) 获取文件夹下全部文件，的列表 os.path.join(path1,path2) 将路径path1和路径path2拼接成新的路径，path1//path2 base_dir = os.path.dirname(os.path.abspath(file)) 获取当前文件的绝对路径 input_file = os.path.join(base_dir, \u0026quot;../resource/swaggerApi/clinic-ysb-app_OpenAPI.json\u0026quot;) ","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"a603e31acc22e0f93fb8dd100f961903","permalink":"https://bluespace3.github.io/post/scrapy%E7%88%AC%E6%9F%9A%E5%AD%90%E7%BD%91%E7%A4%BA%E4%BE%8B/","title":"scrapy爬柚子网示例","content":"柚子网https://www.uu-zz.com/\n爬取页码\n遍历页面内对应的视频集的链接\n遍历视频内子视频链接\n!\nhttps://www.uu-zz.com/+子视频链接，发送get请求\n!\n获得m3u8文件，储存在数据库\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"b69ce1d47769702cf8ea3e64d79c416d","permalink":"https://bluespace3.github.io/post/unnitest%E7%AC%94%E8%AE%B0/","title":"unnitest","content":" 一、引入 1.导包，import unnitest 2.编写测试类，继承unnitest 二、运行 1.unnitest.main(),运行全部用例\n2.测试套：testsuite\n创建：suite=unnitest.Testsuite()\n测试套添加用例：suite.addtTest（类（方法））\n运行：runner=unnitest.TextTestRunner()\n运行：runner.run(suite) *运行必须在命令行运行否则是运行全部用例\n三、生成报告\n1.将HTMLTestRunner.py文件放到项目文件夹下 2.导包：如左图 3.创建测试套，参考上方 4.创建测试报告文件，且以测试套运行（参考左图） 与pytest的异同 pytest以mark方式组织用例（而非套件） 面试相关 pycharm关闭pytest测试模式 ","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"49bc9ec70fcee766ab01b877cfaa0ee5","permalink":"https://bluespace3.github.io/post/%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/","title":"提示词技巧","content":"提示词技巧 总结：\n官方提示词库： https://api-docs.deepseek.com/zh-cn/prompt-library\n","date":"2025-03-20 12:59:32","updated":"2025-03-20 12:59:32"},{"objectID":"adb0e7ab024700427ad6c3ce7f8a7d62","permalink":"https://bluespace3.github.io/post/go%E8%AF%AD%E8%A8%80--%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E9%85%8D/","title":"go语言--安装和环境搭配","content":" 一.Go简介 Go 语言（又称 Golang）是由 Google 开发的一种开源编程语言，于 2009 年正式对外发布。下面从多个方面为你介绍它：\n设计目标 Go 语言的设计初衷是为了解决大规模软件开发中的一些问题，比如编译速度慢、并发编程复杂、代码可维护性差等。所以它结合了静态语言的性能优势和动态语言的开发效率。\n特点 高效的编译和执行：Go 语言拥有快速的编译速度，这使得开发过程更加流畅。同时，它的执行效率也很高，能充分利用现代多核处理器的性能。 内置并发支持：Go 语言原生支持并发编程，通过goroutine和channel可以很方便地实现高并发程序。goroutine是一种轻量级的线程，占用资源少，创建和销毁的开销小；channel则用于goroutine之间的通信和同步。 垃圾回收机制：它具备自动垃圾回收功能，开发者无需手动管理内存，减少了内存泄漏的风险，提高了开发效率。 丰富的标准库：标准库涵盖了网络编程、文件操作、加密解密等多个领域，为开发者提供了便利，减少了对第三方库的依赖。 跨平台支持：可以在不同的操作系统和硬件平台上编译和运行，方便开发跨平台的应用程序。 应用场景 云计算与容器编排：像 Docker 和 Kubernetes 这类知名项目，就是用 Go 语言开发的。 网络编程：由于其出色的并发性能和网络库，Go 语言非常适合开发网络服务器、代理服务器等。 分布式系统：在分布式系统中，Go 语言的并发模型和网络编程能力使其能够高效地处理大量的并发请求。 二、Go语言安装与配置 Go语言支持以下系统：Linux、Mac、Windows。\n安装包下载地址：The Go Programming Language\nwindows 直接安装系统下载安装即可！\nLinux 将下载的二进制包解压至/usr/local目录 tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz AI写代码 将 /usr/local/go/bin 目录添加至 PATH 环境变量： 可以编辑 /etc/profile，并将以下命令添加该文件的末尾，这样就可以永久生效：\nexport PATH=$PATH:/usr/local/go/bin AI写代码 然后执行\nsource /etc/profileAI写代码 三.编写基本测试用例 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;)}AI写代码 go build 文件名+ 运行程序=go run文件名AI写代码 ","date":"2025-03-15 11:00:00","updated":"2025-03-15 11:00:00"},{"objectID":"74af066d4a1c0bbe8273c84297a75bcc","permalink":"https://bluespace3.github.io/post/mac%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E9%80%9F%E8%AE%B0/","title":"mac使用笔记","content":"在Mac终端中，有几种方法可以连续删除命令：\n使用 Ctrl + W ：删除光标前的一个单词 使用 Ctrl + U ：删除光标前的整行内容 使用 Ctrl + K ：删除光标后的整行内容 使用 Option + Delete ：删除光标前的一个单词（与 Ctrl + W 类似） 这些快捷键可以帮助你快速删除命令内容，提高终端操作效率。 ","date":"2025-03-15 11:00:00","updated":"2025-03-15 11:00:00"},{"objectID":"14ca7946f879a014b5a236b7ab4fddf0","permalink":"https://bluespace3.github.io/post/mysql----%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/","title":"数据库使用笔记","content":" 数据库的查询是数据库使用中比较重要的环节，前面的基础查询比较简单，不做介绍，可自行查阅。本文主要介绍复合查询，并结合用例进行讲解。\n本文的用例依据Soctt模式的经典测试表，可以自行下载，也可以自己创建\n链接：点这里跳转\n自行创建步骤如下：\n0、预备工作 0.1 建表 -- 创建 dept 表（部门表） CREATE TABLE dept ( deptno INT PRIMARY KEY, -- 部门编号 dname VARCHAR(14), -- 部门名称 loc VARCHAR(13) -- 部门位置 ); -- 创建 emp 表（员工表） CREATE TABLE emp ( empno INT PRIMARY KEY, -- 员工编号 ename VARCHAR(10), -- 员工姓名 job VARCHAR(9), -- 职位 mgr INT, -- 上级经理编号 hiredate DATE, -- 入职日期 sal DECIMAL(7,2), -- 工资 comm DECIMAL(7,2), -- 奖金 deptno INT, -- 部门编号 FOREIGN KEY (deptno) REFERENCES dept(deptno) ); -- 创建 salgrade 表（工资等级表） CREATE TABLE salgrade ( grade INT PRIMARY KEY, -- 工资等级 losal DECIMAL(7,2), -- 最低工资 hisal DECIMAL(7,2) -- 最高工资 ); 1234567891011121314151617181920212223242526AI写代码 0.2 插入测试数据 -- 插入 dept 表数据 INSERT INTO dept (deptno, dname, loc) VALUES (10, \u0026#39;ACCOUNTING\u0026#39;, \u0026#39;NEW YORK\u0026#39;), (20, \u0026#39;RESEARCH\u0026#39;, \u0026#39;DALLAS\u0026#39;), (30, \u0026#39;SALES\u0026#39;, \u0026#39;CHICAGO\u0026#39;), (40, \u0026#39;OPERATIONS\u0026#39;, \u0026#39;BOSTON\u0026#39;); -- 插入 emp 表数据 INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES (7369, \u0026#39;SMITH\u0026#39;, \u0026#39;CLERK\u0026#39;, 7902, \u0026#39;1980-12-17\u0026#39;, 800.00, NULL, 20), (7499, \u0026#39;ALLEN\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-02-20\u0026#39;, 1600.00, 300.00, 30), (7521, \u0026#39;WARD\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-02-22\u0026#39;, 1250.00, 500.00, 30), (7566, \u0026#39;JONES\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-04-02\u0026#39;, 2975.00, NULL, 20), (7654, \u0026#39;MARTIN\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-09-28\u0026#39;, 1250.00, 1400.00, 30), (7698, \u0026#39;BLAKE\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-05-01\u0026#39;, 2850.00, NULL, 30), (7782, \u0026#39;CLARK\u0026#39;, \u0026#39;MANAGER\u0026#39;, 7839, \u0026#39;1981-06-09\u0026#39;, 2450.00, NULL, 10), (7788, \u0026#39;SCOTT\u0026#39;, \u0026#39;ANALYST\u0026#39;, 7566, \u0026#39;1982-12-09\u0026#39;, 3000.00, NULL, 20), (7839, \u0026#39;KING\u0026#39;, \u0026#39;PRESIDENT\u0026#39;, NULL, \u0026#39;1981-11-17\u0026#39;, 5000.00, NULL, 10), (7844, \u0026#39;TURNER\u0026#39;, \u0026#39;SALESMAN\u0026#39;, 7698, \u0026#39;1981-09-08\u0026#39;, 1500.00, 0.00, 30), (7876, \u0026#39;ADAMS\u0026#39;, \u0026#39;CLERK\u0026#39;, 7788, \u0026#39;1983-01-12\u0026#39;, 1100.00, NULL, 20), (7900, \u0026#39;JAMES\u0026#39;, \u0026#39;CLERK\u0026#39;, 7698, \u0026#39;1981-12-03\u0026#39;, 950.00, NULL, 30), (7902, \u0026#39;FORD\u0026#39;, \u0026#39;ANALYST\u0026#39;, 7566, \u0026#39;1981-12-03\u0026#39;, 3000.00, NULL, 20), (7934, \u0026#39;MILLER\u0026#39;, \u0026#39;CLERK\u0026#39;, 7782, \u0026#39;1982-01-23\u0026#39;, 1300.00, NULL, 10); -- 插入 salgrade 表数据 INSERT INTO salgrade (grade, losal, hisal) VALUES (1, 700, 1200), (2, 1201, 1400), (3, 1401, 2000), (4, 2001, 3000), (5, 3001, 9999); 12345678910111213141516171819202122232425262728293031AI写代码 创建好以后，如果表的内容和下图一样，那基本就没问题了\n1、复合表的查询 1.查询工资高于500 或 岗位为MANAGER 的雇员，同时还要满足他们的姓名首字母为大写的J\n根据上述的要求，我们可以发现，要查询的表总共两个条件，工资高于500 或 岗位为MANAGER， 首字母为J。 根据上述的两个条件，我们可以写出对应的sql查询语句： select name, job , sal from emp where (sal \u0026gt;= 500 or job = 'MANAGER') and enum like 'J%'; 这两个条件可以看成是并列条条件\n2.按照部门号升序而雇员工资降序的顺序对表的内容排序\n先观察一下这里的需求，首先就是要部门号升序，然后就是雇员的工资降序，所以这个案例的需求非常简单。根据这个要求我们可以写出sql查询语句：select deptno , sal from emp order by deptno asc , sal desc;\n3. 使用年薪进行降序排序\n这里我们需要特别注意的一个点就是年薪这个概念，年薪在这里是包括了12个月的月薪加上奖金，而这里奖金就是comm，但是奖金这一列很多都是NULL，而NULL是不参与计算的，所以这里就需要用ifnull(expression ，values)**(如果expression为null，返回的值为values否则返回expression)**利用这个函数的特点，我们就可以算出年薪 = 12 x sal + ifnull(comm,0)； 根据这个要求我们可以写出sql查询语句：select sal * 12 + ifnull(comm,0) 年薪 from emp order by 年薪 desc;\n4.显示工资最高的员工名字和工作岗位\n这条语句的要求非常简单，我们可以直接写出对应sql查询语句： select ename , job from emp where sal = (select max(sal) from emp);这里select是可以嵌套使用的，执行顺序就和C语言的中函数一样。当然，这里我们也可以分两步走，先把最高工资打印出来，再让第二条语句中 sal = 最高工资，结果是一样的。\n5. 显示工资高与平均工资的员工信息\n这个例子的要求和上面一个例子相差无几，做法也都差不多，先求出平均工资，再作比较即可。我们可以直接写出对应sql查询语句：select * from emp where sal \u0026gt;= (select avg(sal) from emp);\n6.显示每个部门的平均工资与最高工资\n这里也是只有两个条件，我们将平均工资和最高工资列出即可。我们可以直接写出对应sql查询语句：select deptno ,avg(sal),max(sal) from emp group by deptno;这里是先分组，然后再对内中内容进行筛查。\n7.显示平均工资低于两千的部门号和它的平均工资\n这个例子就需要和上面的例子一样，先对部门进行分组，分完组后就可以计算平均工资，然后再比对工资低于两千的部门。根据上述的条件，我们可以直接写出对应sql查询语句：select deptno ,avg(sal) 平均工资 from emp group by deptno having 平均工资 \u0026lt; 2000;这里的having是最后执行的，所以可以使用平均工资这个别名。\n8.显示每种岗位的雇员总数，平均工资\n这个例子和上面几个例子大差不差，这里不再赘述，直接把对应的语句写出：select deptno ,count(job) 人数,avg(sal) 平均工资 from emp group by job;\n2、多表复合查询 前面我们介绍了单张表下的复合查询，但在日常生活中还存在非常的多表查询的情况。\n1、显示每一个雇员名，雇员工资和部门名称\n这个例子中和上面不同就是我们需要去查询部门名称，部门名称是在dept这张表中，而雇员名称以及工资在emp这张表中。这就需要我们将两张表的内容合并成一张表，也就是对第一张表的每一行内容与第二张表整张表进行组合，这种穷举的方式也叫作笛卡尔积。当然这种方式会生成很多没有啥意义的组合(部门号不对应)。这里我们就可以使用where进行筛查，select * from emp, dept where emp.deptno = dept.deptno结果如下图\n![\u0026gt;\n经过上述sql语句的筛查基本已经把要求给完成了，我们这里稍微完善一下即可：select ename,sal,dname from emp, dept where emp.deptno = dept.deptno\n3、自链接 前面我们了解了不同表之间的进行链接查询，下面介绍一下同一张表之间链接。以下面这个例子为例：**a.显示员工FORD的上级领导的编号和姓名（mgr是员工领导的编号–empno）。**这个例子中，我们需要将在FORD的领导编号查出，然后在从当前这张表中查领导的相关信息。由此我们可以写出对应的sql语句：select empno,ename from emp where emp.empno=(select mgr from emp where ename=‘FORD’); 4、子查询 **概念：子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询。**前面已有描述，这里就不再赘述\n4.1、单行子查询 单行子查询表示的就是返回结果只有一行的子查询，以下面这一个通过下面这个例子帮助了解：\n显示SMITH同一部门的员工\n这个案例比较简单，我们只需先对SMITH先做子查询即可：select * from emp where deptno = (select deptno from emp where ename=‘smith’); 4.3、多行子查询 这种子查询返回结果有很多行，但是原本子查询返回结果只有一行，所以这里我们需要将引入一些关键字，才能使其达到多行子查询的效果。\nin关键字 all关键字 any关键字 首先我们可以通过一个例子了解一下in关键字：a.查询和10号部门的工作岗位相同的雇员的名字，岗位，工资，部门号，但是不包含10自己.\n在这个例子中，我们要先查询10号部门的工作岗位相同的雇员，然后才是其它的相关信息，最后剔除十号部门。\n第一步：select distinct job from emp where deptno=10;\n第二步：select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10);这里的in在where中作为一种条件判断，表示判断job否在子查询中的表中。\n第三步：select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10) and deptno\u0026lt;\u0026gt;10;\n然后，我们通过另外一个例子来增加对all的理解：**显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号.**这里的all关键字其实和上面的in关键字一样，也是where中作为一种条件判断，代表子查询的所有结果。我们可以直接写出对应的sql语句：select ename, sal, deptno from emp where sal \u0026gt; all(select sal from emp where deptno=30); 最后一个any，作用和上面两个关键字大同小异，表示子查询的任意一个结果，用一个例子帮助理解：显示工资比部门30的任意员工的工资高的员工的姓名、工资和部门号（包含自己部门的员工）.，对应的sql语句：select ename, sal, deptno from emp where sal \u0026gt; any(select sal from emp where deptno=30); 4.4、多列子查询 单行子查询是指子查询只返回单列，单行数据；多行子查询是指返回单列多行数据，都是针对单列而言的，而多列子查询则是指查询返回多个列数据的子查询语句。以下面例子为例：查询和SMITH的部门和岗位完全相同的所有雇员，不含SMITH本人这里第一步就是筛出SMITH部门和岗位相同的雇员，然后剔除SMITH，我们可以用括号的方式来对子查询各列的数据进行查询比对，具体方式如下： select ename from emp where (deptno, job)=(select deptno, job from emp where ename=‘SMITH’) and ename \u0026lt;\u0026gt; ‘SMITH’;\n4.5、from字句中使用子查询 通过对前面的相关知识的了解，我们可以知道，子查询本质其实就是一张新的临时表，所以本质上我们查表都是在查一张表，就是将临时表和原表进行处理后的一张新表。既然上面 where 后面能够使用子查询，那from后面也必然是可以使用子查询的。from后面使用子查询就是将子查询生成的临时表与另外的表做笛卡尔积生成新的表，在从新的表中对数据进行筛查。下面用一个例子来帮助理解：显示每个高于自己部门平均工资的员工的姓名、部门、工资、平均工资\n对应的sql语句：//获取各个部门的平均工资，将其看作临时表 select ename, deptno, sal, format(asal,2) from emp, (select avg(sal) asal, deptno dt from emp group by deptno) tmp where emp.sal \u0026gt; tmp.asal and emp.deptno=tmp.dt;需要 需要注意的时from中子查询形成的临时表要有临时的名称。\n5、合并查询 由于这个合并查询并不多见，使用率也较低，所以这里简单介绍即可。\nunion操作符：该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中的重复行。例子：将工资大于2500或职位是MANAGER的人找出来。 sql语句：select ename, sal, job from emp where sal\u0026gt;2500 union select ename, sal, job fromemp where job='MANAGER';\nunion all操作符：该操作符用于取得两个结果集的并集。当使用该操作符时，不会去掉结果集中的重复行。例子：将工资大于25000或职位是MANAGER的人找出来。sql语句：select ename, sal, job from emp where sal\u0026gt;2500 union all select ename, sal, job from emp where job='MANAGER';\n","date":"2025-03-15 11:00:00","updated":"2025-03-15 11:00:00"}]